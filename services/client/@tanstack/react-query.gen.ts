// This file is auto-generated by @hey-api/openapi-ts

import {
  type Options,
  deleteUser,
  getUserByUuid,
  updateUser,
  deleteTrainingBranch,
  getTrainingBranchByUuid,
  updateTrainingBranch,
  getRule,
  updateRule,
  deleteStudent,
  getStudentById,
  updateStudent,
  deleteAssessmentRubric,
  getAssessmentRubricByUuid,
  updateAssessmentRubric,
  deleteScoringLevel,
  getScoringLevel,
  updateScoringLevel,
  updateMatrixCell,
  deleteRubricCriterion,
  updateRubricCriterion,
  deleteRubricScoring,
  updateRubricScoring,
  deleteQuiz,
  getQuizByUuid,
  updateQuiz,
  deleteQuizQuestion,
  updateQuizQuestion,
  deleteQuestionOption,
  updateQuestionOption,
  deleteTrainingProgram,
  getTrainingProgramByUuid,
  updateTrainingProgram,
  deleteProgramRequirement,
  updateProgramRequirement,
  removeProgramCourse,
  updateProgramCourse,
  deleteOrganisation,
  getOrganisationByUuid,
  updateOrganisation,
  deleteTrainingBranch1,
  getTrainingBranchByUuid1,
  updateTrainingBranch1,
  deleteInstructor,
  getInstructorByUuid,
  updateInstructor,
  deleteInstructorSkill,
  updateInstructorSkill,
  deleteInstructorMembership,
  updateInstructorMembership,
  deleteInstructorExperience,
  updateInstructorExperience,
  deleteInstructorEducation,
  updateInstructorEducation,
  deleteInstructorDocument,
  updateInstructorDocument,
  deleteCourse,
  getCourseByUuid,
  updateCourse,
  deleteCourseTrainingRequirement,
  updateCourseTrainingRequirement,
  setPrimaryRubric,
  updateAssociation,
  deleteCourseRequirement,
  updateCourseRequirement,
  deleteCourseLesson,
  getCourseLesson,
  updateCourseLesson,
  deleteLessonContent,
  updateLessonContent,
  deleteCourseAssessment,
  updateCourseAssessment,
  deleteCourseCreator,
  getCourseCreatorByUuid,
  updateCourseCreator,
  deleteCourseCreatorSkill,
  updateCourseCreatorSkill,
  deleteCourseCreatorMembership,
  updateCourseCreatorMembership,
  deleteCourseCreatorExperience,
  updateCourseCreatorExperience,
  deleteCourseCreatorEducation,
  updateCourseCreatorEducation,
  deleteCourseCreatorCertification,
  updateCourseCreatorCertification,
  deleteGradingLevel,
  updateGradingLevel,
  deleteDifficultyLevel,
  updateDifficultyLevel,
  deleteContentType,
  updateContentType,
  deleteCategory,
  getCategoryByUuid,
  updateCategory,
  updateCatalogItem,
  deactivateClassDefinition,
  getClassDefinition,
  updateClassDefinition,
  getLessonPlan,
  saveLessonPlan,
  deleteCertificate,
  getCertificateByUuid,
  updateCertificate,
  deleteCertificateTemplate,
  updateCertificateTemplate,
  deleteAssignment,
  getAssignmentByUuid,
  updateAssignment,
  updateCurrency,
  uploadProfileImage,
  getAllTrainingBranches,
  createTrainingBranch,
  checkStudentConflict,
  scheduleClass,
  checkInstructorConflict,
  blockInstructorTime,
  listRules,
  createRule,
  getAllStudents,
  createStudent,
  getAllAssessmentRubrics,
  createAssessmentRubric,
  getScoringLevelsByRubric,
  createRubricScoringLevel,
  createRubricScoringLevelsBatch,
  recalculateScores,
  getRubricCriteria,
  addRubricCriterion,
  getRubricScoring,
  addRubricScoring,
  getAllQuizzes,
  createQuiz,
  getQuizQuestions,
  addQuizQuestion,
  getQuestionOptions,
  addQuestionOption,
  reorderQuizQuestions,
  getAllTrainingPrograms,
  createTrainingProgram,
  publishProgram,
  getProgramRequirements,
  addProgramRequirement,
  getProgramCourses,
  addProgramCourse,
  getAllOrganisations,
  createOrganisation,
  getTrainingBranchesByOrganisation,
  createTrainingBranch1,
  removeUserFromBranch,
  assignUserToBranch,
  getAllInstructors,
  createInstructor,
  getInstructorSkills,
  addInstructorSkill,
  getInstructorReviews,
  submitInstructorReview,
  getInstructorMemberships,
  addInstructorMembership,
  getInstructorExperience,
  addInstructorExperience,
  getInstructorEducation,
  addInstructorEducation,
  getInstructorDocuments,
  addInstructorDocument,
  verifyDocument,
  uploadInstructorDocument,
  createLink,
  enrollStudent,
  joinWaitlist,
  getAllCourses,
  createCourse,
  unpublishCourse,
  uploadCourseThumbnail,
  publishCourse,
  uploadCourseIntroVideo,
  uploadCourseBanner,
  archiveCourse,
  getCourseTrainingRequirements,
  addCourseTrainingRequirement,
  listTrainingApplications,
  submitTrainingApplication,
  getTrainingApplication,
  decideOnTrainingApplication,
  getCourseRubrics,
  associateRubric,
  getCourseRequirements,
  addCourseRequirement,
  getCourseLessons,
  addCourseLesson,
  getLessonContent,
  addLessonContent,
  uploadLessonMedia,
  reorderLessonContent,
  getCourseAssessments,
  addCourseAssessment,
  getAllCourseCreators,
  createCourseCreator,
  verifyCourseCreator,
  unverifyCourseCreator,
  getCourseCreatorSkills,
  addCourseCreatorSkill,
  getCourseCreatorMemberships,
  addCourseCreatorMembership,
  getCourseCreatorExperience,
  addCourseCreatorExperience,
  getCourseCreatorEducation,
  addCourseCreatorEducation,
  getCourseCreatorCertifications,
  addCourseCreatorCertification,
  getAllGradingLevels,
  createGradingLevel,
  getAllDifficultyLevels,
  createDifficultyLevel,
  reorderDifficultyLevels,
  getAllContentTypes,
  createContentType,
  getAllCategories,
  createCategory,
  completeCheckout,
  listCatalogItems,
  createCatalogItem,
  backfillCatalogue,
  createCart,
  selectPaymentSession,
  addItem,
  completeCart,
  createClassDefinition,
  getQuizSchedules,
  createQuizSchedule,
  getAssignmentSchedules,
  createAssignmentSchedule,
  getAllCertificates,
  createCertificate,
  uploadCertificatePdf,
  revokeCertificate,
  generateCertificateUrl,
  getCertificateTemplates,
  createCertificateTemplate,
  generateProgramCertificate,
  generateCourseCertificate,
  createBooking,
  requestPayment,
  paymentCallback,
  cancelBooking,
  getAllAssignments,
  createAssignment,
  submitAssignment,
  returnSubmission,
  gradeSubmission,
  assignAdminDomain,
  getAdminUsers,
  createAdminUser,
  moderateOrganisation,
  createOrganisationUser,
  verifyInstructor,
  unverifyInstructor,
  listAll,
  createCurrency,
  makeDefault,
  deactivate,
  activate,
  updateScheduledInstanceStatus,
  reorderScoringLevels,
  markAttendance,
  getCart,
  updateCart,
  deleteQuizSchedule,
  updateQuizSchedule,
  deleteAssignmentSchedule,
  updateAssignmentSchedule,
  getAllUsers,
  search,
  getProfileImage,
  search1,
  getTrainingBranchesByOrganisation1,
  cancelScheduledClass,
  getScheduledInstance,
  getInstructorSchedule,
  getStudentBookings,
  searchStudents,
  validateMatrix,
  getPassingScoringLevels,
  getHighestScoringLevel,
  getRubricMatrix,
  validateMatrix1,
  getMatrixStatistics,
  checkMatrixReadiness,
  getRubricMatrixView,
  searchAssessmentRubrics,
  getRubricsByType,
  getRubricsByStatus,
  getRubricStatistics,
  getCourseCreatorRubricStatistics,
  searchPublicRubrics,
  getPublicRubrics,
  getPopularRubrics,
  getGeneralRubrics,
  getCourseCreatorRubrics,
  getQuizTotalPoints,
  getQuestionDistribution,
  getQuizAttempts,
  searchQuizzes,
  searchQuestions,
  searchAttempts,
  getProgramEnrollments,
  getRequiredCourses,
  getOptionalCourses,
  getProgramCompletionRate,
  getProgramCertificates,
  searchTrainingPrograms,
  searchProgramRequirements,
  getPublishedPrograms,
  getProgramsByInstructor,
  getFreePrograms,
  searchProgramEnrollments,
  searchProgramCourses,
  getProgramsByCategory,
  getActivePrograms,
  getUsersByOrganisation,
  getUsersByOrganisationAndDomain,
  getBranchUsers,
  getBranchUsersByDomain,
  search2,
  getInstructorRatingSummary,
  getInstructorBookings,
  checkAvailability,
  getInstructorCalendar,
  searchSkills,
  searchInstructors,
  searchMemberships,
  searchExperience,
  searchEducation,
  searchDocuments,
  getStudentDashboard,
  getMyStudents,
  cancelEnrollment,
  getEnrollment,
  getStudentSchedule,
  getEnrollmentsForInstance,
  getEnrollmentCount,
  hasCapacityForEnrollment,
  listCurrencies,
  getDefaultCurrency,
  getStatusTransitions,
  checkRubricAssociation,
  getPrimaryRubric,
  getRubricsByContext,
  getCourseEnrollments,
  getCourseCompletionRate,
  removeAllCategoriesFromCourse,
  getCourseCategories,
  searchTrainingApplications,
  searchCourses,
  getPublishedCourses,
  getCourseMedia,
  getCoursesByInstructor,
  getCoursesByCategory,
  getActiveCourses,
  isCourseCreatorVerified,
  getVerifiedCourseCreators,
  getUnverifiedCourseCreators,
  searchCourseCreatorSkills,
  searchCourseCreators,
  searchCourseCreatorMemberships,
  searchCourseCreatorExperience,
  searchCourseCreatorEducation,
  countCourseCreatorsByVerificationStatus,
  searchCourseCreatorCertifications,
  searchContentTypes,
  checkMimeTypeSupport,
  getMediaContentTypes,
  getSubCategories,
  searchCategories,
  getRootCategories,
  getOrder,
  searchCatalogue,
  resolveByCourseOrClass,
  getEnrollmentsForClass,
  getClassDefinitionsForOrganisation,
  getClassDefinitionsForInstructor,
  getClassDefinitionsForCourse,
  getAllActiveClassDefinitions,
  verifyCertificate,
  searchCertificateTemplates,
  getStudentCertificates,
  getDownloadableCertificates,
  searchCertificates,
  getRevokedCertificates,
  getProgramCertificates1,
  getCertificateByNumber,
  getCourseCertificates,
  getBooking,
  getAssignmentSubmissions,
  getHighPerformanceSubmissions,
  getAverageScore,
  getSubmissionAnalytics,
  searchSubmissions,
  searchAssignments,
  getPendingGrading,
  isUserSystemAdmin,
  isUserAdmin,
  getSystemAdminUsers,
  getOrganizationAdminUsers,
  getAdminEligibleUsers,
  isOrganisationVerified,
  getPendingOrganisations,
  isInstructorVerified,
  getOrganisationSupportedDomains,
  getDashboardStatistics,
  getDashboardActivity,
  clearInstructorAvailability,
  revokeLink,
  dissociateRubric,
  dissociateRubricByContext,
  removeCategoryFromCourse,
  removeAdminDomain,
} from '../sdk.gen';
import {
  type UseMutationOptions,
  queryOptions,
  infiniteQueryOptions,
  type InfiniteData,
} from '@tanstack/react-query';
import type {
  DeleteUserData,
  DeleteUserError,
  DeleteUserResponse,
  GetUserByUuidData,
  UpdateUserData,
  UpdateUserError,
  UpdateUserResponse,
  DeleteTrainingBranchData,
  DeleteTrainingBranchError,
  DeleteTrainingBranchResponse,
  GetTrainingBranchByUuidData,
  UpdateTrainingBranchData,
  UpdateTrainingBranchError,
  UpdateTrainingBranchResponse,
  GetRuleData,
  UpdateRuleData,
  UpdateRuleError,
  UpdateRuleResponse,
  DeleteStudentData,
  DeleteStudentError,
  DeleteStudentResponse,
  GetStudentByIdData,
  UpdateStudentData,
  UpdateStudentError,
  UpdateStudentResponse,
  DeleteAssessmentRubricData,
  DeleteAssessmentRubricError,
  GetAssessmentRubricByUuidData,
  UpdateAssessmentRubricData,
  UpdateAssessmentRubricError,
  UpdateAssessmentRubricResponse,
  DeleteScoringLevelData,
  DeleteScoringLevelError,
  DeleteScoringLevelResponse,
  GetScoringLevelData,
  UpdateScoringLevelData,
  UpdateScoringLevelError,
  UpdateScoringLevelResponse,
  UpdateMatrixCellData,
  UpdateMatrixCellError,
  UpdateMatrixCellResponse,
  DeleteRubricCriterionData,
  DeleteRubricCriterionError,
  UpdateRubricCriterionData,
  UpdateRubricCriterionError,
  UpdateRubricCriterionResponse,
  DeleteRubricScoringData,
  DeleteRubricScoringError,
  UpdateRubricScoringData,
  UpdateRubricScoringError,
  UpdateRubricScoringResponse,
  DeleteQuizData,
  DeleteQuizError,
  DeleteQuizResponse,
  GetQuizByUuidData,
  UpdateQuizData,
  UpdateQuizError,
  UpdateQuizResponse,
  DeleteQuizQuestionData,
  DeleteQuizQuestionError,
  UpdateQuizQuestionData,
  UpdateQuizQuestionError,
  UpdateQuizQuestionResponse,
  DeleteQuestionOptionData,
  DeleteQuestionOptionError,
  UpdateQuestionOptionData,
  UpdateQuestionOptionError,
  UpdateQuestionOptionResponse,
  DeleteTrainingProgramData,
  DeleteTrainingProgramError,
  DeleteTrainingProgramResponse,
  GetTrainingProgramByUuidData,
  UpdateTrainingProgramData,
  UpdateTrainingProgramError,
  UpdateTrainingProgramResponse,
  DeleteProgramRequirementData,
  DeleteProgramRequirementError,
  UpdateProgramRequirementData,
  UpdateProgramRequirementError,
  UpdateProgramRequirementResponse,
  RemoveProgramCourseData,
  RemoveProgramCourseError,
  UpdateProgramCourseData,
  UpdateProgramCourseError,
  UpdateProgramCourseResponse,
  DeleteOrganisationData,
  DeleteOrganisationError,
  DeleteOrganisationResponse,
  GetOrganisationByUuidData,
  UpdateOrganisationData,
  UpdateOrganisationError,
  UpdateOrganisationResponse,
  DeleteTrainingBranch1Data,
  DeleteTrainingBranch1Error,
  DeleteTrainingBranch1Response,
  GetTrainingBranchByUuid1Data,
  UpdateTrainingBranch1Data,
  UpdateTrainingBranch1Error,
  UpdateTrainingBranch1Response,
  DeleteInstructorData,
  DeleteInstructorError,
  DeleteInstructorResponse,
  GetInstructorByUuidData,
  UpdateInstructorData,
  UpdateInstructorError,
  UpdateInstructorResponse,
  DeleteInstructorSkillData,
  DeleteInstructorSkillError,
  UpdateInstructorSkillData,
  UpdateInstructorSkillError,
  UpdateInstructorSkillResponse,
  DeleteInstructorMembershipData,
  DeleteInstructorMembershipError,
  UpdateInstructorMembershipData,
  UpdateInstructorMembershipError,
  UpdateInstructorMembershipResponse,
  DeleteInstructorExperienceData,
  DeleteInstructorExperienceError,
  UpdateInstructorExperienceData,
  UpdateInstructorExperienceError,
  UpdateInstructorExperienceResponse,
  DeleteInstructorEducationData,
  DeleteInstructorEducationError,
  UpdateInstructorEducationData,
  UpdateInstructorEducationError,
  UpdateInstructorEducationResponse,
  DeleteInstructorDocumentData,
  DeleteInstructorDocumentError,
  UpdateInstructorDocumentData,
  UpdateInstructorDocumentError,
  UpdateInstructorDocumentResponse,
  DeleteCourseData,
  DeleteCourseError,
  DeleteCourseResponse,
  GetCourseByUuidData,
  UpdateCourseData,
  UpdateCourseError,
  UpdateCourseResponse,
  DeleteCourseTrainingRequirementData,
  DeleteCourseTrainingRequirementError,
  UpdateCourseTrainingRequirementData,
  UpdateCourseTrainingRequirementError,
  UpdateCourseTrainingRequirementResponse,
  SetPrimaryRubricData,
  SetPrimaryRubricError,
  SetPrimaryRubricResponse,
  UpdateAssociationData,
  UpdateAssociationError,
  UpdateAssociationResponse,
  DeleteCourseRequirementData,
  DeleteCourseRequirementError,
  UpdateCourseRequirementData,
  UpdateCourseRequirementError,
  UpdateCourseRequirementResponse,
  DeleteCourseLessonData,
  DeleteCourseLessonError,
  GetCourseLessonData,
  UpdateCourseLessonData,
  UpdateCourseLessonError,
  UpdateCourseLessonResponse,
  DeleteLessonContentData,
  DeleteLessonContentError,
  UpdateLessonContentData,
  UpdateLessonContentError,
  UpdateLessonContentResponse,
  DeleteCourseAssessmentData,
  DeleteCourseAssessmentError,
  UpdateCourseAssessmentData,
  UpdateCourseAssessmentError,
  UpdateCourseAssessmentResponse,
  DeleteCourseCreatorData,
  DeleteCourseCreatorError,
  DeleteCourseCreatorResponse,
  GetCourseCreatorByUuidData,
  UpdateCourseCreatorData,
  UpdateCourseCreatorError,
  UpdateCourseCreatorResponse,
  DeleteCourseCreatorSkillData,
  DeleteCourseCreatorSkillError,
  UpdateCourseCreatorSkillData,
  UpdateCourseCreatorSkillError,
  UpdateCourseCreatorSkillResponse,
  DeleteCourseCreatorMembershipData,
  DeleteCourseCreatorMembershipError,
  UpdateCourseCreatorMembershipData,
  UpdateCourseCreatorMembershipError,
  UpdateCourseCreatorMembershipResponse,
  DeleteCourseCreatorExperienceData,
  DeleteCourseCreatorExperienceError,
  UpdateCourseCreatorExperienceData,
  UpdateCourseCreatorExperienceError,
  UpdateCourseCreatorExperienceResponse,
  DeleteCourseCreatorEducationData,
  DeleteCourseCreatorEducationError,
  UpdateCourseCreatorEducationData,
  UpdateCourseCreatorEducationError,
  UpdateCourseCreatorEducationResponse,
  DeleteCourseCreatorCertificationData,
  DeleteCourseCreatorCertificationError,
  UpdateCourseCreatorCertificationData,
  UpdateCourseCreatorCertificationError,
  UpdateCourseCreatorCertificationResponse,
  DeleteGradingLevelData,
  DeleteGradingLevelError,
  UpdateGradingLevelData,
  UpdateGradingLevelError,
  UpdateGradingLevelResponse,
  DeleteDifficultyLevelData,
  DeleteDifficultyLevelError,
  DeleteDifficultyLevelResponse,
  UpdateDifficultyLevelData,
  UpdateDifficultyLevelError,
  UpdateDifficultyLevelResponse,
  DeleteContentTypeData,
  DeleteContentTypeError,
  DeleteContentTypeResponse,
  UpdateContentTypeData,
  UpdateContentTypeError,
  UpdateContentTypeResponse,
  DeleteCategoryData,
  DeleteCategoryError,
  DeleteCategoryResponse,
  GetCategoryByUuidData,
  UpdateCategoryData,
  UpdateCategoryError,
  UpdateCategoryResponse,
  UpdateCatalogItemData,
  UpdateCatalogItemError,
  UpdateCatalogItemResponse,
  DeactivateClassDefinitionData,
  DeactivateClassDefinitionError,
  DeactivateClassDefinitionResponse,
  GetClassDefinitionData,
  UpdateClassDefinitionData,
  UpdateClassDefinitionError,
  UpdateClassDefinitionResponse,
  GetLessonPlanData,
  SaveLessonPlanData,
  SaveLessonPlanError,
  SaveLessonPlanResponse,
  DeleteCertificateData,
  DeleteCertificateError,
  DeleteCertificateResponse,
  GetCertificateByUuidData,
  UpdateCertificateData,
  UpdateCertificateError,
  UpdateCertificateResponse,
  DeleteCertificateTemplateData,
  DeleteCertificateTemplateError,
  UpdateCertificateTemplateData,
  UpdateCertificateTemplateError,
  UpdateCertificateTemplateResponse,
  DeleteAssignmentData,
  DeleteAssignmentError,
  DeleteAssignmentResponse,
  GetAssignmentByUuidData,
  UpdateAssignmentData,
  UpdateAssignmentError,
  UpdateAssignmentResponse,
  UpdateCurrencyData,
  UpdateCurrencyError,
  UpdateCurrencyResponse,
  UploadProfileImageData,
  UploadProfileImageError,
  UploadProfileImageResponse,
  GetAllTrainingBranchesData,
  GetAllTrainingBranchesError,
  GetAllTrainingBranchesResponse,
  CreateTrainingBranchData,
  CreateTrainingBranchError,
  CreateTrainingBranchResponse,
  CheckStudentConflictData,
  CheckStudentConflictError,
  CheckStudentConflictResponse,
  ScheduleClassData,
  ScheduleClassError,
  ScheduleClassResponse,
  CheckInstructorConflictData,
  CheckInstructorConflictError,
  CheckInstructorConflictResponse,
  BlockInstructorTimeData,
  BlockInstructorTimeError,
  BlockInstructorTimeResponse,
  ListRulesData,
  ListRulesError,
  ListRulesResponse,
  CreateRuleData,
  CreateRuleError,
  CreateRuleResponse,
  GetAllStudentsData,
  GetAllStudentsError,
  GetAllStudentsResponse,
  CreateStudentData,
  CreateStudentError,
  CreateStudentResponse,
  GetAllAssessmentRubricsData,
  GetAllAssessmentRubricsError,
  GetAllAssessmentRubricsResponse,
  CreateAssessmentRubricData,
  CreateAssessmentRubricError,
  CreateAssessmentRubricResponse,
  GetScoringLevelsByRubricData,
  GetScoringLevelsByRubricError,
  GetScoringLevelsByRubricResponse,
  CreateRubricScoringLevelData,
  CreateRubricScoringLevelError,
  CreateRubricScoringLevelResponse,
  CreateRubricScoringLevelsBatchData,
  CreateRubricScoringLevelsBatchError,
  CreateRubricScoringLevelsBatchResponse,
  RecalculateScoresData,
  RecalculateScoresError,
  RecalculateScoresResponse,
  GetRubricCriteriaData,
  GetRubricCriteriaError,
  GetRubricCriteriaResponse,
  AddRubricCriterionData,
  AddRubricCriterionError,
  AddRubricCriterionResponse,
  GetRubricScoringData,
  GetRubricScoringError,
  GetRubricScoringResponse,
  AddRubricScoringData,
  AddRubricScoringError,
  AddRubricScoringResponse,
  GetAllQuizzesData,
  GetAllQuizzesError,
  GetAllQuizzesResponse,
  CreateQuizData,
  CreateQuizError,
  CreateQuizResponse,
  GetQuizQuestionsData,
  AddQuizQuestionData,
  AddQuizQuestionError,
  AddQuizQuestionResponse,
  GetQuestionOptionsData,
  GetQuestionOptionsError,
  GetQuestionOptionsResponse,
  AddQuestionOptionData,
  AddQuestionOptionError,
  AddQuestionOptionResponse,
  ReorderQuizQuestionsData,
  ReorderQuizQuestionsError,
  ReorderQuizQuestionsResponse,
  GetAllTrainingProgramsData,
  GetAllTrainingProgramsError,
  GetAllTrainingProgramsResponse,
  CreateTrainingProgramData,
  CreateTrainingProgramError,
  CreateTrainingProgramResponse,
  PublishProgramData,
  PublishProgramError,
  PublishProgramResponse,
  GetProgramRequirementsData,
  GetProgramRequirementsError,
  GetProgramRequirementsResponse,
  AddProgramRequirementData,
  AddProgramRequirementError,
  AddProgramRequirementResponse,
  GetProgramCoursesData,
  AddProgramCourseData,
  AddProgramCourseError,
  AddProgramCourseResponse,
  GetAllOrganisationsData,
  GetAllOrganisationsError,
  GetAllOrganisationsResponse,
  CreateOrganisationData,
  CreateOrganisationError,
  CreateOrganisationResponse,
  GetTrainingBranchesByOrganisationData,
  GetTrainingBranchesByOrganisationError,
  GetTrainingBranchesByOrganisationResponse,
  CreateTrainingBranch1Data,
  CreateTrainingBranch1Error,
  CreateTrainingBranch1Response,
  RemoveUserFromBranchData,
  RemoveUserFromBranchError,
  RemoveUserFromBranchResponse,
  AssignUserToBranchData,
  AssignUserToBranchError,
  AssignUserToBranchResponse,
  GetAllInstructorsData,
  GetAllInstructorsError,
  GetAllInstructorsResponse,
  CreateInstructorData,
  CreateInstructorError,
  CreateInstructorResponse,
  GetInstructorSkillsData,
  GetInstructorSkillsError,
  GetInstructorSkillsResponse,
  AddInstructorSkillData,
  AddInstructorSkillError,
  AddInstructorSkillResponse,
  GetInstructorReviewsData,
  SubmitInstructorReviewData,
  SubmitInstructorReviewError,
  SubmitInstructorReviewResponse,
  GetInstructorMembershipsData,
  GetInstructorMembershipsError,
  GetInstructorMembershipsResponse,
  AddInstructorMembershipData,
  AddInstructorMembershipError,
  AddInstructorMembershipResponse,
  GetInstructorExperienceData,
  GetInstructorExperienceError,
  GetInstructorExperienceResponse,
  AddInstructorExperienceData,
  AddInstructorExperienceError,
  AddInstructorExperienceResponse,
  GetInstructorEducationData,
  AddInstructorEducationData,
  AddInstructorEducationError,
  AddInstructorEducationResponse,
  GetInstructorDocumentsData,
  AddInstructorDocumentData,
  AddInstructorDocumentError,
  AddInstructorDocumentResponse,
  VerifyDocumentData,
  VerifyDocumentError,
  VerifyDocumentResponse,
  UploadInstructorDocumentData,
  UploadInstructorDocumentError,
  UploadInstructorDocumentResponse,
  CreateLinkData,
  CreateLinkError,
  CreateLinkResponse,
  EnrollStudentData,
  EnrollStudentError,
  EnrollStudentResponse,
  JoinWaitlistData,
  JoinWaitlistError,
  JoinWaitlistResponse,
  GetAllCoursesData,
  GetAllCoursesError,
  GetAllCoursesResponse,
  CreateCourseData,
  CreateCourseError,
  CreateCourseResponse,
  UnpublishCourseData,
  UnpublishCourseError,
  UnpublishCourseResponse,
  UploadCourseThumbnailData,
  UploadCourseThumbnailError,
  UploadCourseThumbnailResponse,
  PublishCourseData,
  PublishCourseError,
  PublishCourseResponse,
  UploadCourseIntroVideoData,
  UploadCourseIntroVideoError,
  UploadCourseIntroVideoResponse,
  UploadCourseBannerData,
  UploadCourseBannerError,
  UploadCourseBannerResponse,
  ArchiveCourseData,
  ArchiveCourseError,
  ArchiveCourseResponse,
  GetCourseTrainingRequirementsData,
  GetCourseTrainingRequirementsError,
  GetCourseTrainingRequirementsResponse,
  AddCourseTrainingRequirementData,
  AddCourseTrainingRequirementError,
  AddCourseTrainingRequirementResponse,
  ListTrainingApplicationsData,
  ListTrainingApplicationsError,
  ListTrainingApplicationsResponse,
  SubmitTrainingApplicationData,
  SubmitTrainingApplicationError,
  SubmitTrainingApplicationResponse,
  GetTrainingApplicationData,
  DecideOnTrainingApplicationData,
  DecideOnTrainingApplicationError,
  DecideOnTrainingApplicationResponse,
  GetCourseRubricsData,
  GetCourseRubricsError,
  GetCourseRubricsResponse,
  AssociateRubricData,
  AssociateRubricError,
  AssociateRubricResponse,
  GetCourseRequirementsData,
  GetCourseRequirementsError,
  GetCourseRequirementsResponse,
  AddCourseRequirementData,
  AddCourseRequirementError,
  AddCourseRequirementResponse,
  GetCourseLessonsData,
  GetCourseLessonsError,
  GetCourseLessonsResponse,
  AddCourseLessonData,
  AddCourseLessonError,
  AddCourseLessonResponse,
  GetLessonContentData,
  AddLessonContentData,
  AddLessonContentError,
  AddLessonContentResponse,
  UploadLessonMediaData,
  UploadLessonMediaError,
  UploadLessonMediaResponse,
  ReorderLessonContentData,
  ReorderLessonContentError,
  ReorderLessonContentResponse,
  GetCourseAssessmentsData,
  GetCourseAssessmentsError,
  GetCourseAssessmentsResponse,
  AddCourseAssessmentData,
  AddCourseAssessmentError,
  AddCourseAssessmentResponse,
  GetAllCourseCreatorsData,
  GetAllCourseCreatorsError,
  GetAllCourseCreatorsResponse,
  CreateCourseCreatorData,
  CreateCourseCreatorError,
  CreateCourseCreatorResponse,
  VerifyCourseCreatorData,
  VerifyCourseCreatorError,
  VerifyCourseCreatorResponse,
  UnverifyCourseCreatorData,
  UnverifyCourseCreatorError,
  UnverifyCourseCreatorResponse,
  GetCourseCreatorSkillsData,
  GetCourseCreatorSkillsError,
  GetCourseCreatorSkillsResponse,
  AddCourseCreatorSkillData,
  AddCourseCreatorSkillError,
  AddCourseCreatorSkillResponse,
  GetCourseCreatorMembershipsData,
  GetCourseCreatorMembershipsError,
  GetCourseCreatorMembershipsResponse,
  AddCourseCreatorMembershipData,
  AddCourseCreatorMembershipError,
  AddCourseCreatorMembershipResponse,
  GetCourseCreatorExperienceData,
  GetCourseCreatorExperienceError,
  GetCourseCreatorExperienceResponse,
  AddCourseCreatorExperienceData,
  AddCourseCreatorExperienceError,
  AddCourseCreatorExperienceResponse,
  GetCourseCreatorEducationData,
  GetCourseCreatorEducationError,
  GetCourseCreatorEducationResponse,
  AddCourseCreatorEducationData,
  AddCourseCreatorEducationError,
  AddCourseCreatorEducationResponse,
  GetCourseCreatorCertificationsData,
  GetCourseCreatorCertificationsError,
  GetCourseCreatorCertificationsResponse,
  AddCourseCreatorCertificationData,
  AddCourseCreatorCertificationError,
  AddCourseCreatorCertificationResponse,
  GetAllGradingLevelsData,
  GetAllGradingLevelsError,
  GetAllGradingLevelsResponse,
  CreateGradingLevelData,
  CreateGradingLevelError,
  CreateGradingLevelResponse,
  GetAllDifficultyLevelsData,
  CreateDifficultyLevelData,
  CreateDifficultyLevelError,
  CreateDifficultyLevelResponse,
  ReorderDifficultyLevelsData,
  ReorderDifficultyLevelsError,
  ReorderDifficultyLevelsResponse,
  GetAllContentTypesData,
  GetAllContentTypesError,
  GetAllContentTypesResponse,
  CreateContentTypeData,
  CreateContentTypeError,
  CreateContentTypeResponse,
  GetAllCategoriesData,
  GetAllCategoriesError,
  GetAllCategoriesResponse,
  CreateCategoryData,
  CreateCategoryError,
  CreateCategoryResponse,
  CompleteCheckoutData,
  CompleteCheckoutError,
  CompleteCheckoutResponse,
  ListCatalogItemsData,
  CreateCatalogItemData,
  CreateCatalogItemError,
  CreateCatalogItemResponse,
  BackfillCatalogueData,
  BackfillCatalogueError,
  BackfillCatalogueResponse,
  CreateCartData,
  CreateCartError,
  CreateCartResponse,
  SelectPaymentSessionData,
  SelectPaymentSessionError,
  SelectPaymentSessionResponse,
  AddItemData,
  AddItemError,
  AddItemResponse,
  CompleteCartData,
  CompleteCartError,
  CompleteCartResponse,
  CreateClassDefinitionData,
  CreateClassDefinitionError,
  CreateClassDefinitionResponse,
  GetQuizSchedulesData,
  CreateQuizScheduleData,
  CreateQuizScheduleError,
  CreateQuizScheduleResponse,
  GetAssignmentSchedulesData,
  CreateAssignmentScheduleData,
  CreateAssignmentScheduleError,
  CreateAssignmentScheduleResponse,
  GetAllCertificatesData,
  GetAllCertificatesError,
  GetAllCertificatesResponse,
  CreateCertificateData,
  CreateCertificateError,
  CreateCertificateResponse,
  UploadCertificatePdfData,
  UploadCertificatePdfError,
  UploadCertificatePdfResponse,
  RevokeCertificateData,
  RevokeCertificateError,
  RevokeCertificateResponse,
  GenerateCertificateUrlData,
  GenerateCertificateUrlError,
  GenerateCertificateUrlResponse,
  GetCertificateTemplatesData,
  GetCertificateTemplatesError,
  GetCertificateTemplatesResponse,
  CreateCertificateTemplateData,
  CreateCertificateTemplateError,
  CreateCertificateTemplateResponse,
  GenerateProgramCertificateData,
  GenerateProgramCertificateError,
  GenerateProgramCertificateResponse,
  GenerateCourseCertificateData,
  GenerateCourseCertificateError,
  GenerateCourseCertificateResponse,
  CreateBookingData,
  CreateBookingError,
  CreateBookingResponse,
  RequestPaymentData,
  RequestPaymentError,
  RequestPaymentResponse,
  PaymentCallbackData,
  PaymentCallbackError,
  PaymentCallbackResponse,
  CancelBookingData,
  CancelBookingError,
  CancelBookingResponse,
  GetAllAssignmentsData,
  GetAllAssignmentsError,
  GetAllAssignmentsResponse,
  CreateAssignmentData,
  CreateAssignmentError,
  CreateAssignmentResponse,
  SubmitAssignmentData,
  SubmitAssignmentError,
  SubmitAssignmentResponse,
  ReturnSubmissionData,
  ReturnSubmissionError,
  ReturnSubmissionResponse,
  GradeSubmissionData,
  GradeSubmissionError,
  GradeSubmissionResponse,
  AssignAdminDomainData,
  AssignAdminDomainError,
  AssignAdminDomainResponse,
  GetAdminUsersData,
  GetAdminUsersError,
  GetAdminUsersResponse,
  CreateAdminUserData,
  CreateAdminUserError,
  CreateAdminUserResponse,
  ModerateOrganisationData,
  ModerateOrganisationError,
  ModerateOrganisationResponse,
  CreateOrganisationUserData,
  CreateOrganisationUserError,
  CreateOrganisationUserResponse,
  VerifyInstructorData,
  VerifyInstructorError,
  VerifyInstructorResponse,
  UnverifyInstructorData,
  UnverifyInstructorError,
  UnverifyInstructorResponse,
  ListAllData,
  CreateCurrencyData,
  CreateCurrencyError,
  CreateCurrencyResponse,
  MakeDefaultData,
  MakeDefaultError,
  MakeDefaultResponse,
  DeactivateData,
  DeactivateError,
  DeactivateResponse,
  ActivateData,
  ActivateError,
  ActivateResponse,
  UpdateScheduledInstanceStatusData,
  UpdateScheduledInstanceStatusError,
  UpdateScheduledInstanceStatusResponse,
  ReorderScoringLevelsData,
  ReorderScoringLevelsError,
  ReorderScoringLevelsResponse,
  MarkAttendanceData,
  MarkAttendanceError,
  MarkAttendanceResponse,
  GetCartData,
  UpdateCartData,
  UpdateCartError,
  UpdateCartResponse,
  DeleteQuizScheduleData,
  DeleteQuizScheduleError,
  UpdateQuizScheduleData,
  UpdateQuizScheduleError,
  UpdateQuizScheduleResponse,
  DeleteAssignmentScheduleData,
  DeleteAssignmentScheduleError,
  UpdateAssignmentScheduleData,
  UpdateAssignmentScheduleError,
  UpdateAssignmentScheduleResponse,
  GetAllUsersData,
  GetAllUsersError,
  GetAllUsersResponse,
  SearchData,
  SearchError,
  SearchResponse,
  GetProfileImageData,
  Search1Data,
  Search1Error,
  Search1Response,
  GetTrainingBranchesByOrganisation1Data,
  GetTrainingBranchesByOrganisation1Error,
  GetTrainingBranchesByOrganisation1Response,
  CancelScheduledClassData,
  CancelScheduledClassError,
  CancelScheduledClassResponse,
  GetScheduledInstanceData,
  GetInstructorScheduleData,
  GetInstructorScheduleError,
  GetInstructorScheduleResponse,
  GetStudentBookingsData,
  GetStudentBookingsError,
  GetStudentBookingsResponse,
  SearchStudentsData,
  SearchStudentsError,
  SearchStudentsResponse,
  ValidateMatrixData,
  GetPassingScoringLevelsData,
  GetPassingScoringLevelsError,
  GetPassingScoringLevelsResponse,
  GetHighestScoringLevelData,
  GetRubricMatrixData,
  ValidateMatrix1Data,
  GetMatrixStatisticsData,
  CheckMatrixReadinessData,
  GetRubricMatrixViewData,
  SearchAssessmentRubricsData,
  SearchAssessmentRubricsError,
  SearchAssessmentRubricsResponse,
  GetRubricsByTypeData,
  GetRubricsByTypeError,
  GetRubricsByTypeResponse,
  GetRubricsByStatusData,
  GetRubricsByStatusError,
  GetRubricsByStatusResponse,
  GetRubricStatisticsData,
  GetCourseCreatorRubricStatisticsData,
  SearchPublicRubricsData,
  SearchPublicRubricsError,
  SearchPublicRubricsResponse,
  GetPublicRubricsData,
  GetPublicRubricsError,
  GetPublicRubricsResponse,
  GetPopularRubricsData,
  GetPopularRubricsError,
  GetPopularRubricsResponse,
  GetGeneralRubricsData,
  GetGeneralRubricsError,
  GetGeneralRubricsResponse,
  GetCourseCreatorRubricsData,
  GetCourseCreatorRubricsError,
  GetCourseCreatorRubricsResponse,
  GetQuizTotalPointsData,
  GetQuestionDistributionData,
  GetQuizAttemptsData,
  GetQuizAttemptsError,
  GetQuizAttemptsResponse,
  SearchQuizzesData,
  SearchQuizzesError,
  SearchQuizzesResponse,
  SearchQuestionsData,
  SearchQuestionsError,
  SearchQuestionsResponse,
  SearchAttemptsData,
  SearchAttemptsError,
  SearchAttemptsResponse,
  GetProgramEnrollmentsData,
  GetProgramEnrollmentsError,
  GetProgramEnrollmentsResponse,
  GetRequiredCoursesData,
  GetOptionalCoursesData,
  GetProgramCompletionRateData,
  GetProgramCertificatesData,
  GetProgramCertificatesError,
  GetProgramCertificatesResponse,
  SearchTrainingProgramsData,
  SearchTrainingProgramsError,
  SearchTrainingProgramsResponse,
  SearchProgramRequirementsData,
  SearchProgramRequirementsError,
  SearchProgramRequirementsResponse,
  GetPublishedProgramsData,
  GetPublishedProgramsError,
  GetPublishedProgramsResponse,
  GetProgramsByInstructorData,
  GetProgramsByInstructorError,
  GetProgramsByInstructorResponse,
  GetFreeProgramsData,
  GetFreeProgramsError,
  GetFreeProgramsResponse,
  SearchProgramEnrollmentsData,
  SearchProgramEnrollmentsError,
  SearchProgramEnrollmentsResponse,
  SearchProgramCoursesData,
  SearchProgramCoursesError,
  SearchProgramCoursesResponse,
  GetProgramsByCategoryData,
  GetProgramsByCategoryError,
  GetProgramsByCategoryResponse,
  GetActiveProgramsData,
  GetActiveProgramsError,
  GetActiveProgramsResponse,
  GetUsersByOrganisationData,
  GetUsersByOrganisationError,
  GetUsersByOrganisationResponse,
  GetUsersByOrganisationAndDomainData,
  GetBranchUsersData,
  GetBranchUsersByDomainData,
  Search2Data,
  Search2Error,
  Search2Response,
  GetInstructorRatingSummaryData,
  GetInstructorBookingsData,
  GetInstructorBookingsError,
  GetInstructorBookingsResponse,
  CheckAvailabilityData,
  CheckAvailabilityError,
  CheckAvailabilityResponse,
  GetInstructorCalendarData,
  SearchSkillsData,
  SearchSkillsError,
  SearchSkillsResponse,
  SearchInstructorsData,
  SearchInstructorsError,
  SearchInstructorsResponse,
  SearchMembershipsData,
  SearchMembershipsError,
  SearchMembershipsResponse,
  SearchExperienceData,
  SearchExperienceError,
  SearchExperienceResponse,
  SearchEducationData,
  SearchEducationError,
  SearchEducationResponse,
  SearchDocumentsData,
  SearchDocumentsError,
  SearchDocumentsResponse,
  GetStudentDashboardData,
  GetMyStudentsData,
  CancelEnrollmentData,
  CancelEnrollmentError,
  CancelEnrollmentResponse,
  GetEnrollmentData,
  GetStudentScheduleData,
  GetStudentScheduleError,
  GetStudentScheduleResponse,
  GetEnrollmentsForInstanceData,
  GetEnrollmentCountData,
  HasCapacityForEnrollmentData,
  ListCurrenciesData,
  ListCurrenciesError,
  ListCurrenciesResponse,
  GetDefaultCurrencyData,
  GetStatusTransitionsData,
  CheckRubricAssociationData,
  GetPrimaryRubricData,
  GetRubricsByContextData,
  GetRubricsByContextError,
  GetRubricsByContextResponse,
  GetCourseEnrollmentsData,
  GetCourseEnrollmentsError,
  GetCourseEnrollmentsResponse,
  GetCourseCompletionRateData,
  RemoveAllCategoriesFromCourseData,
  RemoveAllCategoriesFromCourseError,
  RemoveAllCategoriesFromCourseResponse,
  GetCourseCategoriesData,
  SearchTrainingApplicationsData,
  SearchTrainingApplicationsError,
  SearchTrainingApplicationsResponse,
  SearchCoursesData,
  SearchCoursesError,
  SearchCoursesResponse,
  GetPublishedCoursesData,
  GetPublishedCoursesError,
  GetPublishedCoursesResponse,
  GetCourseMediaData,
  GetCoursesByInstructorData,
  GetCoursesByInstructorError,
  GetCoursesByInstructorResponse,
  GetCoursesByCategoryData,
  GetCoursesByCategoryError,
  GetCoursesByCategoryResponse,
  GetActiveCoursesData,
  GetActiveCoursesError,
  GetActiveCoursesResponse,
  IsCourseCreatorVerifiedData,
  GetVerifiedCourseCreatorsData,
  GetVerifiedCourseCreatorsError,
  GetVerifiedCourseCreatorsResponse,
  GetUnverifiedCourseCreatorsData,
  GetUnverifiedCourseCreatorsError,
  GetUnverifiedCourseCreatorsResponse,
  SearchCourseCreatorSkillsData,
  SearchCourseCreatorSkillsError,
  SearchCourseCreatorSkillsResponse,
  SearchCourseCreatorsData,
  SearchCourseCreatorsError,
  SearchCourseCreatorsResponse,
  SearchCourseCreatorMembershipsData,
  SearchCourseCreatorMembershipsError,
  SearchCourseCreatorMembershipsResponse,
  SearchCourseCreatorExperienceData,
  SearchCourseCreatorExperienceError,
  SearchCourseCreatorExperienceResponse,
  SearchCourseCreatorEducationData,
  SearchCourseCreatorEducationError,
  SearchCourseCreatorEducationResponse,
  CountCourseCreatorsByVerificationStatusData,
  SearchCourseCreatorCertificationsData,
  SearchCourseCreatorCertificationsError,
  SearchCourseCreatorCertificationsResponse,
  SearchContentTypesData,
  SearchContentTypesError,
  SearchContentTypesResponse,
  CheckMimeTypeSupportData,
  GetMediaContentTypesData,
  GetSubCategoriesData,
  SearchCategoriesData,
  SearchCategoriesError,
  SearchCategoriesResponse,
  GetRootCategoriesData,
  GetOrderData,
  SearchCatalogueData,
  SearchCatalogueError,
  SearchCatalogueResponse,
  ResolveByCourseOrClassData,
  GetEnrollmentsForClassData,
  GetClassDefinitionsForOrganisationData,
  GetClassDefinitionsForInstructorData,
  GetClassDefinitionsForCourseData,
  GetAllActiveClassDefinitionsData,
  VerifyCertificateData,
  SearchCertificateTemplatesData,
  SearchCertificateTemplatesError,
  SearchCertificateTemplatesResponse,
  GetStudentCertificatesData,
  GetDownloadableCertificatesData,
  SearchCertificatesData,
  SearchCertificatesError,
  SearchCertificatesResponse,
  GetRevokedCertificatesData,
  GetProgramCertificates1Data,
  GetCertificateByNumberData,
  GetCourseCertificatesData,
  GetBookingData,
  GetAssignmentSubmissionsData,
  GetHighPerformanceSubmissionsData,
  GetAverageScoreData,
  GetSubmissionAnalyticsData,
  SearchSubmissionsData,
  SearchSubmissionsError,
  SearchSubmissionsResponse,
  SearchAssignmentsData,
  SearchAssignmentsError,
  SearchAssignmentsResponse,
  GetPendingGradingData,
  IsUserSystemAdminData,
  IsUserAdminData,
  GetSystemAdminUsersData,
  GetSystemAdminUsersError,
  GetSystemAdminUsersResponse,
  GetOrganizationAdminUsersData,
  GetOrganizationAdminUsersError,
  GetOrganizationAdminUsersResponse,
  GetAdminEligibleUsersData,
  GetAdminEligibleUsersError,
  GetAdminEligibleUsersResponse,
  IsOrganisationVerifiedData,
  GetPendingOrganisationsData,
  GetPendingOrganisationsError,
  GetPendingOrganisationsResponse,
  IsInstructorVerifiedData,
  GetOrganisationSupportedDomainsData,
  GetDashboardStatisticsData,
  GetDashboardActivityData,
  GetDashboardActivityError,
  GetDashboardActivityResponse,
  ClearInstructorAvailabilityData,
  ClearInstructorAvailabilityError,
  ClearInstructorAvailabilityResponse,
  RevokeLinkData,
  RevokeLinkError,
  RevokeLinkResponse,
  DissociateRubricData,
  DissociateRubricError,
  DissociateRubricResponse,
  DissociateRubricByContextData,
  DissociateRubricByContextError,
  DissociateRubricByContextResponse,
  RemoveCategoryFromCourseData,
  RemoveCategoryFromCourseError,
  RemoveCategoryFromCourseResponse,
  RemoveAdminDomainData,
  RemoveAdminDomainError,
  RemoveAdminDomainResponse,
} from '../types.gen';
import { client as _heyApiClient } from '../client.gen';

/**
 * Delete a user by UUID
 */
export const deleteUserMutation = (
  options?: Partial<Options<DeleteUserData>>
): UseMutationOptions<DeleteUserResponse, DeleteUserError, Options<DeleteUserData>> => {
  const mutationOptions: UseMutationOptions<
    DeleteUserResponse,
    DeleteUserError,
    Options<DeleteUserData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await deleteUser({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export type QueryKey<TOptions extends Options> = [
  Pick<TOptions, 'baseUrl' | 'body' | 'headers' | 'path' | 'query'> & {
    _id: string;
    _infinite?: boolean;
    tags?: ReadonlyArray<string>;
  },
];

const createQueryKey = <TOptions extends Options>(
  id: string,
  options?: TOptions,
  infinite?: boolean,
  tags?: ReadonlyArray<string>
): [QueryKey<TOptions>[0]] => {
  const params: QueryKey<TOptions>[0] = {
    _id: id,
    baseUrl: options?.baseUrl || (options?.client ?? _heyApiClient).getConfig().baseUrl,
  } as QueryKey<TOptions>[0];
  if (infinite) {
    params._infinite = infinite;
  }
  if (tags) {
    params.tags = tags;
  }
  if (options?.body) {
    params.body = options.body;
  }
  if (options?.headers) {
    params.headers = options.headers;
  }
  if (options?.path) {
    params.path = options.path;
  }
  if (options?.query) {
    params.query = options.query;
  }
  return [params];
};

export const getUserByUuidQueryKey = (options: Options<GetUserByUuidData>) =>
  createQueryKey('getUserByUuid', options);

/**
 * Get a user by UUID
 */
export const getUserByUuidOptions = (options: Options<GetUserByUuidData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getUserByUuid({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getUserByUuidQueryKey(options),
  });
};

/**
 * Update a user by UUID
 */
export const updateUserMutation = (
  options?: Partial<Options<UpdateUserData>>
): UseMutationOptions<UpdateUserResponse, UpdateUserError, Options<UpdateUserData>> => {
  const mutationOptions: UseMutationOptions<
    UpdateUserResponse,
    UpdateUserError,
    Options<UpdateUserData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await updateUser({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Delete a training branch by UUID
 */
export const deleteTrainingBranchMutation = (
  options?: Partial<Options<DeleteTrainingBranchData>>
): UseMutationOptions<
  DeleteTrainingBranchResponse,
  DeleteTrainingBranchError,
  Options<DeleteTrainingBranchData>
> => {
  const mutationOptions: UseMutationOptions<
    DeleteTrainingBranchResponse,
    DeleteTrainingBranchError,
    Options<DeleteTrainingBranchData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await deleteTrainingBranch({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getTrainingBranchByUuidQueryKey = (options: Options<GetTrainingBranchByUuidData>) =>
  createQueryKey('getTrainingBranchByUuid', options);

/**
 * Get a training branch by UUID
 */
export const getTrainingBranchByUuidOptions = (options: Options<GetTrainingBranchByUuidData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getTrainingBranchByUuid({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getTrainingBranchByUuidQueryKey(options),
  });
};

/**
 * Update a training branch by UUID
 */
export const updateTrainingBranchMutation = (
  options?: Partial<Options<UpdateTrainingBranchData>>
): UseMutationOptions<
  UpdateTrainingBranchResponse,
  UpdateTrainingBranchError,
  Options<UpdateTrainingBranchData>
> => {
  const mutationOptions: UseMutationOptions<
    UpdateTrainingBranchResponse,
    UpdateTrainingBranchError,
    Options<UpdateTrainingBranchData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await updateTrainingBranch({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getRuleQueryKey = (options: Options<GetRuleData>) =>
  createQueryKey('getRule', options);

/**
 * Fetch rule
 * Fetches a single rule by its UUID
 */
export const getRuleOptions = (options: Options<GetRuleData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getRule({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getRuleQueryKey(options),
  });
};

/**
 * Update rule
 */
export const updateRuleMutation = (
  options?: Partial<Options<UpdateRuleData>>
): UseMutationOptions<UpdateRuleResponse, UpdateRuleError, Options<UpdateRuleData>> => {
  const mutationOptions: UseMutationOptions<
    UpdateRuleResponse,
    UpdateRuleError,
    Options<UpdateRuleData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await updateRule({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Delete a student
 * Removes a student record from the system.
 */
export const deleteStudentMutation = (
  options?: Partial<Options<DeleteStudentData>>
): UseMutationOptions<DeleteStudentResponse, DeleteStudentError, Options<DeleteStudentData>> => {
  const mutationOptions: UseMutationOptions<
    DeleteStudentResponse,
    DeleteStudentError,
    Options<DeleteStudentData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await deleteStudent({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getStudentByIdQueryKey = (options: Options<GetStudentByIdData>) =>
  createQueryKey('getStudentById', options);

/**
 * Get student by ID
 * Fetches a student by their UUID.
 */
export const getStudentByIdOptions = (options: Options<GetStudentByIdData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getStudentById({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getStudentByIdQueryKey(options),
  });
};

/**
 * Update a student
 * Updates an existing student record.
 */
export const updateStudentMutation = (
  options?: Partial<Options<UpdateStudentData>>
): UseMutationOptions<UpdateStudentResponse, UpdateStudentError, Options<UpdateStudentData>> => {
  const mutationOptions: UseMutationOptions<
    UpdateStudentResponse,
    UpdateStudentError,
    Options<UpdateStudentData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await updateStudent({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Delete an assessment rubric
 * Deletes an assessment rubric and all its associated criteria and scoring levels.
 */
export const deleteAssessmentRubricMutation = (
  options?: Partial<Options<DeleteAssessmentRubricData>>
): UseMutationOptions<
  unknown,
  DeleteAssessmentRubricError,
  Options<DeleteAssessmentRubricData>
> => {
  const mutationOptions: UseMutationOptions<
    unknown,
    DeleteAssessmentRubricError,
    Options<DeleteAssessmentRubricData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await deleteAssessmentRubric({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getAssessmentRubricByUuidQueryKey = (
  options: Options<GetAssessmentRubricByUuidData>
) => createQueryKey('getAssessmentRubricByUuid', options);

/**
 * Get an assessment rubric by UUID
 * Retrieves a single assessment rubric by its unique identifier.
 */
export const getAssessmentRubricByUuidOptions = (
  options: Options<GetAssessmentRubricByUuidData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getAssessmentRubricByUuid({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getAssessmentRubricByUuidQueryKey(options),
  });
};

/**
 * Update an assessment rubric
 * Updates an existing assessment rubric.
 */
export const updateAssessmentRubricMutation = (
  options?: Partial<Options<UpdateAssessmentRubricData>>
): UseMutationOptions<
  UpdateAssessmentRubricResponse,
  UpdateAssessmentRubricError,
  Options<UpdateAssessmentRubricData>
> => {
  const mutationOptions: UseMutationOptions<
    UpdateAssessmentRubricResponse,
    UpdateAssessmentRubricError,
    Options<UpdateAssessmentRubricData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await updateAssessmentRubric({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Delete a scoring level
 * Removes a scoring level from the specified rubric. This will also remove any associated matrix cells.
 */
export const deleteScoringLevelMutation = (
  options?: Partial<Options<DeleteScoringLevelData>>
): UseMutationOptions<
  DeleteScoringLevelResponse,
  DeleteScoringLevelError,
  Options<DeleteScoringLevelData>
> => {
  const mutationOptions: UseMutationOptions<
    DeleteScoringLevelResponse,
    DeleteScoringLevelError,
    Options<DeleteScoringLevelData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await deleteScoringLevel({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getScoringLevelQueryKey = (options: Options<GetScoringLevelData>) =>
  createQueryKey('getScoringLevel', options);

/**
 * Get a specific scoring level
 * Retrieves a specific scoring level by its UUID within the context of the rubric.
 */
export const getScoringLevelOptions = (options: Options<GetScoringLevelData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getScoringLevel({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getScoringLevelQueryKey(options),
  });
};

/**
 * Update a scoring level
 * Updates an existing scoring level within the specified rubric.
 */
export const updateScoringLevelMutation = (
  options?: Partial<Options<UpdateScoringLevelData>>
): UseMutationOptions<
  UpdateScoringLevelResponse,
  UpdateScoringLevelError,
  Options<UpdateScoringLevelData>
> => {
  const mutationOptions: UseMutationOptions<
    UpdateScoringLevelResponse,
    UpdateScoringLevelError,
    Options<UpdateScoringLevelData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await updateScoringLevel({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Update matrix cell
 * Updates the description for a specific matrix cell (criteria-scoring level intersection).
 */
export const updateMatrixCellMutation = (
  options?: Partial<Options<UpdateMatrixCellData>>
): UseMutationOptions<
  UpdateMatrixCellResponse,
  UpdateMatrixCellError,
  Options<UpdateMatrixCellData>
> => {
  const mutationOptions: UseMutationOptions<
    UpdateMatrixCellResponse,
    UpdateMatrixCellError,
    Options<UpdateMatrixCellData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await updateMatrixCell({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Delete a rubric criterion
 * Deletes a criterion from a rubric.
 */
export const deleteRubricCriterionMutation = (
  options?: Partial<Options<DeleteRubricCriterionData>>
): UseMutationOptions<unknown, DeleteRubricCriterionError, Options<DeleteRubricCriterionData>> => {
  const mutationOptions: UseMutationOptions<
    unknown,
    DeleteRubricCriterionError,
    Options<DeleteRubricCriterionData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await deleteRubricCriterion({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Update a rubric criterion
 * Updates an existing criterion within a rubric.
 */
export const updateRubricCriterionMutation = (
  options?: Partial<Options<UpdateRubricCriterionData>>
): UseMutationOptions<
  UpdateRubricCriterionResponse,
  UpdateRubricCriterionError,
  Options<UpdateRubricCriterionData>
> => {
  const mutationOptions: UseMutationOptions<
    UpdateRubricCriterionResponse,
    UpdateRubricCriterionError,
    Options<UpdateRubricCriterionData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await updateRubricCriterion({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Delete a scoring level
 * Deletes a scoring level from a criterion.
 */
export const deleteRubricScoringMutation = (
  options?: Partial<Options<DeleteRubricScoringData>>
): UseMutationOptions<unknown, DeleteRubricScoringError, Options<DeleteRubricScoringData>> => {
  const mutationOptions: UseMutationOptions<
    unknown,
    DeleteRubricScoringError,
    Options<DeleteRubricScoringData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await deleteRubricScoring({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Update a scoring level
 * Updates an existing scoring level for a criterion.
 */
export const updateRubricScoringMutation = (
  options?: Partial<Options<UpdateRubricScoringData>>
): UseMutationOptions<
  UpdateRubricScoringResponse,
  UpdateRubricScoringError,
  Options<UpdateRubricScoringData>
> => {
  const mutationOptions: UseMutationOptions<
    UpdateRubricScoringResponse,
    UpdateRubricScoringError,
    Options<UpdateRubricScoringData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await updateRubricScoring({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Delete quiz
 * Permanently removes a quiz and all associated data.
 */
export const deleteQuizMutation = (
  options?: Partial<Options<DeleteQuizData>>
): UseMutationOptions<DeleteQuizResponse, DeleteQuizError, Options<DeleteQuizData>> => {
  const mutationOptions: UseMutationOptions<
    DeleteQuizResponse,
    DeleteQuizError,
    Options<DeleteQuizData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await deleteQuiz({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getQuizByUuidQueryKey = (options: Options<GetQuizByUuidData>) =>
  createQueryKey('getQuizByUuid', options);

/**
 * Get quiz by UUID
 * Retrieves a complete quiz including questions and computed properties.
 */
export const getQuizByUuidOptions = (options: Options<GetQuizByUuidData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getQuizByUuid({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getQuizByUuidQueryKey(options),
  });
};

/**
 * Update quiz
 * Updates an existing quiz with selective field updates.
 */
export const updateQuizMutation = (
  options?: Partial<Options<UpdateQuizData>>
): UseMutationOptions<UpdateQuizResponse, UpdateQuizError, Options<UpdateQuizData>> => {
  const mutationOptions: UseMutationOptions<
    UpdateQuizResponse,
    UpdateQuizError,
    Options<UpdateQuizData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await updateQuiz({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Delete quiz question
 * Removes a question from a quiz including all options and responses.
 */
export const deleteQuizQuestionMutation = (
  options?: Partial<Options<DeleteQuizQuestionData>>
): UseMutationOptions<unknown, DeleteQuizQuestionError, Options<DeleteQuizQuestionData>> => {
  const mutationOptions: UseMutationOptions<
    unknown,
    DeleteQuizQuestionError,
    Options<DeleteQuizQuestionData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await deleteQuizQuestion({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Update quiz question
 * Updates a specific question within a quiz.
 */
export const updateQuizQuestionMutation = (
  options?: Partial<Options<UpdateQuizQuestionData>>
): UseMutationOptions<
  UpdateQuizQuestionResponse,
  UpdateQuizQuestionError,
  Options<UpdateQuizQuestionData>
> => {
  const mutationOptions: UseMutationOptions<
    UpdateQuizQuestionResponse,
    UpdateQuizQuestionError,
    Options<UpdateQuizQuestionData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await updateQuizQuestion({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Delete question option
 * Removes an option from a question.
 */
export const deleteQuestionOptionMutation = (
  options?: Partial<Options<DeleteQuestionOptionData>>
): UseMutationOptions<unknown, DeleteQuestionOptionError, Options<DeleteQuestionOptionData>> => {
  const mutationOptions: UseMutationOptions<
    unknown,
    DeleteQuestionOptionError,
    Options<DeleteQuestionOptionData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await deleteQuestionOption({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Update question option
 * Updates a specific option for a question.
 */
export const updateQuestionOptionMutation = (
  options?: Partial<Options<UpdateQuestionOptionData>>
): UseMutationOptions<
  UpdateQuestionOptionResponse,
  UpdateQuestionOptionError,
  Options<UpdateQuestionOptionData>
> => {
  const mutationOptions: UseMutationOptions<
    UpdateQuestionOptionResponse,
    UpdateQuestionOptionError,
    Options<UpdateQuestionOptionData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await updateQuestionOption({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Delete training program
 * Permanently removes a training program and its associated data.
 */
export const deleteTrainingProgramMutation = (
  options?: Partial<Options<DeleteTrainingProgramData>>
): UseMutationOptions<
  DeleteTrainingProgramResponse,
  DeleteTrainingProgramError,
  Options<DeleteTrainingProgramData>
> => {
  const mutationOptions: UseMutationOptions<
    DeleteTrainingProgramResponse,
    DeleteTrainingProgramError,
    Options<DeleteTrainingProgramData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await deleteTrainingProgram({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getTrainingProgramByUuidQueryKey = (options: Options<GetTrainingProgramByUuidData>) =>
  createQueryKey('getTrainingProgramByUuid', options);

/**
 * Get program by UUID
 * Retrieves a complete program profile including computed properties and analytics.
 */
export const getTrainingProgramByUuidOptions = (options: Options<GetTrainingProgramByUuidData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getTrainingProgramByUuid({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getTrainingProgramByUuidQueryKey(options),
  });
};

/**
 * Update training program
 * Updates an existing training program with selective field updates.
 */
export const updateTrainingProgramMutation = (
  options?: Partial<Options<UpdateTrainingProgramData>>
): UseMutationOptions<
  UpdateTrainingProgramResponse,
  UpdateTrainingProgramError,
  Options<UpdateTrainingProgramData>
> => {
  const mutationOptions: UseMutationOptions<
    UpdateTrainingProgramResponse,
    UpdateTrainingProgramError,
    Options<UpdateTrainingProgramData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await updateTrainingProgram({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Delete program requirement
 * Removes a requirement from a program.
 */
export const deleteProgramRequirementMutation = (
  options?: Partial<Options<DeleteProgramRequirementData>>
): UseMutationOptions<
  unknown,
  DeleteProgramRequirementError,
  Options<DeleteProgramRequirementData>
> => {
  const mutationOptions: UseMutationOptions<
    unknown,
    DeleteProgramRequirementError,
    Options<DeleteProgramRequirementData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await deleteProgramRequirement({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Update program requirement
 * Updates a specific requirement for a program.
 */
export const updateProgramRequirementMutation = (
  options?: Partial<Options<UpdateProgramRequirementData>>
): UseMutationOptions<
  UpdateProgramRequirementResponse,
  UpdateProgramRequirementError,
  Options<UpdateProgramRequirementData>
> => {
  const mutationOptions: UseMutationOptions<
    UpdateProgramRequirementResponse,
    UpdateProgramRequirementError,
    Options<UpdateProgramRequirementData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await updateProgramRequirement({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Remove course from program
 * Removes the association between a course and program.
 */
export const removeProgramCourseMutation = (
  options?: Partial<Options<RemoveProgramCourseData>>
): UseMutationOptions<unknown, RemoveProgramCourseError, Options<RemoveProgramCourseData>> => {
  const mutationOptions: UseMutationOptions<
    unknown,
    RemoveProgramCourseError,
    Options<RemoveProgramCourseData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await removeProgramCourse({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Update program course
 * Updates course association settings within a program.
 */
export const updateProgramCourseMutation = (
  options?: Partial<Options<UpdateProgramCourseData>>
): UseMutationOptions<
  UpdateProgramCourseResponse,
  UpdateProgramCourseError,
  Options<UpdateProgramCourseData>
> => {
  const mutationOptions: UseMutationOptions<
    UpdateProgramCourseResponse,
    UpdateProgramCourseError,
    Options<UpdateProgramCourseData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await updateProgramCourse({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Delete an organisation by UUID
 */
export const deleteOrganisationMutation = (
  options?: Partial<Options<DeleteOrganisationData>>
): UseMutationOptions<
  DeleteOrganisationResponse,
  DeleteOrganisationError,
  Options<DeleteOrganisationData>
> => {
  const mutationOptions: UseMutationOptions<
    DeleteOrganisationResponse,
    DeleteOrganisationError,
    Options<DeleteOrganisationData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await deleteOrganisation({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getOrganisationByUuidQueryKey = (options: Options<GetOrganisationByUuidData>) =>
  createQueryKey('getOrganisationByUuid', options);

/**
 * Get an organisation by UUID
 */
export const getOrganisationByUuidOptions = (options: Options<GetOrganisationByUuidData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getOrganisationByUuid({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getOrganisationByUuidQueryKey(options),
  });
};

/**
 * Update an organisation by UUID
 */
export const updateOrganisationMutation = (
  options?: Partial<Options<UpdateOrganisationData>>
): UseMutationOptions<
  UpdateOrganisationResponse,
  UpdateOrganisationError,
  Options<UpdateOrganisationData>
> => {
  const mutationOptions: UseMutationOptions<
    UpdateOrganisationResponse,
    UpdateOrganisationError,
    Options<UpdateOrganisationData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await updateOrganisation({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Delete a training branch by UUID within organization
 */
export const deleteTrainingBranch1Mutation = (
  options?: Partial<Options<DeleteTrainingBranch1Data>>
): UseMutationOptions<
  DeleteTrainingBranch1Response,
  DeleteTrainingBranch1Error,
  Options<DeleteTrainingBranch1Data>
> => {
  const mutationOptions: UseMutationOptions<
    DeleteTrainingBranch1Response,
    DeleteTrainingBranch1Error,
    Options<DeleteTrainingBranch1Data>
  > = {
    mutationFn: async localOptions => {
      const { data } = await deleteTrainingBranch1({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getTrainingBranchByUuid1QueryKey = (options: Options<GetTrainingBranchByUuid1Data>) =>
  createQueryKey('getTrainingBranchByUuid1', options);

/**
 * Get a training branch by UUID within organization
 */
export const getTrainingBranchByUuid1Options = (options: Options<GetTrainingBranchByUuid1Data>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getTrainingBranchByUuid1({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getTrainingBranchByUuid1QueryKey(options),
  });
};

/**
 * Update a training branch by UUID within organization
 */
export const updateTrainingBranch1Mutation = (
  options?: Partial<Options<UpdateTrainingBranch1Data>>
): UseMutationOptions<
  UpdateTrainingBranch1Response,
  UpdateTrainingBranch1Error,
  Options<UpdateTrainingBranch1Data>
> => {
  const mutationOptions: UseMutationOptions<
    UpdateTrainingBranch1Response,
    UpdateTrainingBranch1Error,
    Options<UpdateTrainingBranch1Data>
  > = {
    mutationFn: async localOptions => {
      const { data } = await updateTrainingBranch1({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Delete an instructor
 * Removes an instructor record from the system.
 */
export const deleteInstructorMutation = (
  options?: Partial<Options<DeleteInstructorData>>
): UseMutationOptions<
  DeleteInstructorResponse,
  DeleteInstructorError,
  Options<DeleteInstructorData>
> => {
  const mutationOptions: UseMutationOptions<
    DeleteInstructorResponse,
    DeleteInstructorError,
    Options<DeleteInstructorData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await deleteInstructor({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getInstructorByUuidQueryKey = (options: Options<GetInstructorByUuidData>) =>
  createQueryKey('getInstructorByUuid', options);

/**
 * Get instructor by UUID
 * Fetches an instructor by their UUID.
 */
export const getInstructorByUuidOptions = (options: Options<GetInstructorByUuidData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getInstructorByUuid({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getInstructorByUuidQueryKey(options),
  });
};

/**
 * Update an instructor
 * Updates an existing instructor record.
 */
export const updateInstructorMutation = (
  options?: Partial<Options<UpdateInstructorData>>
): UseMutationOptions<
  UpdateInstructorResponse,
  UpdateInstructorError,
  Options<UpdateInstructorData>
> => {
  const mutationOptions: UseMutationOptions<
    UpdateInstructorResponse,
    UpdateInstructorError,
    Options<UpdateInstructorData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await updateInstructor({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Delete instructor skill
 * Removes a skill from an instructor
 */
export const deleteInstructorSkillMutation = (
  options?: Partial<Options<DeleteInstructorSkillData>>
): UseMutationOptions<unknown, DeleteInstructorSkillError, Options<DeleteInstructorSkillData>> => {
  const mutationOptions: UseMutationOptions<
    unknown,
    DeleteInstructorSkillError,
    Options<DeleteInstructorSkillData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await deleteInstructorSkill({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Update instructor skill
 * Updates a specific skill record
 */
export const updateInstructorSkillMutation = (
  options?: Partial<Options<UpdateInstructorSkillData>>
): UseMutationOptions<
  UpdateInstructorSkillResponse,
  UpdateInstructorSkillError,
  Options<UpdateInstructorSkillData>
> => {
  const mutationOptions: UseMutationOptions<
    UpdateInstructorSkillResponse,
    UpdateInstructorSkillError,
    Options<UpdateInstructorSkillData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await updateInstructorSkill({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Delete instructor membership
 * Removes a membership record from an instructor
 */
export const deleteInstructorMembershipMutation = (
  options?: Partial<Options<DeleteInstructorMembershipData>>
): UseMutationOptions<
  unknown,
  DeleteInstructorMembershipError,
  Options<DeleteInstructorMembershipData>
> => {
  const mutationOptions: UseMutationOptions<
    unknown,
    DeleteInstructorMembershipError,
    Options<DeleteInstructorMembershipData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await deleteInstructorMembership({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Update instructor membership
 * Updates a specific membership record
 */
export const updateInstructorMembershipMutation = (
  options?: Partial<Options<UpdateInstructorMembershipData>>
): UseMutationOptions<
  UpdateInstructorMembershipResponse,
  UpdateInstructorMembershipError,
  Options<UpdateInstructorMembershipData>
> => {
  const mutationOptions: UseMutationOptions<
    UpdateInstructorMembershipResponse,
    UpdateInstructorMembershipError,
    Options<UpdateInstructorMembershipData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await updateInstructorMembership({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Delete instructor experience
 * Removes an experience record from an instructor
 */
export const deleteInstructorExperienceMutation = (
  options?: Partial<Options<DeleteInstructorExperienceData>>
): UseMutationOptions<
  unknown,
  DeleteInstructorExperienceError,
  Options<DeleteInstructorExperienceData>
> => {
  const mutationOptions: UseMutationOptions<
    unknown,
    DeleteInstructorExperienceError,
    Options<DeleteInstructorExperienceData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await deleteInstructorExperience({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Update instructor experience
 * Updates a specific experience record
 */
export const updateInstructorExperienceMutation = (
  options?: Partial<Options<UpdateInstructorExperienceData>>
): UseMutationOptions<
  UpdateInstructorExperienceResponse,
  UpdateInstructorExperienceError,
  Options<UpdateInstructorExperienceData>
> => {
  const mutationOptions: UseMutationOptions<
    UpdateInstructorExperienceResponse,
    UpdateInstructorExperienceError,
    Options<UpdateInstructorExperienceData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await updateInstructorExperience({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Delete instructor education
 * Removes an education record from an instructor
 */
export const deleteInstructorEducationMutation = (
  options?: Partial<Options<DeleteInstructorEducationData>>
): UseMutationOptions<
  unknown,
  DeleteInstructorEducationError,
  Options<DeleteInstructorEducationData>
> => {
  const mutationOptions: UseMutationOptions<
    unknown,
    DeleteInstructorEducationError,
    Options<DeleteInstructorEducationData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await deleteInstructorEducation({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Update instructor education
 * Updates a specific education record
 */
export const updateInstructorEducationMutation = (
  options?: Partial<Options<UpdateInstructorEducationData>>
): UseMutationOptions<
  UpdateInstructorEducationResponse,
  UpdateInstructorEducationError,
  Options<UpdateInstructorEducationData>
> => {
  const mutationOptions: UseMutationOptions<
    UpdateInstructorEducationResponse,
    UpdateInstructorEducationError,
    Options<UpdateInstructorEducationData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await updateInstructorEducation({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Delete instructor document
 * Removes a document from an instructor
 */
export const deleteInstructorDocumentMutation = (
  options?: Partial<Options<DeleteInstructorDocumentData>>
): UseMutationOptions<
  unknown,
  DeleteInstructorDocumentError,
  Options<DeleteInstructorDocumentData>
> => {
  const mutationOptions: UseMutationOptions<
    unknown,
    DeleteInstructorDocumentError,
    Options<DeleteInstructorDocumentData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await deleteInstructorDocument({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Update instructor document
 * Updates a specific document
 */
export const updateInstructorDocumentMutation = (
  options?: Partial<Options<UpdateInstructorDocumentData>>
): UseMutationOptions<
  UpdateInstructorDocumentResponse,
  UpdateInstructorDocumentError,
  Options<UpdateInstructorDocumentData>
> => {
  const mutationOptions: UseMutationOptions<
    UpdateInstructorDocumentResponse,
    UpdateInstructorDocumentError,
    Options<UpdateInstructorDocumentData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await updateInstructorDocument({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Delete course
 * Permanently removes a course, its category associations, and all associated data.
 */
export const deleteCourseMutation = (
  options?: Partial<Options<DeleteCourseData>>
): UseMutationOptions<DeleteCourseResponse, DeleteCourseError, Options<DeleteCourseData>> => {
  const mutationOptions: UseMutationOptions<
    DeleteCourseResponse,
    DeleteCourseError,
    Options<DeleteCourseData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await deleteCourse({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getCourseByUuidQueryKey = (options: Options<GetCourseByUuidData>) =>
  createQueryKey('getCourseByUuid', options);

/**
 * Get course by UUID
 * Retrieves a complete course profile including computed properties and category information.
 *
 * **Response includes:**
 * - All course details and metadata
 * - `category_uuids`: List of category UUIDs the course belongs to
 * - `category_names`: List of category names for display (read-only)
 * - `category_count`: Number of categories assigned to the course
 * - `has_multiple_categories`: Boolean indicating if course has multiple categories
 *
 */
export const getCourseByUuidOptions = (options: Options<GetCourseByUuidData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getCourseByUuid({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getCourseByUuidQueryKey(options),
  });
};

/**
 * Update course
 * Updates an existing course with selective field updates including category management.
 *
 * **Category Updates:**
 * - Provide `category_uuids` to completely replace existing categories
 * - To add categories, include existing + new category UUIDs
 * - To remove all categories, provide an empty array
 * - Changes to categories are applied atomically
 *
 * **Authorization:** Only the course owner can update the course.
 *
 */
export const updateCourseMutation = (
  options?: Partial<Options<UpdateCourseData>>
): UseMutationOptions<UpdateCourseResponse, UpdateCourseError, Options<UpdateCourseData>> => {
  const mutationOptions: UseMutationOptions<
    UpdateCourseResponse,
    UpdateCourseError,
    Options<UpdateCourseData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await updateCourse({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Delete training delivery requirement
 * Removes a training delivery requirement from a course.
 */
export const deleteCourseTrainingRequirementMutation = (
  options?: Partial<Options<DeleteCourseTrainingRequirementData>>
): UseMutationOptions<
  unknown,
  DeleteCourseTrainingRequirementError,
  Options<DeleteCourseTrainingRequirementData>
> => {
  const mutationOptions: UseMutationOptions<
    unknown,
    DeleteCourseTrainingRequirementError,
    Options<DeleteCourseTrainingRequirementData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await deleteCourseTrainingRequirement({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Update training delivery requirement
 * Updates a specific training delivery requirement for a course.
 */
export const updateCourseTrainingRequirementMutation = (
  options?: Partial<Options<UpdateCourseTrainingRequirementData>>
): UseMutationOptions<
  UpdateCourseTrainingRequirementResponse,
  UpdateCourseTrainingRequirementError,
  Options<UpdateCourseTrainingRequirementData>
> => {
  const mutationOptions: UseMutationOptions<
    UpdateCourseTrainingRequirementResponse,
    UpdateCourseTrainingRequirementError,
    Options<UpdateCourseTrainingRequirementData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await updateCourseTrainingRequirement({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Set primary rubric for a course
 * Designates a specific rubric as the primary rubric for the course.
 */
export const setPrimaryRubricMutation = (
  options?: Partial<Options<SetPrimaryRubricData>>
): UseMutationOptions<
  SetPrimaryRubricResponse,
  SetPrimaryRubricError,
  Options<SetPrimaryRubricData>
> => {
  const mutationOptions: UseMutationOptions<
    SetPrimaryRubricResponse,
    SetPrimaryRubricError,
    Options<SetPrimaryRubricData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await setPrimaryRubric({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Update rubric association
 * Updates an existing rubric association, allowing changes to context, primary status, etc.
 */
export const updateAssociationMutation = (
  options?: Partial<Options<UpdateAssociationData>>
): UseMutationOptions<
  UpdateAssociationResponse,
  UpdateAssociationError,
  Options<UpdateAssociationData>
> => {
  const mutationOptions: UseMutationOptions<
    UpdateAssociationResponse,
    UpdateAssociationError,
    Options<UpdateAssociationData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await updateAssociation({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Delete course requirement
 * Removes a requirement from a course.
 */
export const deleteCourseRequirementMutation = (
  options?: Partial<Options<DeleteCourseRequirementData>>
): UseMutationOptions<
  unknown,
  DeleteCourseRequirementError,
  Options<DeleteCourseRequirementData>
> => {
  const mutationOptions: UseMutationOptions<
    unknown,
    DeleteCourseRequirementError,
    Options<DeleteCourseRequirementData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await deleteCourseRequirement({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Update course requirement
 * Updates a specific requirement for a course.
 */
export const updateCourseRequirementMutation = (
  options?: Partial<Options<UpdateCourseRequirementData>>
): UseMutationOptions<
  UpdateCourseRequirementResponse,
  UpdateCourseRequirementError,
  Options<UpdateCourseRequirementData>
> => {
  const mutationOptions: UseMutationOptions<
    UpdateCourseRequirementResponse,
    UpdateCourseRequirementError,
    Options<UpdateCourseRequirementData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await updateCourseRequirement({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Delete course lesson
 * Removes a lesson from a course including all associated content.
 */
export const deleteCourseLessonMutation = (
  options?: Partial<Options<DeleteCourseLessonData>>
): UseMutationOptions<unknown, DeleteCourseLessonError, Options<DeleteCourseLessonData>> => {
  const mutationOptions: UseMutationOptions<
    unknown,
    DeleteCourseLessonError,
    Options<DeleteCourseLessonData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await deleteCourseLesson({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getCourseLessonQueryKey = (options: Options<GetCourseLessonData>) =>
  createQueryKey('getCourseLesson', options);

/**
 * Get lesson by UUID
 * Retrieves a specific lesson by its UUID within a course context.
 *
 * **Lesson Retrieval Details:**
 * - Returns complete lesson profile including computed properties
 * - Validates that the lesson belongs to the specified course
 * - Includes lesson content count and duration calculations
 * - Provides lesson status and completion tracking information
 *
 * **Response includes:**
 * - Basic lesson information (title, description, objectives)
 * - Lesson metadata (duration, sequence number, status)
 * - Associated course UUID validation
 * - Content summary statistics
 * - Computed properties (isCompleted, progressPercentage for authenticated users)
 *
 * **Use Cases:**
 * - Direct lesson navigation from course content
 * - Lesson detail page rendering
 * - Progress tracking and analytics
 * - Content validation and prerequisites checking
 *
 * **Security Considerations:**
 * - Validates lesson belongs to specified course
 * - Respects course enrollment status for detailed information
 * - May return limited data for unenrolled users depending on course visibility settings
 *
 */
export const getCourseLessonOptions = (options: Options<GetCourseLessonData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getCourseLesson({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getCourseLessonQueryKey(options),
  });
};

/**
 * Update course lesson
 * Updates a specific lesson within a course.
 */
export const updateCourseLessonMutation = (
  options?: Partial<Options<UpdateCourseLessonData>>
): UseMutationOptions<
  UpdateCourseLessonResponse,
  UpdateCourseLessonError,
  Options<UpdateCourseLessonData>
> => {
  const mutationOptions: UseMutationOptions<
    UpdateCourseLessonResponse,
    UpdateCourseLessonError,
    Options<UpdateCourseLessonData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await updateCourseLesson({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Delete lesson content
 * Removes content from a lesson.
 */
export const deleteLessonContentMutation = (
  options?: Partial<Options<DeleteLessonContentData>>
): UseMutationOptions<unknown, DeleteLessonContentError, Options<DeleteLessonContentData>> => {
  const mutationOptions: UseMutationOptions<
    unknown,
    DeleteLessonContentError,
    Options<DeleteLessonContentData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await deleteLessonContent({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Update lesson content
 * Updates a specific content item within a lesson.
 */
export const updateLessonContentMutation = (
  options?: Partial<Options<UpdateLessonContentData>>
): UseMutationOptions<
  UpdateLessonContentResponse,
  UpdateLessonContentError,
  Options<UpdateLessonContentData>
> => {
  const mutationOptions: UseMutationOptions<
    UpdateLessonContentResponse,
    UpdateLessonContentError,
    Options<UpdateLessonContentData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await updateLessonContent({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Delete course assessment
 * Removes an assessment from a course.
 */
export const deleteCourseAssessmentMutation = (
  options?: Partial<Options<DeleteCourseAssessmentData>>
): UseMutationOptions<
  unknown,
  DeleteCourseAssessmentError,
  Options<DeleteCourseAssessmentData>
> => {
  const mutationOptions: UseMutationOptions<
    unknown,
    DeleteCourseAssessmentError,
    Options<DeleteCourseAssessmentData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await deleteCourseAssessment({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Update course assessment
 * Updates a specific assessment within a course.
 */
export const updateCourseAssessmentMutation = (
  options?: Partial<Options<UpdateCourseAssessmentData>>
): UseMutationOptions<
  UpdateCourseAssessmentResponse,
  UpdateCourseAssessmentError,
  Options<UpdateCourseAssessmentData>
> => {
  const mutationOptions: UseMutationOptions<
    UpdateCourseAssessmentResponse,
    UpdateCourseAssessmentError,
    Options<UpdateCourseAssessmentData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await updateCourseAssessment({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Delete a course creator
 * Removes a course creator profile from the system. This will cascade delete associated data.
 */
export const deleteCourseCreatorMutation = (
  options?: Partial<Options<DeleteCourseCreatorData>>
): UseMutationOptions<
  DeleteCourseCreatorResponse,
  DeleteCourseCreatorError,
  Options<DeleteCourseCreatorData>
> => {
  const mutationOptions: UseMutationOptions<
    DeleteCourseCreatorResponse,
    DeleteCourseCreatorError,
    Options<DeleteCourseCreatorData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await deleteCourseCreator({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getCourseCreatorByUuidQueryKey = (options: Options<GetCourseCreatorByUuidData>) =>
  createQueryKey('getCourseCreatorByUuid', options);

/**
 * Get course creator by UUID
 * Fetches a course creator profile by their unique identifier.
 */
export const getCourseCreatorByUuidOptions = (options: Options<GetCourseCreatorByUuidData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getCourseCreatorByUuid({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getCourseCreatorByUuidQueryKey(options),
  });
};

/**
 * Update a course creator
 * Updates an existing course creator profile. Only allows updating mutable fields like bio, professional headline, and website.
 */
export const updateCourseCreatorMutation = (
  options?: Partial<Options<UpdateCourseCreatorData>>
): UseMutationOptions<
  UpdateCourseCreatorResponse,
  UpdateCourseCreatorError,
  Options<UpdateCourseCreatorData>
> => {
  const mutationOptions: UseMutationOptions<
    UpdateCourseCreatorResponse,
    UpdateCourseCreatorError,
    Options<UpdateCourseCreatorData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await updateCourseCreator({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Delete course creator skill
 * Removes a skill record from a course creator profile.
 */
export const deleteCourseCreatorSkillMutation = (
  options?: Partial<Options<DeleteCourseCreatorSkillData>>
): UseMutationOptions<
  unknown,
  DeleteCourseCreatorSkillError,
  Options<DeleteCourseCreatorSkillData>
> => {
  const mutationOptions: UseMutationOptions<
    unknown,
    DeleteCourseCreatorSkillError,
    Options<DeleteCourseCreatorSkillData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await deleteCourseCreatorSkill({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Update course creator skill
 * Updates a recorded skill for a course creator.
 */
export const updateCourseCreatorSkillMutation = (
  options?: Partial<Options<UpdateCourseCreatorSkillData>>
): UseMutationOptions<
  UpdateCourseCreatorSkillResponse,
  UpdateCourseCreatorSkillError,
  Options<UpdateCourseCreatorSkillData>
> => {
  const mutationOptions: UseMutationOptions<
    UpdateCourseCreatorSkillResponse,
    UpdateCourseCreatorSkillError,
    Options<UpdateCourseCreatorSkillData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await updateCourseCreatorSkill({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Delete membership record
 * Deletes a course creator membership record.
 */
export const deleteCourseCreatorMembershipMutation = (
  options?: Partial<Options<DeleteCourseCreatorMembershipData>>
): UseMutationOptions<
  unknown,
  DeleteCourseCreatorMembershipError,
  Options<DeleteCourseCreatorMembershipData>
> => {
  const mutationOptions: UseMutationOptions<
    unknown,
    DeleteCourseCreatorMembershipError,
    Options<DeleteCourseCreatorMembershipData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await deleteCourseCreatorMembership({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Update membership record
 * Updates a course creator professional membership.
 */
export const updateCourseCreatorMembershipMutation = (
  options?: Partial<Options<UpdateCourseCreatorMembershipData>>
): UseMutationOptions<
  UpdateCourseCreatorMembershipResponse,
  UpdateCourseCreatorMembershipError,
  Options<UpdateCourseCreatorMembershipData>
> => {
  const mutationOptions: UseMutationOptions<
    UpdateCourseCreatorMembershipResponse,
    UpdateCourseCreatorMembershipError,
    Options<UpdateCourseCreatorMembershipData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await updateCourseCreatorMembership({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Delete experience record
 * Removes a course creator experience entry.
 */
export const deleteCourseCreatorExperienceMutation = (
  options?: Partial<Options<DeleteCourseCreatorExperienceData>>
): UseMutationOptions<
  unknown,
  DeleteCourseCreatorExperienceError,
  Options<DeleteCourseCreatorExperienceData>
> => {
  const mutationOptions: UseMutationOptions<
    unknown,
    DeleteCourseCreatorExperienceError,
    Options<DeleteCourseCreatorExperienceData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await deleteCourseCreatorExperience({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Update experience
 * Updates a recorded work experience entry for a course creator.
 */
export const updateCourseCreatorExperienceMutation = (
  options?: Partial<Options<UpdateCourseCreatorExperienceData>>
): UseMutationOptions<
  UpdateCourseCreatorExperienceResponse,
  UpdateCourseCreatorExperienceError,
  Options<UpdateCourseCreatorExperienceData>
> => {
  const mutationOptions: UseMutationOptions<
    UpdateCourseCreatorExperienceResponse,
    UpdateCourseCreatorExperienceError,
    Options<UpdateCourseCreatorExperienceData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await updateCourseCreatorExperience({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Delete education record
 * Deletes an education record from a course creator profile.
 */
export const deleteCourseCreatorEducationMutation = (
  options?: Partial<Options<DeleteCourseCreatorEducationData>>
): UseMutationOptions<
  unknown,
  DeleteCourseCreatorEducationError,
  Options<DeleteCourseCreatorEducationData>
> => {
  const mutationOptions: UseMutationOptions<
    unknown,
    DeleteCourseCreatorEducationError,
    Options<DeleteCourseCreatorEducationData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await deleteCourseCreatorEducation({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Update education record
 * Updates an existing course creator education entry.
 */
export const updateCourseCreatorEducationMutation = (
  options?: Partial<Options<UpdateCourseCreatorEducationData>>
): UseMutationOptions<
  UpdateCourseCreatorEducationResponse,
  UpdateCourseCreatorEducationError,
  Options<UpdateCourseCreatorEducationData>
> => {
  const mutationOptions: UseMutationOptions<
    UpdateCourseCreatorEducationResponse,
    UpdateCourseCreatorEducationError,
    Options<UpdateCourseCreatorEducationData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await updateCourseCreatorEducation({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Delete certification record
 * Deletes a certification entry from a course creator profile.
 */
export const deleteCourseCreatorCertificationMutation = (
  options?: Partial<Options<DeleteCourseCreatorCertificationData>>
): UseMutationOptions<
  unknown,
  DeleteCourseCreatorCertificationError,
  Options<DeleteCourseCreatorCertificationData>
> => {
  const mutationOptions: UseMutationOptions<
    unknown,
    DeleteCourseCreatorCertificationError,
    Options<DeleteCourseCreatorCertificationData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await deleteCourseCreatorCertification({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Update certification record
 * Updates certification metadata for a course creator.
 */
export const updateCourseCreatorCertificationMutation = (
  options?: Partial<Options<UpdateCourseCreatorCertificationData>>
): UseMutationOptions<
  UpdateCourseCreatorCertificationResponse,
  UpdateCourseCreatorCertificationError,
  Options<UpdateCourseCreatorCertificationData>
> => {
  const mutationOptions: UseMutationOptions<
    UpdateCourseCreatorCertificationResponse,
    UpdateCourseCreatorCertificationError,
    Options<UpdateCourseCreatorCertificationData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await updateCourseCreatorCertification({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Delete grading level
 * Removes a grading level.
 */
export const deleteGradingLevelMutation = (
  options?: Partial<Options<DeleteGradingLevelData>>
): UseMutationOptions<unknown, DeleteGradingLevelError, Options<DeleteGradingLevelData>> => {
  const mutationOptions: UseMutationOptions<
    unknown,
    DeleteGradingLevelError,
    Options<DeleteGradingLevelData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await deleteGradingLevel({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Update grading level
 * Updates an existing grading level.
 */
export const updateGradingLevelMutation = (
  options?: Partial<Options<UpdateGradingLevelData>>
): UseMutationOptions<
  UpdateGradingLevelResponse,
  UpdateGradingLevelError,
  Options<UpdateGradingLevelData>
> => {
  const mutationOptions: UseMutationOptions<
    UpdateGradingLevelResponse,
    UpdateGradingLevelError,
    Options<UpdateGradingLevelData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await updateGradingLevel({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Delete difficulty level
 * Removes a difficulty level if no courses are using it.
 */
export const deleteDifficultyLevelMutation = (
  options?: Partial<Options<DeleteDifficultyLevelData>>
): UseMutationOptions<
  DeleteDifficultyLevelResponse,
  DeleteDifficultyLevelError,
  Options<DeleteDifficultyLevelData>
> => {
  const mutationOptions: UseMutationOptions<
    DeleteDifficultyLevelResponse,
    DeleteDifficultyLevelError,
    Options<DeleteDifficultyLevelData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await deleteDifficultyLevel({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Update difficulty level
 * Updates an existing difficulty level.
 */
export const updateDifficultyLevelMutation = (
  options?: Partial<Options<UpdateDifficultyLevelData>>
): UseMutationOptions<
  UpdateDifficultyLevelResponse,
  UpdateDifficultyLevelError,
  Options<UpdateDifficultyLevelData>
> => {
  const mutationOptions: UseMutationOptions<
    UpdateDifficultyLevelResponse,
    UpdateDifficultyLevelError,
    Options<UpdateDifficultyLevelData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await updateDifficultyLevel({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Delete content type
 * Removes a content type if no lesson content is using it.
 */
export const deleteContentTypeMutation = (
  options?: Partial<Options<DeleteContentTypeData>>
): UseMutationOptions<
  DeleteContentTypeResponse,
  DeleteContentTypeError,
  Options<DeleteContentTypeData>
> => {
  const mutationOptions: UseMutationOptions<
    DeleteContentTypeResponse,
    DeleteContentTypeError,
    Options<DeleteContentTypeData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await deleteContentType({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Update content type
 * Updates an existing content type.
 */
export const updateContentTypeMutation = (
  options?: Partial<Options<UpdateContentTypeData>>
): UseMutationOptions<
  UpdateContentTypeResponse,
  UpdateContentTypeError,
  Options<UpdateContentTypeData>
> => {
  const mutationOptions: UseMutationOptions<
    UpdateContentTypeResponse,
    UpdateContentTypeError,
    Options<UpdateContentTypeData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await updateContentType({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Delete category
 * Removes a category if it has no subcategories or associated courses.
 */
export const deleteCategoryMutation = (
  options?: Partial<Options<DeleteCategoryData>>
): UseMutationOptions<DeleteCategoryResponse, DeleteCategoryError, Options<DeleteCategoryData>> => {
  const mutationOptions: UseMutationOptions<
    DeleteCategoryResponse,
    DeleteCategoryError,
    Options<DeleteCategoryData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await deleteCategory({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getCategoryByUuidQueryKey = (options: Options<GetCategoryByUuidData>) =>
  createQueryKey('getCategoryByUuid', options);

/**
 * Get category by UUID
 * Retrieves a specific category by its UUID.
 */
export const getCategoryByUuidOptions = (options: Options<GetCategoryByUuidData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getCategoryByUuid({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getCategoryByUuidQueryKey(options),
  });
};

/**
 * Update category
 * Updates an existing category.
 */
export const updateCategoryMutation = (
  options?: Partial<Options<UpdateCategoryData>>
): UseMutationOptions<UpdateCategoryResponse, UpdateCategoryError, Options<UpdateCategoryData>> => {
  const mutationOptions: UseMutationOptions<
    UpdateCategoryResponse,
    UpdateCategoryError,
    Options<UpdateCategoryData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await updateCategory({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Update catalogue mapping
 * Updates internal variant identifiers or status for an existing mapping
 */
export const updateCatalogItemMutation = (
  options?: Partial<Options<UpdateCatalogItemData>>
): UseMutationOptions<
  UpdateCatalogItemResponse,
  UpdateCatalogItemError,
  Options<UpdateCatalogItemData>
> => {
  const mutationOptions: UseMutationOptions<
    UpdateCatalogItemResponse,
    UpdateCatalogItemError,
    Options<UpdateCatalogItemData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await updateCatalogItem({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Deactivate a class definition by UUID
 */
export const deactivateClassDefinitionMutation = (
  options?: Partial<Options<DeactivateClassDefinitionData>>
): UseMutationOptions<
  DeactivateClassDefinitionResponse,
  DeactivateClassDefinitionError,
  Options<DeactivateClassDefinitionData>
> => {
  const mutationOptions: UseMutationOptions<
    DeactivateClassDefinitionResponse,
    DeactivateClassDefinitionError,
    Options<DeactivateClassDefinitionData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await deactivateClassDefinition({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getClassDefinitionQueryKey = (options: Options<GetClassDefinitionData>) =>
  createQueryKey('getClassDefinition', options);

/**
 * Get a class definition by UUID
 */
export const getClassDefinitionOptions = (options: Options<GetClassDefinitionData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getClassDefinition({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getClassDefinitionQueryKey(options),
  });
};

/**
 * Update a class definition by UUID
 */
export const updateClassDefinitionMutation = (
  options?: Partial<Options<UpdateClassDefinitionData>>
): UseMutationOptions<
  UpdateClassDefinitionResponse,
  UpdateClassDefinitionError,
  Options<UpdateClassDefinitionData>
> => {
  const mutationOptions: UseMutationOptions<
    UpdateClassDefinitionResponse,
    UpdateClassDefinitionError,
    Options<UpdateClassDefinitionData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await updateClassDefinition({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getLessonPlanQueryKey = (options: Options<GetLessonPlanData>) =>
  createQueryKey('getLessonPlan', options);

/**
 * Get the lesson plan for a class definition
 */
export const getLessonPlanOptions = (options: Options<GetLessonPlanData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getLessonPlan({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getLessonPlanQueryKey(options),
  });
};

/**
 * Replace the lesson plan for a class definition
 */
export const saveLessonPlanMutation = (
  options?: Partial<Options<SaveLessonPlanData>>
): UseMutationOptions<SaveLessonPlanResponse, SaveLessonPlanError, Options<SaveLessonPlanData>> => {
  const mutationOptions: UseMutationOptions<
    SaveLessonPlanResponse,
    SaveLessonPlanError,
    Options<SaveLessonPlanData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await saveLessonPlan({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Delete certificate
 * Permanently removes a certificate record.
 */
export const deleteCertificateMutation = (
  options?: Partial<Options<DeleteCertificateData>>
): UseMutationOptions<
  DeleteCertificateResponse,
  DeleteCertificateError,
  Options<DeleteCertificateData>
> => {
  const mutationOptions: UseMutationOptions<
    DeleteCertificateResponse,
    DeleteCertificateError,
    Options<DeleteCertificateData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await deleteCertificate({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getCertificateByUuidQueryKey = (options: Options<GetCertificateByUuidData>) =>
  createQueryKey('getCertificateByUuid', options);

/**
 * Get certificate by UUID
 * Retrieves a complete certificate including computed properties and verification status.
 */
export const getCertificateByUuidOptions = (options: Options<GetCertificateByUuidData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getCertificateByUuid({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getCertificateByUuidQueryKey(options),
  });
};

/**
 * Update certificate
 * Updates an existing certificate with selective field updates.
 */
export const updateCertificateMutation = (
  options?: Partial<Options<UpdateCertificateData>>
): UseMutationOptions<
  UpdateCertificateResponse,
  UpdateCertificateError,
  Options<UpdateCertificateData>
> => {
  const mutationOptions: UseMutationOptions<
    UpdateCertificateResponse,
    UpdateCertificateError,
    Options<UpdateCertificateData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await updateCertificate({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Delete certificate template
 * Removes a certificate template.
 */
export const deleteCertificateTemplateMutation = (
  options?: Partial<Options<DeleteCertificateTemplateData>>
): UseMutationOptions<
  unknown,
  DeleteCertificateTemplateError,
  Options<DeleteCertificateTemplateData>
> => {
  const mutationOptions: UseMutationOptions<
    unknown,
    DeleteCertificateTemplateError,
    Options<DeleteCertificateTemplateData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await deleteCertificateTemplate({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Update certificate template
 * Updates an existing certificate template.
 */
export const updateCertificateTemplateMutation = (
  options?: Partial<Options<UpdateCertificateTemplateData>>
): UseMutationOptions<
  UpdateCertificateTemplateResponse,
  UpdateCertificateTemplateError,
  Options<UpdateCertificateTemplateData>
> => {
  const mutationOptions: UseMutationOptions<
    UpdateCertificateTemplateResponse,
    UpdateCertificateTemplateError,
    Options<UpdateCertificateTemplateData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await updateCertificateTemplate({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Delete assignment
 * Permanently removes an assignment and all associated submissions.
 */
export const deleteAssignmentMutation = (
  options?: Partial<Options<DeleteAssignmentData>>
): UseMutationOptions<
  DeleteAssignmentResponse,
  DeleteAssignmentError,
  Options<DeleteAssignmentData>
> => {
  const mutationOptions: UseMutationOptions<
    DeleteAssignmentResponse,
    DeleteAssignmentError,
    Options<DeleteAssignmentData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await deleteAssignment({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getAssignmentByUuidQueryKey = (options: Options<GetAssignmentByUuidData>) =>
  createQueryKey('getAssignmentByUuid', options);

/**
 * Get assignment by UUID
 * Retrieves a complete assignment including submission statistics.
 */
export const getAssignmentByUuidOptions = (options: Options<GetAssignmentByUuidData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getAssignmentByUuid({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getAssignmentByUuidQueryKey(options),
  });
};

/**
 * Update assignment
 * Updates an existing assignment with selective field updates.
 */
export const updateAssignmentMutation = (
  options?: Partial<Options<UpdateAssignmentData>>
): UseMutationOptions<
  UpdateAssignmentResponse,
  UpdateAssignmentError,
  Options<UpdateAssignmentData>
> => {
  const mutationOptions: UseMutationOptions<
    UpdateAssignmentResponse,
    UpdateAssignmentError,
    Options<UpdateAssignmentData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await updateAssignment({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Update an existing currency
 */
export const updateCurrencyMutation = (
  options?: Partial<Options<UpdateCurrencyData>>
): UseMutationOptions<UpdateCurrencyResponse, UpdateCurrencyError, Options<UpdateCurrencyData>> => {
  const mutationOptions: UseMutationOptions<
    UpdateCurrencyResponse,
    UpdateCurrencyError,
    Options<UpdateCurrencyData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await updateCurrency({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const uploadProfileImageQueryKey = (options: Options<UploadProfileImageData>) =>
  createQueryKey('uploadProfileImage', options);

/**
 * Upload User's Profile Image
 */
export const uploadProfileImageOptions = (options: Options<UploadProfileImageData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await uploadProfileImage({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: uploadProfileImageQueryKey(options),
  });
};

/**
 * Upload User's Profile Image
 */
export const uploadProfileImageMutation = (
  options?: Partial<Options<UploadProfileImageData>>
): UseMutationOptions<
  UploadProfileImageResponse,
  UploadProfileImageError,
  Options<UploadProfileImageData>
> => {
  const mutationOptions: UseMutationOptions<
    UploadProfileImageResponse,
    UploadProfileImageError,
    Options<UploadProfileImageData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await uploadProfileImage({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getAllTrainingBranchesQueryKey = (options: Options<GetAllTrainingBranchesData>) =>
  createQueryKey('getAllTrainingBranches', options);

/**
 * Get all training branches
 */
export const getAllTrainingBranchesOptions = (options: Options<GetAllTrainingBranchesData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getAllTrainingBranches({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getAllTrainingBranchesQueryKey(options),
  });
};

const createInfiniteParams = <
  K extends Pick<QueryKey<Options>[0], 'body' | 'headers' | 'path' | 'query'>,
>(
  queryKey: QueryKey<Options>,
  page: K
) => {
  const params = {
    ...queryKey[0],
  };
  if (page.body) {
    params.body = {
      ...(queryKey[0].body as any),
      ...(page.body as any),
    };
  }
  if (page.headers) {
    params.headers = {
      ...queryKey[0].headers,
      ...page.headers,
    };
  }
  if (page.path) {
    params.path = {
      ...(queryKey[0].path as any),
      ...(page.path as any),
    };
  }
  if (page.query) {
    params.query = {
      ...(queryKey[0].query as any),
      ...(page.query as any),
    };
  }
  return params as unknown as typeof page;
};

export const getAllTrainingBranchesInfiniteQueryKey = (
  options: Options<GetAllTrainingBranchesData>
): QueryKey<Options<GetAllTrainingBranchesData>> =>
  createQueryKey('getAllTrainingBranches', options, true);

/**
 * Get all training branches
 */
export const getAllTrainingBranchesInfiniteOptions = (
  options: Options<GetAllTrainingBranchesData>
) => {
  return infiniteQueryOptions<
    GetAllTrainingBranchesResponse,
    GetAllTrainingBranchesError,
    InfiniteData<GetAllTrainingBranchesResponse>,
    QueryKey<Options<GetAllTrainingBranchesData>>,
    | number
    | Pick<QueryKey<Options<GetAllTrainingBranchesData>>[0], 'body' | 'headers' | 'path' | 'query'>
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<GetAllTrainingBranchesData>>[0],
          'body' | 'headers' | 'path' | 'query'
        > =
          typeof pageParam === 'object'
            ? pageParam
            : {
                query: {
                  'pageable.page': pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getAllTrainingBranches({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: getAllTrainingBranchesInfiniteQueryKey(options),
    }
  );
};

export const createTrainingBranchQueryKey = (options: Options<CreateTrainingBranchData>) =>
  createQueryKey('createTrainingBranch', options);

/**
 * Create a new training branch
 */
export const createTrainingBranchOptions = (options: Options<CreateTrainingBranchData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await createTrainingBranch({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: createTrainingBranchQueryKey(options),
  });
};

/**
 * Create a new training branch
 */
export const createTrainingBranchMutation = (
  options?: Partial<Options<CreateTrainingBranchData>>
): UseMutationOptions<
  CreateTrainingBranchResponse,
  CreateTrainingBranchError,
  Options<CreateTrainingBranchData>
> => {
  const mutationOptions: UseMutationOptions<
    CreateTrainingBranchResponse,
    CreateTrainingBranchError,
    Options<CreateTrainingBranchData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await createTrainingBranch({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const checkStudentConflictQueryKey = (options: Options<CheckStudentConflictData>) =>
  createQueryKey('checkStudentConflict', options);

/**
 * Check if a student has enrollment conflicts
 */
export const checkStudentConflictOptions = (options: Options<CheckStudentConflictData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await checkStudentConflict({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: checkStudentConflictQueryKey(options),
  });
};

/**
 * Check if a student has enrollment conflicts
 */
export const checkStudentConflictMutation = (
  options?: Partial<Options<CheckStudentConflictData>>
): UseMutationOptions<
  CheckStudentConflictResponse,
  CheckStudentConflictError,
  Options<CheckStudentConflictData>
> => {
  const mutationOptions: UseMutationOptions<
    CheckStudentConflictResponse,
    CheckStudentConflictError,
    Options<CheckStudentConflictData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await checkStudentConflict({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const scheduleClassQueryKey = (options: Options<ScheduleClassData>) =>
  createQueryKey('scheduleClass', options);

/**
 * Schedule a new class instance
 */
export const scheduleClassOptions = (options: Options<ScheduleClassData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await scheduleClass({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: scheduleClassQueryKey(options),
  });
};

/**
 * Schedule a new class instance
 */
export const scheduleClassMutation = (
  options?: Partial<Options<ScheduleClassData>>
): UseMutationOptions<ScheduleClassResponse, ScheduleClassError, Options<ScheduleClassData>> => {
  const mutationOptions: UseMutationOptions<
    ScheduleClassResponse,
    ScheduleClassError,
    Options<ScheduleClassData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await scheduleClass({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const checkInstructorConflictQueryKey = (options: Options<CheckInstructorConflictData>) =>
  createQueryKey('checkInstructorConflict', options);

/**
 * Check if an instructor has scheduling conflicts
 */
export const checkInstructorConflictOptions = (options: Options<CheckInstructorConflictData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await checkInstructorConflict({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: checkInstructorConflictQueryKey(options),
  });
};

/**
 * Check if an instructor has scheduling conflicts
 */
export const checkInstructorConflictMutation = (
  options?: Partial<Options<CheckInstructorConflictData>>
): UseMutationOptions<
  CheckInstructorConflictResponse,
  CheckInstructorConflictError,
  Options<CheckInstructorConflictData>
> => {
  const mutationOptions: UseMutationOptions<
    CheckInstructorConflictResponse,
    CheckInstructorConflictError,
    Options<CheckInstructorConflictData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await checkInstructorConflict({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const blockInstructorTimeQueryKey = (options: Options<BlockInstructorTimeData>) =>
  createQueryKey('blockInstructorTime', options);

/**
 * Block instructor calendar for non-teaching time
 */
export const blockInstructorTimeOptions = (options: Options<BlockInstructorTimeData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await blockInstructorTime({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: blockInstructorTimeQueryKey(options),
  });
};

/**
 * Block instructor calendar for non-teaching time
 */
export const blockInstructorTimeMutation = (
  options?: Partial<Options<BlockInstructorTimeData>>
): UseMutationOptions<
  BlockInstructorTimeResponse,
  BlockInstructorTimeError,
  Options<BlockInstructorTimeData>
> => {
  const mutationOptions: UseMutationOptions<
    BlockInstructorTimeResponse,
    BlockInstructorTimeError,
    Options<BlockInstructorTimeData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await blockInstructorTime({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const listRulesQueryKey = (options: Options<ListRulesData>) =>
  createQueryKey('listRules', options);

/**
 * List rules
 * Returns paginated list of system rules with optional filters
 */
export const listRulesOptions = (options: Options<ListRulesData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await listRules({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: listRulesQueryKey(options),
  });
};

export const listRulesInfiniteQueryKey = (
  options: Options<ListRulesData>
): QueryKey<Options<ListRulesData>> => createQueryKey('listRules', options, true);

/**
 * List rules
 * Returns paginated list of system rules with optional filters
 */
export const listRulesInfiniteOptions = (options: Options<ListRulesData>) => {
  return infiniteQueryOptions<
    ListRulesResponse,
    ListRulesError,
    InfiniteData<ListRulesResponse>,
    QueryKey<Options<ListRulesData>>,
    number | Pick<QueryKey<Options<ListRulesData>>[0], 'body' | 'headers' | 'path' | 'query'>
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<ListRulesData>>[0],
          'body' | 'headers' | 'path' | 'query'
        > =
          typeof pageParam === 'object'
            ? pageParam
            : {
                query: {
                  'pageable.page': pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await listRules({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: listRulesInfiniteQueryKey(options),
    }
  );
};

export const createRuleQueryKey = (options: Options<CreateRuleData>) =>
  createQueryKey('createRule', options);

/**
 * Create rule
 */
export const createRuleOptions = (options: Options<CreateRuleData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await createRule({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: createRuleQueryKey(options),
  });
};

/**
 * Create rule
 */
export const createRuleMutation = (
  options?: Partial<Options<CreateRuleData>>
): UseMutationOptions<CreateRuleResponse, CreateRuleError, Options<CreateRuleData>> => {
  const mutationOptions: UseMutationOptions<
    CreateRuleResponse,
    CreateRuleError,
    Options<CreateRuleData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await createRule({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getAllStudentsQueryKey = (options: Options<GetAllStudentsData>) =>
  createQueryKey('getAllStudents', options);

/**
 * Get all students
 * Fetches a paginated list of students.
 */
export const getAllStudentsOptions = (options: Options<GetAllStudentsData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getAllStudents({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getAllStudentsQueryKey(options),
  });
};

export const getAllStudentsInfiniteQueryKey = (
  options: Options<GetAllStudentsData>
): QueryKey<Options<GetAllStudentsData>> => createQueryKey('getAllStudents', options, true);

/**
 * Get all students
 * Fetches a paginated list of students.
 */
export const getAllStudentsInfiniteOptions = (options: Options<GetAllStudentsData>) => {
  return infiniteQueryOptions<
    GetAllStudentsResponse,
    GetAllStudentsError,
    InfiniteData<GetAllStudentsResponse>,
    QueryKey<Options<GetAllStudentsData>>,
    number | Pick<QueryKey<Options<GetAllStudentsData>>[0], 'body' | 'headers' | 'path' | 'query'>
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<GetAllStudentsData>>[0],
          'body' | 'headers' | 'path' | 'query'
        > =
          typeof pageParam === 'object'
            ? pageParam
            : {
                query: {
                  'pageable.page': pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getAllStudents({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: getAllStudentsInfiniteQueryKey(options),
    }
  );
};

export const createStudentQueryKey = (options: Options<CreateStudentData>) =>
  createQueryKey('createStudent', options);

/**
 * Create a new student
 * Saves a new student record in the system.
 */
export const createStudentOptions = (options: Options<CreateStudentData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await createStudent({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: createStudentQueryKey(options),
  });
};

/**
 * Create a new student
 * Saves a new student record in the system.
 */
export const createStudentMutation = (
  options?: Partial<Options<CreateStudentData>>
): UseMutationOptions<CreateStudentResponse, CreateStudentError, Options<CreateStudentData>> => {
  const mutationOptions: UseMutationOptions<
    CreateStudentResponse,
    CreateStudentError,
    Options<CreateStudentData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await createStudent({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getAllAssessmentRubricsQueryKey = (options: Options<GetAllAssessmentRubricsData>) =>
  createQueryKey('getAllAssessmentRubrics', options);

/**
 * Get all assessment rubrics
 * Retrieves a paginated list of all assessment rubrics.
 */
export const getAllAssessmentRubricsOptions = (options: Options<GetAllAssessmentRubricsData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getAllAssessmentRubrics({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getAllAssessmentRubricsQueryKey(options),
  });
};

export const getAllAssessmentRubricsInfiniteQueryKey = (
  options: Options<GetAllAssessmentRubricsData>
): QueryKey<Options<GetAllAssessmentRubricsData>> =>
  createQueryKey('getAllAssessmentRubrics', options, true);

/**
 * Get all assessment rubrics
 * Retrieves a paginated list of all assessment rubrics.
 */
export const getAllAssessmentRubricsInfiniteOptions = (
  options: Options<GetAllAssessmentRubricsData>
) => {
  return infiniteQueryOptions<
    GetAllAssessmentRubricsResponse,
    GetAllAssessmentRubricsError,
    InfiniteData<GetAllAssessmentRubricsResponse>,
    QueryKey<Options<GetAllAssessmentRubricsData>>,
    | number
    | Pick<QueryKey<Options<GetAllAssessmentRubricsData>>[0], 'body' | 'headers' | 'path' | 'query'>
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<GetAllAssessmentRubricsData>>[0],
          'body' | 'headers' | 'path' | 'query'
        > =
          typeof pageParam === 'object'
            ? pageParam
            : {
                query: {
                  'pageable.page': pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getAllAssessmentRubrics({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: getAllAssessmentRubricsInfiniteQueryKey(options),
    }
  );
};

export const createAssessmentRubricQueryKey = (options: Options<CreateAssessmentRubricData>) =>
  createQueryKey('createAssessmentRubric', options);

/**
 * Create a new assessment rubric
 * Creates a new assessment rubric. The rubric can be associated with a specific course or be a general-purpose rubric.
 */
export const createAssessmentRubricOptions = (options: Options<CreateAssessmentRubricData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await createAssessmentRubric({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: createAssessmentRubricQueryKey(options),
  });
};

/**
 * Create a new assessment rubric
 * Creates a new assessment rubric. The rubric can be associated with a specific course or be a general-purpose rubric.
 */
export const createAssessmentRubricMutation = (
  options?: Partial<Options<CreateAssessmentRubricData>>
): UseMutationOptions<
  CreateAssessmentRubricResponse,
  CreateAssessmentRubricError,
  Options<CreateAssessmentRubricData>
> => {
  const mutationOptions: UseMutationOptions<
    CreateAssessmentRubricResponse,
    CreateAssessmentRubricError,
    Options<CreateAssessmentRubricData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await createAssessmentRubric({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getScoringLevelsByRubricQueryKey = (options: Options<GetScoringLevelsByRubricData>) =>
  createQueryKey('getScoringLevelsByRubric', options);

/**
 * Get all scoring levels for a rubric
 * Retrieves all custom scoring levels for the specified rubric, ordered by level order.
 */
export const getScoringLevelsByRubricOptions = (options: Options<GetScoringLevelsByRubricData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getScoringLevelsByRubric({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getScoringLevelsByRubricQueryKey(options),
  });
};

export const getScoringLevelsByRubricInfiniteQueryKey = (
  options: Options<GetScoringLevelsByRubricData>
): QueryKey<Options<GetScoringLevelsByRubricData>> =>
  createQueryKey('getScoringLevelsByRubric', options, true);

/**
 * Get all scoring levels for a rubric
 * Retrieves all custom scoring levels for the specified rubric, ordered by level order.
 */
export const getScoringLevelsByRubricInfiniteOptions = (
  options: Options<GetScoringLevelsByRubricData>
) => {
  return infiniteQueryOptions<
    GetScoringLevelsByRubricResponse,
    GetScoringLevelsByRubricError,
    InfiniteData<GetScoringLevelsByRubricResponse>,
    QueryKey<Options<GetScoringLevelsByRubricData>>,
    | number
    | Pick<
        QueryKey<Options<GetScoringLevelsByRubricData>>[0],
        'body' | 'headers' | 'path' | 'query'
      >
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<GetScoringLevelsByRubricData>>[0],
          'body' | 'headers' | 'path' | 'query'
        > =
          typeof pageParam === 'object'
            ? pageParam
            : {
                query: {
                  'pageable.page': pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getScoringLevelsByRubric({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: getScoringLevelsByRubricInfiniteQueryKey(options),
    }
  );
};

export const createRubricScoringLevelQueryKey = (options: Options<CreateRubricScoringLevelData>) =>
  createQueryKey('createRubricScoringLevel', options);

/**
 * Create a new scoring level for a rubric
 * Creates a new custom scoring level (e.g., Excellent, Good, Fair) within the specified rubric for matrix-based assessment.
 */
export const createRubricScoringLevelOptions = (options: Options<CreateRubricScoringLevelData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await createRubricScoringLevel({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: createRubricScoringLevelQueryKey(options),
  });
};

/**
 * Create a new scoring level for a rubric
 * Creates a new custom scoring level (e.g., Excellent, Good, Fair) within the specified rubric for matrix-based assessment.
 */
export const createRubricScoringLevelMutation = (
  options?: Partial<Options<CreateRubricScoringLevelData>>
): UseMutationOptions<
  CreateRubricScoringLevelResponse,
  CreateRubricScoringLevelError,
  Options<CreateRubricScoringLevelData>
> => {
  const mutationOptions: UseMutationOptions<
    CreateRubricScoringLevelResponse,
    CreateRubricScoringLevelError,
    Options<CreateRubricScoringLevelData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await createRubricScoringLevel({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const createRubricScoringLevelsBatchQueryKey = (
  options: Options<CreateRubricScoringLevelsBatchData>
) => createQueryKey('createRubricScoringLevelsBatch', options);

/**
 * Create multiple scoring levels for a rubric (batch)
 * Creates multiple custom scoring levels at once for efficient rubric setup.
 */
export const createRubricScoringLevelsBatchOptions = (
  options: Options<CreateRubricScoringLevelsBatchData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await createRubricScoringLevelsBatch({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: createRubricScoringLevelsBatchQueryKey(options),
  });
};

/**
 * Create multiple scoring levels for a rubric (batch)
 * Creates multiple custom scoring levels at once for efficient rubric setup.
 */
export const createRubricScoringLevelsBatchMutation = (
  options?: Partial<Options<CreateRubricScoringLevelsBatchData>>
): UseMutationOptions<
  CreateRubricScoringLevelsBatchResponse,
  CreateRubricScoringLevelsBatchError,
  Options<CreateRubricScoringLevelsBatchData>
> => {
  const mutationOptions: UseMutationOptions<
    CreateRubricScoringLevelsBatchResponse,
    CreateRubricScoringLevelsBatchError,
    Options<CreateRubricScoringLevelsBatchData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await createRubricScoringLevelsBatch({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const recalculateScoresQueryKey = (options: Options<RecalculateScoresData>) =>
  createQueryKey('recalculateScores', options);

/**
 * Recalculate rubric scores
 * Recalculates maximum and minimum passing scores based on current matrix configuration and weights.
 */
export const recalculateScoresOptions = (options: Options<RecalculateScoresData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await recalculateScores({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: recalculateScoresQueryKey(options),
  });
};

/**
 * Recalculate rubric scores
 * Recalculates maximum and minimum passing scores based on current matrix configuration and weights.
 */
export const recalculateScoresMutation = (
  options?: Partial<Options<RecalculateScoresData>>
): UseMutationOptions<
  RecalculateScoresResponse,
  RecalculateScoresError,
  Options<RecalculateScoresData>
> => {
  const mutationOptions: UseMutationOptions<
    RecalculateScoresResponse,
    RecalculateScoresError,
    Options<RecalculateScoresData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await recalculateScores({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getRubricCriteriaQueryKey = (options: Options<GetRubricCriteriaData>) =>
  createQueryKey('getRubricCriteria', options);

/**
 * Get all criteria for a rubric
 * Retrieves a paginated list of all criteria for a specific assessment rubric.
 */
export const getRubricCriteriaOptions = (options: Options<GetRubricCriteriaData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getRubricCriteria({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getRubricCriteriaQueryKey(options),
  });
};

export const getRubricCriteriaInfiniteQueryKey = (
  options: Options<GetRubricCriteriaData>
): QueryKey<Options<GetRubricCriteriaData>> => createQueryKey('getRubricCriteria', options, true);

/**
 * Get all criteria for a rubric
 * Retrieves a paginated list of all criteria for a specific assessment rubric.
 */
export const getRubricCriteriaInfiniteOptions = (options: Options<GetRubricCriteriaData>) => {
  return infiniteQueryOptions<
    GetRubricCriteriaResponse,
    GetRubricCriteriaError,
    InfiniteData<GetRubricCriteriaResponse>,
    QueryKey<Options<GetRubricCriteriaData>>,
    | number
    | Pick<QueryKey<Options<GetRubricCriteriaData>>[0], 'body' | 'headers' | 'path' | 'query'>
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<GetRubricCriteriaData>>[0],
          'body' | 'headers' | 'path' | 'query'
        > =
          typeof pageParam === 'object'
            ? pageParam
            : {
                query: {
                  'pageable.page': pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getRubricCriteria({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: getRubricCriteriaInfiniteQueryKey(options),
    }
  );
};

export const addRubricCriterionQueryKey = (options: Options<AddRubricCriterionData>) =>
  createQueryKey('addRubricCriterion', options);

/**
 * Add a criterion to a rubric
 * Adds a new criterion to an existing assessment rubric. If scoring levels exist, the matrix will be auto-generated.
 */
export const addRubricCriterionOptions = (options: Options<AddRubricCriterionData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await addRubricCriterion({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: addRubricCriterionQueryKey(options),
  });
};

/**
 * Add a criterion to a rubric
 * Adds a new criterion to an existing assessment rubric. If scoring levels exist, the matrix will be auto-generated.
 */
export const addRubricCriterionMutation = (
  options?: Partial<Options<AddRubricCriterionData>>
): UseMutationOptions<
  AddRubricCriterionResponse,
  AddRubricCriterionError,
  Options<AddRubricCriterionData>
> => {
  const mutationOptions: UseMutationOptions<
    AddRubricCriterionResponse,
    AddRubricCriterionError,
    Options<AddRubricCriterionData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await addRubricCriterion({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getRubricScoringQueryKey = (options: Options<GetRubricScoringData>) =>
  createQueryKey('getRubricScoring', options);

/**
 * Get all scoring levels for a criterion
 * Retrieves a paginated list of all scoring levels for a specific rubric criterion.
 */
export const getRubricScoringOptions = (options: Options<GetRubricScoringData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getRubricScoring({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getRubricScoringQueryKey(options),
  });
};

export const getRubricScoringInfiniteQueryKey = (
  options: Options<GetRubricScoringData>
): QueryKey<Options<GetRubricScoringData>> => createQueryKey('getRubricScoring', options, true);

/**
 * Get all scoring levels for a criterion
 * Retrieves a paginated list of all scoring levels for a specific rubric criterion.
 */
export const getRubricScoringInfiniteOptions = (options: Options<GetRubricScoringData>) => {
  return infiniteQueryOptions<
    GetRubricScoringResponse,
    GetRubricScoringError,
    InfiniteData<GetRubricScoringResponse>,
    QueryKey<Options<GetRubricScoringData>>,
    number | Pick<QueryKey<Options<GetRubricScoringData>>[0], 'body' | 'headers' | 'path' | 'query'>
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<GetRubricScoringData>>[0],
          'body' | 'headers' | 'path' | 'query'
        > =
          typeof pageParam === 'object'
            ? pageParam
            : {
                query: {
                  'pageable.page': pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getRubricScoring({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: getRubricScoringInfiniteQueryKey(options),
    }
  );
};

export const addRubricScoringQueryKey = (options: Options<AddRubricScoringData>) =>
  createQueryKey('addRubricScoring', options);

/**
 * Add a scoring level to a criterion
 * Adds a new scoring level to an existing rubric criterion.
 */
export const addRubricScoringOptions = (options: Options<AddRubricScoringData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await addRubricScoring({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: addRubricScoringQueryKey(options),
  });
};

/**
 * Add a scoring level to a criterion
 * Adds a new scoring level to an existing rubric criterion.
 */
export const addRubricScoringMutation = (
  options?: Partial<Options<AddRubricScoringData>>
): UseMutationOptions<
  AddRubricScoringResponse,
  AddRubricScoringError,
  Options<AddRubricScoringData>
> => {
  const mutationOptions: UseMutationOptions<
    AddRubricScoringResponse,
    AddRubricScoringError,
    Options<AddRubricScoringData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await addRubricScoring({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getAllQuizzesQueryKey = (options: Options<GetAllQuizzesData>) =>
  createQueryKey('getAllQuizzes', options);

/**
 * Get all quizzes
 * Retrieves paginated list of all quizzes with filtering support.
 */
export const getAllQuizzesOptions = (options: Options<GetAllQuizzesData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getAllQuizzes({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getAllQuizzesQueryKey(options),
  });
};

export const getAllQuizzesInfiniteQueryKey = (
  options: Options<GetAllQuizzesData>
): QueryKey<Options<GetAllQuizzesData>> => createQueryKey('getAllQuizzes', options, true);

/**
 * Get all quizzes
 * Retrieves paginated list of all quizzes with filtering support.
 */
export const getAllQuizzesInfiniteOptions = (options: Options<GetAllQuizzesData>) => {
  return infiniteQueryOptions<
    GetAllQuizzesResponse,
    GetAllQuizzesError,
    InfiniteData<GetAllQuizzesResponse>,
    QueryKey<Options<GetAllQuizzesData>>,
    number | Pick<QueryKey<Options<GetAllQuizzesData>>[0], 'body' | 'headers' | 'path' | 'query'>
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<GetAllQuizzesData>>[0],
          'body' | 'headers' | 'path' | 'query'
        > =
          typeof pageParam === 'object'
            ? pageParam
            : {
                query: {
                  'pageable.page': pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getAllQuizzes({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: getAllQuizzesInfiniteQueryKey(options),
    }
  );
};

export const createQuizQueryKey = (options: Options<CreateQuizData>) =>
  createQueryKey('createQuiz', options);

/**
 * Create a new quiz
 * Creates a new quiz with default DRAFT status and inactive state.
 */
export const createQuizOptions = (options: Options<CreateQuizData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await createQuiz({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: createQuizQueryKey(options),
  });
};

/**
 * Create a new quiz
 * Creates a new quiz with default DRAFT status and inactive state.
 */
export const createQuizMutation = (
  options?: Partial<Options<CreateQuizData>>
): UseMutationOptions<CreateQuizResponse, CreateQuizError, Options<CreateQuizData>> => {
  const mutationOptions: UseMutationOptions<
    CreateQuizResponse,
    CreateQuizError,
    Options<CreateQuizData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await createQuiz({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getQuizQuestionsQueryKey = (options: Options<GetQuizQuestionsData>) =>
  createQueryKey('getQuizQuestions', options);

/**
 * Get quiz questions
 * Retrieves all questions for a quiz in display order with computed properties.
 */
export const getQuizQuestionsOptions = (options: Options<GetQuizQuestionsData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getQuizQuestions({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getQuizQuestionsQueryKey(options),
  });
};

export const addQuizQuestionQueryKey = (options: Options<AddQuizQuestionData>) =>
  createQueryKey('addQuizQuestion', options);

/**
 * Add question to quiz
 * Creates a new question for the specified quiz with automatic ordering.
 */
export const addQuizQuestionOptions = (options: Options<AddQuizQuestionData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await addQuizQuestion({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: addQuizQuestionQueryKey(options),
  });
};

/**
 * Add question to quiz
 * Creates a new question for the specified quiz with automatic ordering.
 */
export const addQuizQuestionMutation = (
  options?: Partial<Options<AddQuizQuestionData>>
): UseMutationOptions<
  AddQuizQuestionResponse,
  AddQuizQuestionError,
  Options<AddQuizQuestionData>
> => {
  const mutationOptions: UseMutationOptions<
    AddQuizQuestionResponse,
    AddQuizQuestionError,
    Options<AddQuizQuestionData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await addQuizQuestion({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getQuestionOptionsQueryKey = (options: Options<GetQuestionOptionsData>) =>
  createQueryKey('getQuestionOptions', options);

/**
 * Get question options
 * Retrieves all options for a specific question.
 */
export const getQuestionOptionsOptions = (options: Options<GetQuestionOptionsData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getQuestionOptions({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getQuestionOptionsQueryKey(options),
  });
};

export const getQuestionOptionsInfiniteQueryKey = (
  options: Options<GetQuestionOptionsData>
): QueryKey<Options<GetQuestionOptionsData>> => createQueryKey('getQuestionOptions', options, true);

/**
 * Get question options
 * Retrieves all options for a specific question.
 */
export const getQuestionOptionsInfiniteOptions = (options: Options<GetQuestionOptionsData>) => {
  return infiniteQueryOptions<
    GetQuestionOptionsResponse,
    GetQuestionOptionsError,
    InfiniteData<GetQuestionOptionsResponse>,
    QueryKey<Options<GetQuestionOptionsData>>,
    | number
    | Pick<QueryKey<Options<GetQuestionOptionsData>>[0], 'body' | 'headers' | 'path' | 'query'>
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<GetQuestionOptionsData>>[0],
          'body' | 'headers' | 'path' | 'query'
        > =
          typeof pageParam === 'object'
            ? pageParam
            : {
                query: {
                  'pageable.page': pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getQuestionOptions({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: getQuestionOptionsInfiniteQueryKey(options),
    }
  );
};

export const addQuestionOptionQueryKey = (options: Options<AddQuestionOptionData>) =>
  createQueryKey('addQuestionOption', options);

/**
 * Add option to question
 * Creates a new option for a multiple choice or true/false question.
 */
export const addQuestionOptionOptions = (options: Options<AddQuestionOptionData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await addQuestionOption({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: addQuestionOptionQueryKey(options),
  });
};

/**
 * Add option to question
 * Creates a new option for a multiple choice or true/false question.
 */
export const addQuestionOptionMutation = (
  options?: Partial<Options<AddQuestionOptionData>>
): UseMutationOptions<
  AddQuestionOptionResponse,
  AddQuestionOptionError,
  Options<AddQuestionOptionData>
> => {
  const mutationOptions: UseMutationOptions<
    AddQuestionOptionResponse,
    AddQuestionOptionError,
    Options<AddQuestionOptionData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await addQuestionOption({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const reorderQuizQuestionsQueryKey = (options: Options<ReorderQuizQuestionsData>) =>
  createQueryKey('reorderQuizQuestions', options);

/**
 * Reorder quiz questions
 * Updates the display order of questions within a quiz.
 */
export const reorderQuizQuestionsOptions = (options: Options<ReorderQuizQuestionsData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await reorderQuizQuestions({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: reorderQuizQuestionsQueryKey(options),
  });
};

/**
 * Reorder quiz questions
 * Updates the display order of questions within a quiz.
 */
export const reorderQuizQuestionsMutation = (
  options?: Partial<Options<ReorderQuizQuestionsData>>
): UseMutationOptions<
  ReorderQuizQuestionsResponse,
  ReorderQuizQuestionsError,
  Options<ReorderQuizQuestionsData>
> => {
  const mutationOptions: UseMutationOptions<
    ReorderQuizQuestionsResponse,
    ReorderQuizQuestionsError,
    Options<ReorderQuizQuestionsData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await reorderQuizQuestions({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getAllTrainingProgramsQueryKey = (options: Options<GetAllTrainingProgramsData>) =>
  createQueryKey('getAllTrainingPrograms', options);

/**
 * Get all programs
 * Retrieves paginated list of all training programs with filtering support.
 */
export const getAllTrainingProgramsOptions = (options: Options<GetAllTrainingProgramsData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getAllTrainingPrograms({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getAllTrainingProgramsQueryKey(options),
  });
};

export const getAllTrainingProgramsInfiniteQueryKey = (
  options: Options<GetAllTrainingProgramsData>
): QueryKey<Options<GetAllTrainingProgramsData>> =>
  createQueryKey('getAllTrainingPrograms', options, true);

/**
 * Get all programs
 * Retrieves paginated list of all training programs with filtering support.
 */
export const getAllTrainingProgramsInfiniteOptions = (
  options: Options<GetAllTrainingProgramsData>
) => {
  return infiniteQueryOptions<
    GetAllTrainingProgramsResponse,
    GetAllTrainingProgramsError,
    InfiniteData<GetAllTrainingProgramsResponse>,
    QueryKey<Options<GetAllTrainingProgramsData>>,
    | number
    | Pick<QueryKey<Options<GetAllTrainingProgramsData>>[0], 'body' | 'headers' | 'path' | 'query'>
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<GetAllTrainingProgramsData>>[0],
          'body' | 'headers' | 'path' | 'query'
        > =
          typeof pageParam === 'object'
            ? pageParam
            : {
                query: {
                  'pageable.page': pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getAllTrainingPrograms({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: getAllTrainingProgramsInfiniteQueryKey(options),
    }
  );
};

export const createTrainingProgramQueryKey = (options: Options<CreateTrainingProgramData>) =>
  createQueryKey('createTrainingProgram', options);

/**
 * Create a new training program
 * Creates a new training program with default DRAFT status and inactive state.
 */
export const createTrainingProgramOptions = (options: Options<CreateTrainingProgramData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await createTrainingProgram({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: createTrainingProgramQueryKey(options),
  });
};

/**
 * Create a new training program
 * Creates a new training program with default DRAFT status and inactive state.
 */
export const createTrainingProgramMutation = (
  options?: Partial<Options<CreateTrainingProgramData>>
): UseMutationOptions<
  CreateTrainingProgramResponse,
  CreateTrainingProgramError,
  Options<CreateTrainingProgramData>
> => {
  const mutationOptions: UseMutationOptions<
    CreateTrainingProgramResponse,
    CreateTrainingProgramError,
    Options<CreateTrainingProgramData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await createTrainingProgram({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const publishProgramQueryKey = (options: Options<PublishProgramData>) =>
  createQueryKey('publishProgram', options);

/**
 * Publish training program
 * Publishes a program making it available for enrollment.
 */
export const publishProgramOptions = (options: Options<PublishProgramData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await publishProgram({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: publishProgramQueryKey(options),
  });
};

/**
 * Publish training program
 * Publishes a program making it available for enrollment.
 */
export const publishProgramMutation = (
  options?: Partial<Options<PublishProgramData>>
): UseMutationOptions<PublishProgramResponse, PublishProgramError, Options<PublishProgramData>> => {
  const mutationOptions: UseMutationOptions<
    PublishProgramResponse,
    PublishProgramError,
    Options<PublishProgramData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await publishProgram({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getProgramRequirementsQueryKey = (options: Options<GetProgramRequirementsData>) =>
  createQueryKey('getProgramRequirements', options);

/**
 * Get program requirements
 * Retrieves all requirements for a specific program.
 */
export const getProgramRequirementsOptions = (options: Options<GetProgramRequirementsData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getProgramRequirements({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getProgramRequirementsQueryKey(options),
  });
};

export const getProgramRequirementsInfiniteQueryKey = (
  options: Options<GetProgramRequirementsData>
): QueryKey<Options<GetProgramRequirementsData>> =>
  createQueryKey('getProgramRequirements', options, true);

/**
 * Get program requirements
 * Retrieves all requirements for a specific program.
 */
export const getProgramRequirementsInfiniteOptions = (
  options: Options<GetProgramRequirementsData>
) => {
  return infiniteQueryOptions<
    GetProgramRequirementsResponse,
    GetProgramRequirementsError,
    InfiniteData<GetProgramRequirementsResponse>,
    QueryKey<Options<GetProgramRequirementsData>>,
    | number
    | Pick<QueryKey<Options<GetProgramRequirementsData>>[0], 'body' | 'headers' | 'path' | 'query'>
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<GetProgramRequirementsData>>[0],
          'body' | 'headers' | 'path' | 'query'
        > =
          typeof pageParam === 'object'
            ? pageParam
            : {
                query: {
                  'pageable.page': pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getProgramRequirements({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: getProgramRequirementsInfiniteQueryKey(options),
    }
  );
};

export const addProgramRequirementQueryKey = (options: Options<AddProgramRequirementData>) =>
  createQueryKey('addProgramRequirement', options);

/**
 * Add requirement to program
 * Adds a new requirement or prerequisite to a program.
 */
export const addProgramRequirementOptions = (options: Options<AddProgramRequirementData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await addProgramRequirement({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: addProgramRequirementQueryKey(options),
  });
};

/**
 * Add requirement to program
 * Adds a new requirement or prerequisite to a program.
 */
export const addProgramRequirementMutation = (
  options?: Partial<Options<AddProgramRequirementData>>
): UseMutationOptions<
  AddProgramRequirementResponse,
  AddProgramRequirementError,
  Options<AddProgramRequirementData>
> => {
  const mutationOptions: UseMutationOptions<
    AddProgramRequirementResponse,
    AddProgramRequirementError,
    Options<AddProgramRequirementData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await addProgramRequirement({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getProgramCoursesQueryKey = (options: Options<GetProgramCoursesData>) =>
  createQueryKey('getProgramCourses', options);

/**
 * Get program courses
 * Retrieves all courses in a program in sequence order with requirement status.
 */
export const getProgramCoursesOptions = (options: Options<GetProgramCoursesData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getProgramCourses({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getProgramCoursesQueryKey(options),
  });
};

export const addProgramCourseQueryKey = (options: Options<AddProgramCourseData>) =>
  createQueryKey('addProgramCourse', options);

/**
 * Add course to program
 * Associates a course with a program, setting sequence and requirement status.
 */
export const addProgramCourseOptions = (options: Options<AddProgramCourseData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await addProgramCourse({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: addProgramCourseQueryKey(options),
  });
};

/**
 * Add course to program
 * Associates a course with a program, setting sequence and requirement status.
 */
export const addProgramCourseMutation = (
  options?: Partial<Options<AddProgramCourseData>>
): UseMutationOptions<
  AddProgramCourseResponse,
  AddProgramCourseError,
  Options<AddProgramCourseData>
> => {
  const mutationOptions: UseMutationOptions<
    AddProgramCourseResponse,
    AddProgramCourseError,
    Options<AddProgramCourseData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await addProgramCourse({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getAllOrganisationsQueryKey = (options: Options<GetAllOrganisationsData>) =>
  createQueryKey('getAllOrganisations', options);

/**
 * Get all organisations
 */
export const getAllOrganisationsOptions = (options: Options<GetAllOrganisationsData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getAllOrganisations({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getAllOrganisationsQueryKey(options),
  });
};

export const getAllOrganisationsInfiniteQueryKey = (
  options: Options<GetAllOrganisationsData>
): QueryKey<Options<GetAllOrganisationsData>> =>
  createQueryKey('getAllOrganisations', options, true);

/**
 * Get all organisations
 */
export const getAllOrganisationsInfiniteOptions = (options: Options<GetAllOrganisationsData>) => {
  return infiniteQueryOptions<
    GetAllOrganisationsResponse,
    GetAllOrganisationsError,
    InfiniteData<GetAllOrganisationsResponse>,
    QueryKey<Options<GetAllOrganisationsData>>,
    | number
    | Pick<QueryKey<Options<GetAllOrganisationsData>>[0], 'body' | 'headers' | 'path' | 'query'>
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<GetAllOrganisationsData>>[0],
          'body' | 'headers' | 'path' | 'query'
        > =
          typeof pageParam === 'object'
            ? pageParam
            : {
                query: {
                  'pageable.page': pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getAllOrganisations({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: getAllOrganisationsInfiniteQueryKey(options),
    }
  );
};

export const createOrganisationQueryKey = (options: Options<CreateOrganisationData>) =>
  createQueryKey('createOrganisation', options);

/**
 * Create a new organisation
 */
export const createOrganisationOptions = (options: Options<CreateOrganisationData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await createOrganisation({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: createOrganisationQueryKey(options),
  });
};

/**
 * Create a new organisation
 */
export const createOrganisationMutation = (
  options?: Partial<Options<CreateOrganisationData>>
): UseMutationOptions<
  CreateOrganisationResponse,
  CreateOrganisationError,
  Options<CreateOrganisationData>
> => {
  const mutationOptions: UseMutationOptions<
    CreateOrganisationResponse,
    CreateOrganisationError,
    Options<CreateOrganisationData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await createOrganisation({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getTrainingBranchesByOrganisationQueryKey = (
  options: Options<GetTrainingBranchesByOrganisationData>
) => createQueryKey('getTrainingBranchesByOrganisation', options);

/**
 * Get training branches by organisation UUID
 */
export const getTrainingBranchesByOrganisationOptions = (
  options: Options<GetTrainingBranchesByOrganisationData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getTrainingBranchesByOrganisation({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getTrainingBranchesByOrganisationQueryKey(options),
  });
};

export const getTrainingBranchesByOrganisationInfiniteQueryKey = (
  options: Options<GetTrainingBranchesByOrganisationData>
): QueryKey<Options<GetTrainingBranchesByOrganisationData>> =>
  createQueryKey('getTrainingBranchesByOrganisation', options, true);

/**
 * Get training branches by organisation UUID
 */
export const getTrainingBranchesByOrganisationInfiniteOptions = (
  options: Options<GetTrainingBranchesByOrganisationData>
) => {
  return infiniteQueryOptions<
    GetTrainingBranchesByOrganisationResponse,
    GetTrainingBranchesByOrganisationError,
    InfiniteData<GetTrainingBranchesByOrganisationResponse>,
    QueryKey<Options<GetTrainingBranchesByOrganisationData>>,
    | number
    | Pick<
        QueryKey<Options<GetTrainingBranchesByOrganisationData>>[0],
        'body' | 'headers' | 'path' | 'query'
      >
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<GetTrainingBranchesByOrganisationData>>[0],
          'body' | 'headers' | 'path' | 'query'
        > =
          typeof pageParam === 'object'
            ? pageParam
            : {
                query: {
                  'pageable.page': pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getTrainingBranchesByOrganisation({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: getTrainingBranchesByOrganisationInfiniteQueryKey(options),
    }
  );
};

export const createTrainingBranch1QueryKey = (options: Options<CreateTrainingBranch1Data>) =>
  createQueryKey('createTrainingBranch1', options);

/**
 * Create a new training branch within organization
 */
export const createTrainingBranch1Options = (options: Options<CreateTrainingBranch1Data>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await createTrainingBranch1({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: createTrainingBranch1QueryKey(options),
  });
};

/**
 * Create a new training branch within organization
 */
export const createTrainingBranch1Mutation = (
  options?: Partial<Options<CreateTrainingBranch1Data>>
): UseMutationOptions<
  CreateTrainingBranch1Response,
  CreateTrainingBranch1Error,
  Options<CreateTrainingBranch1Data>
> => {
  const mutationOptions: UseMutationOptions<
    CreateTrainingBranch1Response,
    CreateTrainingBranch1Error,
    Options<CreateTrainingBranch1Data>
  > = {
    mutationFn: async localOptions => {
      const { data } = await createTrainingBranch1({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Remove user from training branch
 * Removes a user from a training branch. The user remains in the parent organization but loses branch-specific assignment.
 */
export const removeUserFromBranchMutation = (
  options?: Partial<Options<RemoveUserFromBranchData>>
): UseMutationOptions<
  RemoveUserFromBranchResponse,
  RemoveUserFromBranchError,
  Options<RemoveUserFromBranchData>
> => {
  const mutationOptions: UseMutationOptions<
    RemoveUserFromBranchResponse,
    RemoveUserFromBranchError,
    Options<RemoveUserFromBranchData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await removeUserFromBranch({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const assignUserToBranchQueryKey = (options: Options<AssignUserToBranchData>) =>
  createQueryKey('assignUserToBranch', options);

/**
 * Assign user to training branch
 * Assigns a user to a specific training branch with a defined role. If the user is not already in the parent organization, creates organization membership first. If the user is already in the organization, updates their branch assignment.
 */
export const assignUserToBranchOptions = (options: Options<AssignUserToBranchData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await assignUserToBranch({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: assignUserToBranchQueryKey(options),
  });
};

/**
 * Assign user to training branch
 * Assigns a user to a specific training branch with a defined role. If the user is not already in the parent organization, creates organization membership first. If the user is already in the organization, updates their branch assignment.
 */
export const assignUserToBranchMutation = (
  options?: Partial<Options<AssignUserToBranchData>>
): UseMutationOptions<
  AssignUserToBranchResponse,
  AssignUserToBranchError,
  Options<AssignUserToBranchData>
> => {
  const mutationOptions: UseMutationOptions<
    AssignUserToBranchResponse,
    AssignUserToBranchError,
    Options<AssignUserToBranchData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await assignUserToBranch({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getAllInstructorsQueryKey = (options: Options<GetAllInstructorsData>) =>
  createQueryKey('getAllInstructors', options);

/**
 * Get all instructors
 * Fetches a paginated list of instructors.
 */
export const getAllInstructorsOptions = (options: Options<GetAllInstructorsData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getAllInstructors({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getAllInstructorsQueryKey(options),
  });
};

export const getAllInstructorsInfiniteQueryKey = (
  options: Options<GetAllInstructorsData>
): QueryKey<Options<GetAllInstructorsData>> => createQueryKey('getAllInstructors', options, true);

/**
 * Get all instructors
 * Fetches a paginated list of instructors.
 */
export const getAllInstructorsInfiniteOptions = (options: Options<GetAllInstructorsData>) => {
  return infiniteQueryOptions<
    GetAllInstructorsResponse,
    GetAllInstructorsError,
    InfiniteData<GetAllInstructorsResponse>,
    QueryKey<Options<GetAllInstructorsData>>,
    | number
    | Pick<QueryKey<Options<GetAllInstructorsData>>[0], 'body' | 'headers' | 'path' | 'query'>
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<GetAllInstructorsData>>[0],
          'body' | 'headers' | 'path' | 'query'
        > =
          typeof pageParam === 'object'
            ? pageParam
            : {
                query: {
                  'pageable.page': pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getAllInstructors({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: getAllInstructorsInfiniteQueryKey(options),
    }
  );
};

export const createInstructorQueryKey = (options: Options<CreateInstructorData>) =>
  createQueryKey('createInstructor', options);

/**
 * Create a new instructor
 * Saves a new instructor record in the system.
 */
export const createInstructorOptions = (options: Options<CreateInstructorData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await createInstructor({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: createInstructorQueryKey(options),
  });
};

/**
 * Create a new instructor
 * Saves a new instructor record in the system.
 */
export const createInstructorMutation = (
  options?: Partial<Options<CreateInstructorData>>
): UseMutationOptions<
  CreateInstructorResponse,
  CreateInstructorError,
  Options<CreateInstructorData>
> => {
  const mutationOptions: UseMutationOptions<
    CreateInstructorResponse,
    CreateInstructorError,
    Options<CreateInstructorData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await createInstructor({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getInstructorSkillsQueryKey = (options: Options<GetInstructorSkillsData>) =>
  createQueryKey('getInstructorSkills', options);

/**
 * Get instructor skills
 * Retrieves all skills for a specific instructor
 */
export const getInstructorSkillsOptions = (options: Options<GetInstructorSkillsData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getInstructorSkills({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getInstructorSkillsQueryKey(options),
  });
};

export const getInstructorSkillsInfiniteQueryKey = (
  options: Options<GetInstructorSkillsData>
): QueryKey<Options<GetInstructorSkillsData>> =>
  createQueryKey('getInstructorSkills', options, true);

/**
 * Get instructor skills
 * Retrieves all skills for a specific instructor
 */
export const getInstructorSkillsInfiniteOptions = (options: Options<GetInstructorSkillsData>) => {
  return infiniteQueryOptions<
    GetInstructorSkillsResponse,
    GetInstructorSkillsError,
    InfiniteData<GetInstructorSkillsResponse>,
    QueryKey<Options<GetInstructorSkillsData>>,
    | number
    | Pick<QueryKey<Options<GetInstructorSkillsData>>[0], 'body' | 'headers' | 'path' | 'query'>
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<GetInstructorSkillsData>>[0],
          'body' | 'headers' | 'path' | 'query'
        > =
          typeof pageParam === 'object'
            ? pageParam
            : {
                query: {
                  'pageable.page': pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getInstructorSkills({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: getInstructorSkillsInfiniteQueryKey(options),
    }
  );
};

export const addInstructorSkillQueryKey = (options: Options<AddInstructorSkillData>) =>
  createQueryKey('addInstructorSkill', options);

/**
 * Add skill to instructor
 * Adds a skill to an instructor
 */
export const addInstructorSkillOptions = (options: Options<AddInstructorSkillData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await addInstructorSkill({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: addInstructorSkillQueryKey(options),
  });
};

/**
 * Add skill to instructor
 * Adds a skill to an instructor
 */
export const addInstructorSkillMutation = (
  options?: Partial<Options<AddInstructorSkillData>>
): UseMutationOptions<
  AddInstructorSkillResponse,
  AddInstructorSkillError,
  Options<AddInstructorSkillData>
> => {
  const mutationOptions: UseMutationOptions<
    AddInstructorSkillResponse,
    AddInstructorSkillError,
    Options<AddInstructorSkillData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await addInstructorSkill({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getInstructorReviewsQueryKey = (options: Options<GetInstructorReviewsData>) =>
  createQueryKey('getInstructorReviews', options);

/**
 * Get reviews for an instructor
 * Returns all reviews left for the specified instructor.
 */
export const getInstructorReviewsOptions = (options: Options<GetInstructorReviewsData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getInstructorReviews({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getInstructorReviewsQueryKey(options),
  });
};

export const submitInstructorReviewQueryKey = (options: Options<SubmitInstructorReviewData>) =>
  createQueryKey('submitInstructorReview', options);

/**
 * Submit a review for an instructor
 * Allows a student to leave a review for an instructor, scoped to a specific enrollment.
 *
 * Frontend clients should:
 * - Use the student's enrollment UUID and the instructor UUID for the class they attended.
 * - Enforce that each enrollment can create at most one review for a given instructor.
 *
 */
export const submitInstructorReviewOptions = (options: Options<SubmitInstructorReviewData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await submitInstructorReview({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: submitInstructorReviewQueryKey(options),
  });
};

/**
 * Submit a review for an instructor
 * Allows a student to leave a review for an instructor, scoped to a specific enrollment.
 *
 * Frontend clients should:
 * - Use the student's enrollment UUID and the instructor UUID for the class they attended.
 * - Enforce that each enrollment can create at most one review for a given instructor.
 *
 */
export const submitInstructorReviewMutation = (
  options?: Partial<Options<SubmitInstructorReviewData>>
): UseMutationOptions<
  SubmitInstructorReviewResponse,
  SubmitInstructorReviewError,
  Options<SubmitInstructorReviewData>
> => {
  const mutationOptions: UseMutationOptions<
    SubmitInstructorReviewResponse,
    SubmitInstructorReviewError,
    Options<SubmitInstructorReviewData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await submitInstructorReview({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getInstructorMembershipsQueryKey = (options: Options<GetInstructorMembershipsData>) =>
  createQueryKey('getInstructorMemberships', options);

/**
 * Get instructor memberships
 * Retrieves all membership records for a specific instructor
 */
export const getInstructorMembershipsOptions = (options: Options<GetInstructorMembershipsData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getInstructorMemberships({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getInstructorMembershipsQueryKey(options),
  });
};

export const getInstructorMembershipsInfiniteQueryKey = (
  options: Options<GetInstructorMembershipsData>
): QueryKey<Options<GetInstructorMembershipsData>> =>
  createQueryKey('getInstructorMemberships', options, true);

/**
 * Get instructor memberships
 * Retrieves all membership records for a specific instructor
 */
export const getInstructorMembershipsInfiniteOptions = (
  options: Options<GetInstructorMembershipsData>
) => {
  return infiniteQueryOptions<
    GetInstructorMembershipsResponse,
    GetInstructorMembershipsError,
    InfiniteData<GetInstructorMembershipsResponse>,
    QueryKey<Options<GetInstructorMembershipsData>>,
    | number
    | Pick<
        QueryKey<Options<GetInstructorMembershipsData>>[0],
        'body' | 'headers' | 'path' | 'query'
      >
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<GetInstructorMembershipsData>>[0],
          'body' | 'headers' | 'path' | 'query'
        > =
          typeof pageParam === 'object'
            ? pageParam
            : {
                query: {
                  'pageable.page': pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getInstructorMemberships({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: getInstructorMembershipsInfiniteQueryKey(options),
    }
  );
};

export const addInstructorMembershipQueryKey = (options: Options<AddInstructorMembershipData>) =>
  createQueryKey('addInstructorMembership', options);

/**
 * Add membership to instructor
 * Adds professional membership to an instructor
 */
export const addInstructorMembershipOptions = (options: Options<AddInstructorMembershipData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await addInstructorMembership({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: addInstructorMembershipQueryKey(options),
  });
};

/**
 * Add membership to instructor
 * Adds professional membership to an instructor
 */
export const addInstructorMembershipMutation = (
  options?: Partial<Options<AddInstructorMembershipData>>
): UseMutationOptions<
  AddInstructorMembershipResponse,
  AddInstructorMembershipError,
  Options<AddInstructorMembershipData>
> => {
  const mutationOptions: UseMutationOptions<
    AddInstructorMembershipResponse,
    AddInstructorMembershipError,
    Options<AddInstructorMembershipData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await addInstructorMembership({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getInstructorExperienceQueryKey = (options: Options<GetInstructorExperienceData>) =>
  createQueryKey('getInstructorExperience', options);

/**
 * Get instructor experience
 * Retrieves all experience records for a specific instructor
 */
export const getInstructorExperienceOptions = (options: Options<GetInstructorExperienceData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getInstructorExperience({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getInstructorExperienceQueryKey(options),
  });
};

export const getInstructorExperienceInfiniteQueryKey = (
  options: Options<GetInstructorExperienceData>
): QueryKey<Options<GetInstructorExperienceData>> =>
  createQueryKey('getInstructorExperience', options, true);

/**
 * Get instructor experience
 * Retrieves all experience records for a specific instructor
 */
export const getInstructorExperienceInfiniteOptions = (
  options: Options<GetInstructorExperienceData>
) => {
  return infiniteQueryOptions<
    GetInstructorExperienceResponse,
    GetInstructorExperienceError,
    InfiniteData<GetInstructorExperienceResponse>,
    QueryKey<Options<GetInstructorExperienceData>>,
    | number
    | Pick<QueryKey<Options<GetInstructorExperienceData>>[0], 'body' | 'headers' | 'path' | 'query'>
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<GetInstructorExperienceData>>[0],
          'body' | 'headers' | 'path' | 'query'
        > =
          typeof pageParam === 'object'
            ? pageParam
            : {
                query: {
                  'pageable.page': pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getInstructorExperience({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: getInstructorExperienceInfiniteQueryKey(options),
    }
  );
};

export const addInstructorExperienceQueryKey = (options: Options<AddInstructorExperienceData>) =>
  createQueryKey('addInstructorExperience', options);

/**
 * Add experience to instructor
 * Adds work experience to an instructor
 */
export const addInstructorExperienceOptions = (options: Options<AddInstructorExperienceData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await addInstructorExperience({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: addInstructorExperienceQueryKey(options),
  });
};

/**
 * Add experience to instructor
 * Adds work experience to an instructor
 */
export const addInstructorExperienceMutation = (
  options?: Partial<Options<AddInstructorExperienceData>>
): UseMutationOptions<
  AddInstructorExperienceResponse,
  AddInstructorExperienceError,
  Options<AddInstructorExperienceData>
> => {
  const mutationOptions: UseMutationOptions<
    AddInstructorExperienceResponse,
    AddInstructorExperienceError,
    Options<AddInstructorExperienceData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await addInstructorExperience({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getInstructorEducationQueryKey = (options: Options<GetInstructorEducationData>) =>
  createQueryKey('getInstructorEducation', options);

/**
 * Get instructor education
 * Retrieves all education records for a specific instructor
 */
export const getInstructorEducationOptions = (options: Options<GetInstructorEducationData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getInstructorEducation({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getInstructorEducationQueryKey(options),
  });
};

export const addInstructorEducationQueryKey = (options: Options<AddInstructorEducationData>) =>
  createQueryKey('addInstructorEducation', options);

/**
 * Add education to instructor
 * Adds educational qualification to an instructor
 */
export const addInstructorEducationOptions = (options: Options<AddInstructorEducationData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await addInstructorEducation({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: addInstructorEducationQueryKey(options),
  });
};

/**
 * Add education to instructor
 * Adds educational qualification to an instructor
 */
export const addInstructorEducationMutation = (
  options?: Partial<Options<AddInstructorEducationData>>
): UseMutationOptions<
  AddInstructorEducationResponse,
  AddInstructorEducationError,
  Options<AddInstructorEducationData>
> => {
  const mutationOptions: UseMutationOptions<
    AddInstructorEducationResponse,
    AddInstructorEducationError,
    Options<AddInstructorEducationData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await addInstructorEducation({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getInstructorDocumentsQueryKey = (options: Options<GetInstructorDocumentsData>) =>
  createQueryKey('getInstructorDocuments', options);

/**
 * Get instructor documents
 * Retrieves all documents for a specific instructor
 */
export const getInstructorDocumentsOptions = (options: Options<GetInstructorDocumentsData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getInstructorDocuments({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getInstructorDocumentsQueryKey(options),
  });
};

export const addInstructorDocumentQueryKey = (options: Options<AddInstructorDocumentData>) =>
  createQueryKey('addInstructorDocument', options);

/**
 * Add document to instructor
 * Uploads and associates a document with an instructor
 */
export const addInstructorDocumentOptions = (options: Options<AddInstructorDocumentData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await addInstructorDocument({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: addInstructorDocumentQueryKey(options),
  });
};

/**
 * Add document to instructor
 * Uploads and associates a document with an instructor
 */
export const addInstructorDocumentMutation = (
  options?: Partial<Options<AddInstructorDocumentData>>
): UseMutationOptions<
  AddInstructorDocumentResponse,
  AddInstructorDocumentError,
  Options<AddInstructorDocumentData>
> => {
  const mutationOptions: UseMutationOptions<
    AddInstructorDocumentResponse,
    AddInstructorDocumentError,
    Options<AddInstructorDocumentData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await addInstructorDocument({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const verifyDocumentQueryKey = (options: Options<VerifyDocumentData>) =>
  createQueryKey('verifyDocument', options);

/**
 * Verify instructor document
 * Marks a document as verified
 */
export const verifyDocumentOptions = (options: Options<VerifyDocumentData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await verifyDocument({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: verifyDocumentQueryKey(options),
  });
};

/**
 * Verify instructor document
 * Marks a document as verified
 */
export const verifyDocumentMutation = (
  options?: Partial<Options<VerifyDocumentData>>
): UseMutationOptions<VerifyDocumentResponse, VerifyDocumentError, Options<VerifyDocumentData>> => {
  const mutationOptions: UseMutationOptions<
    VerifyDocumentResponse,
    VerifyDocumentError,
    Options<VerifyDocumentData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await verifyDocument({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const uploadInstructorDocumentQueryKey = (options: Options<UploadInstructorDocumentData>) =>
  createQueryKey('uploadInstructorDocument', options);

/**
 * Upload instructor document file
 * Uploads a PDF document for an instructor and creates a document record.
 *
 * **Use cases:**
 * - Uploading certificates, licenses, and other professional credentials.
 * - Attaching supporting documents to education, experience, or membership records.
 *
 * **File requirements:**
 * - Must be a PDF file (`application/pdf`).
 * - Stored via the platform StorageService under the `profile_documents` folder, partitioned by instructor UUID.
 *
 */
export const uploadInstructorDocumentOptions = (options: Options<UploadInstructorDocumentData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await uploadInstructorDocument({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: uploadInstructorDocumentQueryKey(options),
  });
};

/**
 * Upload instructor document file
 * Uploads a PDF document for an instructor and creates a document record.
 *
 * **Use cases:**
 * - Uploading certificates, licenses, and other professional credentials.
 * - Attaching supporting documents to education, experience, or membership records.
 *
 * **File requirements:**
 * - Must be a PDF file (`application/pdf`).
 * - Stored via the platform StorageService under the `profile_documents` folder, partitioned by instructor UUID.
 *
 */
export const uploadInstructorDocumentMutation = (
  options?: Partial<Options<UploadInstructorDocumentData>>
): UseMutationOptions<
  UploadInstructorDocumentResponse,
  UploadInstructorDocumentError,
  Options<UploadInstructorDocumentData>
> => {
  const mutationOptions: UseMutationOptions<
    UploadInstructorDocumentResponse,
    UploadInstructorDocumentError,
    Options<UploadInstructorDocumentData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await uploadInstructorDocument({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const createLinkQueryKey = (options: Options<CreateLinkData>) =>
  createQueryKey('createLink', options);

/**
 * Link a guardian to a learner
 * Grants a guardian/parent access to monitor a learner using their own credentials.
 */
export const createLinkOptions = (options: Options<CreateLinkData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await createLink({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: createLinkQueryKey(options),
  });
};

/**
 * Link a guardian to a learner
 * Grants a guardian/parent access to monitor a learner using their own credentials.
 */
export const createLinkMutation = (
  options?: Partial<Options<CreateLinkData>>
): UseMutationOptions<CreateLinkResponse, CreateLinkError, Options<CreateLinkData>> => {
  const mutationOptions: UseMutationOptions<
    CreateLinkResponse,
    CreateLinkError,
    Options<CreateLinkData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await createLink({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const enrollStudentQueryKey = (options: Options<EnrollStudentData>) =>
  createQueryKey('enrollStudent', options);

/**
 * Enroll a student into a class across all scheduled instances
 */
export const enrollStudentOptions = (options: Options<EnrollStudentData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await enrollStudent({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: enrollStudentQueryKey(options),
  });
};

/**
 * Enroll a student into a class across all scheduled instances
 */
export const enrollStudentMutation = (
  options?: Partial<Options<EnrollStudentData>>
): UseMutationOptions<EnrollStudentResponse, EnrollStudentError, Options<EnrollStudentData>> => {
  const mutationOptions: UseMutationOptions<
    EnrollStudentResponse,
    EnrollStudentError,
    Options<EnrollStudentData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await enrollStudent({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const joinWaitlistQueryKey = (options: Options<JoinWaitlistData>) =>
  createQueryKey('joinWaitlist', options);

/**
 * Join class waitlist when capacity is full
 */
export const joinWaitlistOptions = (options: Options<JoinWaitlistData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await joinWaitlist({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: joinWaitlistQueryKey(options),
  });
};

/**
 * Join class waitlist when capacity is full
 */
export const joinWaitlistMutation = (
  options?: Partial<Options<JoinWaitlistData>>
): UseMutationOptions<JoinWaitlistResponse, JoinWaitlistError, Options<JoinWaitlistData>> => {
  const mutationOptions: UseMutationOptions<
    JoinWaitlistResponse,
    JoinWaitlistError,
    Options<JoinWaitlistData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await joinWaitlist({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getAllCoursesQueryKey = (options: Options<GetAllCoursesData>) =>
  createQueryKey('getAllCourses', options);

/**
 * Get all courses
 * Retrieves paginated list of all courses with category information and filtering support.
 */
export const getAllCoursesOptions = (options: Options<GetAllCoursesData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getAllCourses({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getAllCoursesQueryKey(options),
  });
};

export const getAllCoursesInfiniteQueryKey = (
  options: Options<GetAllCoursesData>
): QueryKey<Options<GetAllCoursesData>> => createQueryKey('getAllCourses', options, true);

/**
 * Get all courses
 * Retrieves paginated list of all courses with category information and filtering support.
 */
export const getAllCoursesInfiniteOptions = (options: Options<GetAllCoursesData>) => {
  return infiniteQueryOptions<
    GetAllCoursesResponse,
    GetAllCoursesError,
    InfiniteData<GetAllCoursesResponse>,
    QueryKey<Options<GetAllCoursesData>>,
    number | Pick<QueryKey<Options<GetAllCoursesData>>[0], 'body' | 'headers' | 'path' | 'query'>
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<GetAllCoursesData>>[0],
          'body' | 'headers' | 'path' | 'query'
        > =
          typeof pageParam === 'object'
            ? pageParam
            : {
                query: {
                  'pageable.page': pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getAllCourses({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: getAllCoursesInfiniteQueryKey(options),
    }
  );
};

export const createCourseQueryKey = (options: Options<CreateCourseData>) =>
  createQueryKey('createCourse', options);

/**
 * Create a new course
 * Creates a new course with default DRAFT status and inactive state. Supports multiple categories.
 *
 * **Category Assignment:**
 * - Use `category_uuids` field to assign multiple categories to the course
 * - Categories are validated to ensure they exist before assignment
 * - A course can belong to multiple categories for better organization and discoverability
 *
 * **Example Request Body:**
 * ```json
 * {
 * "name": "Advanced Java Programming",
 * "instructor_uuid": "instructor-uuid-here",
 * "category_uuids": ["java-uuid", "programming-uuid"],
 * "description": "Comprehensive Java course",
 * "duration_hours": 40,
 * "duration_minutes": 0
 * }
 * ```
 *
 */
export const createCourseOptions = (options: Options<CreateCourseData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await createCourse({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: createCourseQueryKey(options),
  });
};

/**
 * Create a new course
 * Creates a new course with default DRAFT status and inactive state. Supports multiple categories.
 *
 * **Category Assignment:**
 * - Use `category_uuids` field to assign multiple categories to the course
 * - Categories are validated to ensure they exist before assignment
 * - A course can belong to multiple categories for better organization and discoverability
 *
 * **Example Request Body:**
 * ```json
 * {
 * "name": "Advanced Java Programming",
 * "instructor_uuid": "instructor-uuid-here",
 * "category_uuids": ["java-uuid", "programming-uuid"],
 * "description": "Comprehensive Java course",
 * "duration_hours": 40,
 * "duration_minutes": 0
 * }
 * ```
 *
 */
export const createCourseMutation = (
  options?: Partial<Options<CreateCourseData>>
): UseMutationOptions<CreateCourseResponse, CreateCourseError, Options<CreateCourseData>> => {
  const mutationOptions: UseMutationOptions<
    CreateCourseResponse,
    CreateCourseError,
    Options<CreateCourseData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await createCourse({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const unpublishCourseQueryKey = (options: Options<UnpublishCourseData>) =>
  createQueryKey('unpublishCourse', options);

/**
 * Unpublish course
 * Unpublishes a course, changing it from PUBLISHED to DRAFT status.
 *
 * **Smart Active Status Logic:**
 * - If NO active enrollments: Course becomes DRAFT and ACTIVE (available for new enrollments)
 * - If HAS active enrollments: Course becomes DRAFT and INACTIVE (existing students continue, no new enrollments)
 *
 * **Business Rules:**
 * - Course status always changes from PUBLISHED to DRAFT
 * - Active status depends on current enrollment situation
 * - Existing enrollments are never affected
 * - Course can be published again later
 *
 * **Use Cases:**
 * - Temporarily remove course from catalog while keeping it available
 * - Stop new enrollments while allowing current students to continue
 * - Prepare course for updates before republishing
 *
 */
export const unpublishCourseOptions = (options: Options<UnpublishCourseData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await unpublishCourse({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: unpublishCourseQueryKey(options),
  });
};

/**
 * Unpublish course
 * Unpublishes a course, changing it from PUBLISHED to DRAFT status.
 *
 * **Smart Active Status Logic:**
 * - If NO active enrollments: Course becomes DRAFT and ACTIVE (available for new enrollments)
 * - If HAS active enrollments: Course becomes DRAFT and INACTIVE (existing students continue, no new enrollments)
 *
 * **Business Rules:**
 * - Course status always changes from PUBLISHED to DRAFT
 * - Active status depends on current enrollment situation
 * - Existing enrollments are never affected
 * - Course can be published again later
 *
 * **Use Cases:**
 * - Temporarily remove course from catalog while keeping it available
 * - Stop new enrollments while allowing current students to continue
 * - Prepare course for updates before republishing
 *
 */
export const unpublishCourseMutation = (
  options?: Partial<Options<UnpublishCourseData>>
): UseMutationOptions<
  UnpublishCourseResponse,
  UnpublishCourseError,
  Options<UnpublishCourseData>
> => {
  const mutationOptions: UseMutationOptions<
    UnpublishCourseResponse,
    UnpublishCourseError,
    Options<UnpublishCourseData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await unpublishCourse({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const uploadCourseThumbnailQueryKey = (options: Options<UploadCourseThumbnailData>) =>
  createQueryKey('uploadCourseThumbnail', options);

/**
 * Upload course thumbnail
 * Uploads a thumbnail image for the specified course. The thumbnail is typically used in course
 * listings, search results, and course cards throughout the application.
 *
 * **File Requirements:**
 * - Supported formats: JPG, PNG, GIF, WebP
 * - Maximum file size: 5MB
 * - Recommended dimensions: 400x300 pixels or 4:3 aspect ratio
 * - Files will be automatically optimized for web delivery
 *
 * **Usage Guidelines:**
 * - Thumbnails should clearly represent the course content
 * - Use high-quality, professional images
 * - Avoid images with too much text or small details
 * - Consider accessibility and contrast for text overlays
 *
 * **Storage Details:**
 * - Files are stored in the course_thumbnails folder
 * - Previous thumbnail will be replaced if a new one is uploaded
 * - Generated URL will be automatically set in the course record
 *
 */
export const uploadCourseThumbnailOptions = (options: Options<UploadCourseThumbnailData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await uploadCourseThumbnail({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: uploadCourseThumbnailQueryKey(options),
  });
};

/**
 * Upload course thumbnail
 * Uploads a thumbnail image for the specified course. The thumbnail is typically used in course
 * listings, search results, and course cards throughout the application.
 *
 * **File Requirements:**
 * - Supported formats: JPG, PNG, GIF, WebP
 * - Maximum file size: 5MB
 * - Recommended dimensions: 400x300 pixels or 4:3 aspect ratio
 * - Files will be automatically optimized for web delivery
 *
 * **Usage Guidelines:**
 * - Thumbnails should clearly represent the course content
 * - Use high-quality, professional images
 * - Avoid images with too much text or small details
 * - Consider accessibility and contrast for text overlays
 *
 * **Storage Details:**
 * - Files are stored in the course_thumbnails folder
 * - Previous thumbnail will be replaced if a new one is uploaded
 * - Generated URL will be automatically set in the course record
 *
 */
export const uploadCourseThumbnailMutation = (
  options?: Partial<Options<UploadCourseThumbnailData>>
): UseMutationOptions<
  UploadCourseThumbnailResponse,
  UploadCourseThumbnailError,
  Options<UploadCourseThumbnailData>
> => {
  const mutationOptions: UseMutationOptions<
    UploadCourseThumbnailResponse,
    UploadCourseThumbnailError,
    Options<UploadCourseThumbnailData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await uploadCourseThumbnail({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const publishCourseQueryKey = (options: Options<PublishCourseData>) =>
  createQueryKey('publishCourse', options);

/**
 * Publish course
 * Publishes a course making it available for enrollment.
 */
export const publishCourseOptions = (options: Options<PublishCourseData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await publishCourse({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: publishCourseQueryKey(options),
  });
};

/**
 * Publish course
 * Publishes a course making it available for enrollment.
 */
export const publishCourseMutation = (
  options?: Partial<Options<PublishCourseData>>
): UseMutationOptions<PublishCourseResponse, PublishCourseError, Options<PublishCourseData>> => {
  const mutationOptions: UseMutationOptions<
    PublishCourseResponse,
    PublishCourseError,
    Options<PublishCourseData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await publishCourse({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const uploadCourseIntroVideoQueryKey = (options: Options<UploadCourseIntroVideoData>) =>
  createQueryKey('uploadCourseIntroVideo', options);

/**
 * Upload course introduction video
 * Uploads an introduction video for the specified course. The intro video is used for course
 * previews, marketing, and helping students understand what they'll learn.
 *
 * **File Requirements:**
 * - Supported formats: MP4, WebM, MOV, AVI
 * - Maximum file size: 100MB
 * - Recommended duration: 1-3 minutes
 * - Recommended resolution: 720p or 1080p
 *
 * **Content Guidelines:**
 * - Keep intro videos concise and engaging
 * - Clearly explain what students will learn
 * - Include instructor introduction if appropriate
 * - Ensure good audio quality
 * - Consider adding captions for accessibility
 *
 * **Storage Details:**
 * - Files are stored in the course_intro_videos folder
 * - Previous intro video will be replaced if a new one is uploaded
 * - Generated URL will be automatically set in the course record
 * - Consider video compression for optimal streaming performance
 *
 */
export const uploadCourseIntroVideoOptions = (options: Options<UploadCourseIntroVideoData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await uploadCourseIntroVideo({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: uploadCourseIntroVideoQueryKey(options),
  });
};

/**
 * Upload course introduction video
 * Uploads an introduction video for the specified course. The intro video is used for course
 * previews, marketing, and helping students understand what they'll learn.
 *
 * **File Requirements:**
 * - Supported formats: MP4, WebM, MOV, AVI
 * - Maximum file size: 100MB
 * - Recommended duration: 1-3 minutes
 * - Recommended resolution: 720p or 1080p
 *
 * **Content Guidelines:**
 * - Keep intro videos concise and engaging
 * - Clearly explain what students will learn
 * - Include instructor introduction if appropriate
 * - Ensure good audio quality
 * - Consider adding captions for accessibility
 *
 * **Storage Details:**
 * - Files are stored in the course_intro_videos folder
 * - Previous intro video will be replaced if a new one is uploaded
 * - Generated URL will be automatically set in the course record
 * - Consider video compression for optimal streaming performance
 *
 */
export const uploadCourseIntroVideoMutation = (
  options?: Partial<Options<UploadCourseIntroVideoData>>
): UseMutationOptions<
  UploadCourseIntroVideoResponse,
  UploadCourseIntroVideoError,
  Options<UploadCourseIntroVideoData>
> => {
  const mutationOptions: UseMutationOptions<
    UploadCourseIntroVideoResponse,
    UploadCourseIntroVideoError,
    Options<UploadCourseIntroVideoData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await uploadCourseIntroVideo({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const uploadCourseBannerQueryKey = (options: Options<UploadCourseBannerData>) =>
  createQueryKey('uploadCourseBanner', options);

/**
 * Upload course banner
 * Uploads a banner image for the specified course. The banner is typically used on the course
 * detail page as a hero image and in promotional materials.
 *
 * **File Requirements:**
 * - Supported formats: JPG, PNG, GIF, WebP
 * - Maximum file size: 10MB
 * - Recommended dimensions: 1200x400 pixels or 3:1 aspect ratio
 * - Files will be automatically optimized for web delivery
 *
 * **Usage Guidelines:**
 * - Banners should be visually striking and professional
 * - Consider responsive design - banner should work on mobile and desktop
 * - Use images that complement your course branding
 * - Ensure good contrast if overlaying text
 *
 * **Storage Details:**
 * - Files are stored in the course_banners folder
 * - Previous banner will be replaced if a new one is uploaded
 * - Generated URL will be automatically set in the course record
 *
 */
export const uploadCourseBannerOptions = (options: Options<UploadCourseBannerData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await uploadCourseBanner({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: uploadCourseBannerQueryKey(options),
  });
};

/**
 * Upload course banner
 * Uploads a banner image for the specified course. The banner is typically used on the course
 * detail page as a hero image and in promotional materials.
 *
 * **File Requirements:**
 * - Supported formats: JPG, PNG, GIF, WebP
 * - Maximum file size: 10MB
 * - Recommended dimensions: 1200x400 pixels or 3:1 aspect ratio
 * - Files will be automatically optimized for web delivery
 *
 * **Usage Guidelines:**
 * - Banners should be visually striking and professional
 * - Consider responsive design - banner should work on mobile and desktop
 * - Use images that complement your course branding
 * - Ensure good contrast if overlaying text
 *
 * **Storage Details:**
 * - Files are stored in the course_banners folder
 * - Previous banner will be replaced if a new one is uploaded
 * - Generated URL will be automatically set in the course record
 *
 */
export const uploadCourseBannerMutation = (
  options?: Partial<Options<UploadCourseBannerData>>
): UseMutationOptions<
  UploadCourseBannerResponse,
  UploadCourseBannerError,
  Options<UploadCourseBannerData>
> => {
  const mutationOptions: UseMutationOptions<
    UploadCourseBannerResponse,
    UploadCourseBannerError,
    Options<UploadCourseBannerData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await uploadCourseBanner({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const archiveCourseQueryKey = (options: Options<ArchiveCourseData>) =>
  createQueryKey('archiveCourse', options);

/**
 * Archive course
 * Archives a course, making it completely unavailable.
 *
 * **Important:**
 * - This is typically a permanent action
 * - Course becomes completely inaccessible to new students
 * - Existing enrollments may be handled differently based on business rules
 * - Course data is preserved for historical/audit purposes
 *
 */
export const archiveCourseOptions = (options: Options<ArchiveCourseData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await archiveCourse({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: archiveCourseQueryKey(options),
  });
};

/**
 * Archive course
 * Archives a course, making it completely unavailable.
 *
 * **Important:**
 * - This is typically a permanent action
 * - Course becomes completely inaccessible to new students
 * - Existing enrollments may be handled differently based on business rules
 * - Course data is preserved for historical/audit purposes
 *
 */
export const archiveCourseMutation = (
  options?: Partial<Options<ArchiveCourseData>>
): UseMutationOptions<ArchiveCourseResponse, ArchiveCourseError, Options<ArchiveCourseData>> => {
  const mutationOptions: UseMutationOptions<
    ArchiveCourseResponse,
    ArchiveCourseError,
    Options<ArchiveCourseData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await archiveCourse({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getCourseTrainingRequirementsQueryKey = (
  options: Options<GetCourseTrainingRequirementsData>
) => createQueryKey('getCourseTrainingRequirements', options);

/**
 * Get training delivery requirements
 * Retrieves all operational training requirements for a specific course.
 */
export const getCourseTrainingRequirementsOptions = (
  options: Options<GetCourseTrainingRequirementsData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getCourseTrainingRequirements({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getCourseTrainingRequirementsQueryKey(options),
  });
};

export const getCourseTrainingRequirementsInfiniteQueryKey = (
  options: Options<GetCourseTrainingRequirementsData>
): QueryKey<Options<GetCourseTrainingRequirementsData>> =>
  createQueryKey('getCourseTrainingRequirements', options, true);

/**
 * Get training delivery requirements
 * Retrieves all operational training requirements for a specific course.
 */
export const getCourseTrainingRequirementsInfiniteOptions = (
  options: Options<GetCourseTrainingRequirementsData>
) => {
  return infiniteQueryOptions<
    GetCourseTrainingRequirementsResponse,
    GetCourseTrainingRequirementsError,
    InfiniteData<GetCourseTrainingRequirementsResponse>,
    QueryKey<Options<GetCourseTrainingRequirementsData>>,
    | number
    | Pick<
        QueryKey<Options<GetCourseTrainingRequirementsData>>[0],
        'body' | 'headers' | 'path' | 'query'
      >
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<GetCourseTrainingRequirementsData>>[0],
          'body' | 'headers' | 'path' | 'query'
        > =
          typeof pageParam === 'object'
            ? pageParam
            : {
                query: {
                  'pageable.page': pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getCourseTrainingRequirements({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: getCourseTrainingRequirementsInfiniteQueryKey(options),
    }
  );
};

export const addCourseTrainingRequirementQueryKey = (
  options: Options<AddCourseTrainingRequirementData>
) => createQueryKey('addCourseTrainingRequirement', options);

/**
 * Add training delivery requirement
 * Adds a new material, equipment, or facility requirement necessary to deliver the course.
 */
export const addCourseTrainingRequirementOptions = (
  options: Options<AddCourseTrainingRequirementData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await addCourseTrainingRequirement({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: addCourseTrainingRequirementQueryKey(options),
  });
};

/**
 * Add training delivery requirement
 * Adds a new material, equipment, or facility requirement necessary to deliver the course.
 */
export const addCourseTrainingRequirementMutation = (
  options?: Partial<Options<AddCourseTrainingRequirementData>>
): UseMutationOptions<
  AddCourseTrainingRequirementResponse,
  AddCourseTrainingRequirementError,
  Options<AddCourseTrainingRequirementData>
> => {
  const mutationOptions: UseMutationOptions<
    AddCourseTrainingRequirementResponse,
    AddCourseTrainingRequirementError,
    Options<AddCourseTrainingRequirementData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await addCourseTrainingRequirement({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const listTrainingApplicationsQueryKey = (options: Options<ListTrainingApplicationsData>) =>
  createQueryKey('listTrainingApplications', options);

/**
 * List training applications
 * Retrieves applications for a course. Optionally filter by status using `status=pending|approved|rejected|revoked`.
 *
 */
export const listTrainingApplicationsOptions = (options: Options<ListTrainingApplicationsData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await listTrainingApplications({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: listTrainingApplicationsQueryKey(options),
  });
};

export const listTrainingApplicationsInfiniteQueryKey = (
  options: Options<ListTrainingApplicationsData>
): QueryKey<Options<ListTrainingApplicationsData>> =>
  createQueryKey('listTrainingApplications', options, true);

/**
 * List training applications
 * Retrieves applications for a course. Optionally filter by status using `status=pending|approved|rejected|revoked`.
 *
 */
export const listTrainingApplicationsInfiniteOptions = (
  options: Options<ListTrainingApplicationsData>
) => {
  return infiniteQueryOptions<
    ListTrainingApplicationsResponse,
    ListTrainingApplicationsError,
    InfiniteData<ListTrainingApplicationsResponse>,
    QueryKey<Options<ListTrainingApplicationsData>>,
    | number
    | Pick<
        QueryKey<Options<ListTrainingApplicationsData>>[0],
        'body' | 'headers' | 'path' | 'query'
      >
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<ListTrainingApplicationsData>>[0],
          'body' | 'headers' | 'path' | 'query'
        > =
          typeof pageParam === 'object'
            ? pageParam
            : {
                query: {
                  'pageable.page': pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await listTrainingApplications({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: listTrainingApplicationsInfiniteQueryKey(options),
    }
  );
};

export const submitTrainingApplicationQueryKey = (
  options: Options<SubmitTrainingApplicationData>
) => createQueryKey('submitTrainingApplication', options);

/**
 * Submit training application
 * Allows an instructor or organisation to apply for permission to deliver the specified course.
 *
 * **Application Workflow:**
 * - Applicants submit once per course. Rejected applications can be resubmitted, which reopens the request.
 * - Duplicate pending or approved submissions are rejected with clear error messages. Revoked applicants must resubmit to regain access.
 * - Course creators review applications using the approval endpoints below.
 *
 */
export const submitTrainingApplicationOptions = (
  options: Options<SubmitTrainingApplicationData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await submitTrainingApplication({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: submitTrainingApplicationQueryKey(options),
  });
};

/**
 * Submit training application
 * Allows an instructor or organisation to apply for permission to deliver the specified course.
 *
 * **Application Workflow:**
 * - Applicants submit once per course. Rejected applications can be resubmitted, which reopens the request.
 * - Duplicate pending or approved submissions are rejected with clear error messages. Revoked applicants must resubmit to regain access.
 * - Course creators review applications using the approval endpoints below.
 *
 */
export const submitTrainingApplicationMutation = (
  options?: Partial<Options<SubmitTrainingApplicationData>>
): UseMutationOptions<
  SubmitTrainingApplicationResponse,
  SubmitTrainingApplicationError,
  Options<SubmitTrainingApplicationData>
> => {
  const mutationOptions: UseMutationOptions<
    SubmitTrainingApplicationResponse,
    SubmitTrainingApplicationError,
    Options<SubmitTrainingApplicationData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await submitTrainingApplication({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getTrainingApplicationQueryKey = (options: Options<GetTrainingApplicationData>) =>
  createQueryKey('getTrainingApplication', options);

/**
 * Get training application
 * Retrieves a specific training application for a course.
 */
export const getTrainingApplicationOptions = (options: Options<GetTrainingApplicationData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getTrainingApplication({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getTrainingApplicationQueryKey(options),
  });
};

export const decideOnTrainingApplicationQueryKey = (
  options: Options<DecideOnTrainingApplicationData>
) => createQueryKey('decideOnTrainingApplication', options);

/**
 * Decide on training application
 * Applies a decision to an instructor or organisation application to deliver the course.
 * Use the `action` query parameter with values `approve`, `reject`, or `revoke`.
 *
 */
export const decideOnTrainingApplicationOptions = (
  options: Options<DecideOnTrainingApplicationData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await decideOnTrainingApplication({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: decideOnTrainingApplicationQueryKey(options),
  });
};

/**
 * Decide on training application
 * Applies a decision to an instructor or organisation application to deliver the course.
 * Use the `action` query parameter with values `approve`, `reject`, or `revoke`.
 *
 */
export const decideOnTrainingApplicationMutation = (
  options?: Partial<Options<DecideOnTrainingApplicationData>>
): UseMutationOptions<
  DecideOnTrainingApplicationResponse,
  DecideOnTrainingApplicationError,
  Options<DecideOnTrainingApplicationData>
> => {
  const mutationOptions: UseMutationOptions<
    DecideOnTrainingApplicationResponse,
    DecideOnTrainingApplicationError,
    Options<DecideOnTrainingApplicationData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await decideOnTrainingApplication({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getCourseRubricsQueryKey = (options: Options<GetCourseRubricsData>) =>
  createQueryKey('getCourseRubrics', options);

/**
 * Get all rubrics associated with a course
 * Retrieves all rubrics that are associated with the specified course, including usage context.
 */
export const getCourseRubricsOptions = (options: Options<GetCourseRubricsData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getCourseRubrics({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getCourseRubricsQueryKey(options),
  });
};

export const getCourseRubricsInfiniteQueryKey = (
  options: Options<GetCourseRubricsData>
): QueryKey<Options<GetCourseRubricsData>> => createQueryKey('getCourseRubrics', options, true);

/**
 * Get all rubrics associated with a course
 * Retrieves all rubrics that are associated with the specified course, including usage context.
 */
export const getCourseRubricsInfiniteOptions = (options: Options<GetCourseRubricsData>) => {
  return infiniteQueryOptions<
    GetCourseRubricsResponse,
    GetCourseRubricsError,
    InfiniteData<GetCourseRubricsResponse>,
    QueryKey<Options<GetCourseRubricsData>>,
    number | Pick<QueryKey<Options<GetCourseRubricsData>>[0], 'body' | 'headers' | 'path' | 'query'>
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<GetCourseRubricsData>>[0],
          'body' | 'headers' | 'path' | 'query'
        > =
          typeof pageParam === 'object'
            ? pageParam
            : {
                query: {
                  'pageable.page': pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getCourseRubrics({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: getCourseRubricsInfiniteQueryKey(options),
    }
  );
};

export const associateRubricQueryKey = (options: Options<AssociateRubricData>) =>
  createQueryKey('associateRubric', options);

/**
 * Associate a rubric with a course
 * Creates an association between a rubric and a course, allowing the rubric to be used for assessments in that course.
 */
export const associateRubricOptions = (options: Options<AssociateRubricData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await associateRubric({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: associateRubricQueryKey(options),
  });
};

/**
 * Associate a rubric with a course
 * Creates an association between a rubric and a course, allowing the rubric to be used for assessments in that course.
 */
export const associateRubricMutation = (
  options?: Partial<Options<AssociateRubricData>>
): UseMutationOptions<
  AssociateRubricResponse,
  AssociateRubricError,
  Options<AssociateRubricData>
> => {
  const mutationOptions: UseMutationOptions<
    AssociateRubricResponse,
    AssociateRubricError,
    Options<AssociateRubricData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await associateRubric({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getCourseRequirementsQueryKey = (options: Options<GetCourseRequirementsData>) =>
  createQueryKey('getCourseRequirements', options);

/**
 * Get course requirements
 * Retrieves all requirements for a specific course.
 */
export const getCourseRequirementsOptions = (options: Options<GetCourseRequirementsData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getCourseRequirements({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getCourseRequirementsQueryKey(options),
  });
};

export const getCourseRequirementsInfiniteQueryKey = (
  options: Options<GetCourseRequirementsData>
): QueryKey<Options<GetCourseRequirementsData>> =>
  createQueryKey('getCourseRequirements', options, true);

/**
 * Get course requirements
 * Retrieves all requirements for a specific course.
 */
export const getCourseRequirementsInfiniteOptions = (
  options: Options<GetCourseRequirementsData>
) => {
  return infiniteQueryOptions<
    GetCourseRequirementsResponse,
    GetCourseRequirementsError,
    InfiniteData<GetCourseRequirementsResponse>,
    QueryKey<Options<GetCourseRequirementsData>>,
    | number
    | Pick<QueryKey<Options<GetCourseRequirementsData>>[0], 'body' | 'headers' | 'path' | 'query'>
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<GetCourseRequirementsData>>[0],
          'body' | 'headers' | 'path' | 'query'
        > =
          typeof pageParam === 'object'
            ? pageParam
            : {
                query: {
                  'pageable.page': pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getCourseRequirements({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: getCourseRequirementsInfiniteQueryKey(options),
    }
  );
};

export const addCourseRequirementQueryKey = (options: Options<AddCourseRequirementData>) =>
  createQueryKey('addCourseRequirement', options);

/**
 * Add requirement to course
 * Adds a new requirement or prerequisite to a course.
 */
export const addCourseRequirementOptions = (options: Options<AddCourseRequirementData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await addCourseRequirement({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: addCourseRequirementQueryKey(options),
  });
};

/**
 * Add requirement to course
 * Adds a new requirement or prerequisite to a course.
 */
export const addCourseRequirementMutation = (
  options?: Partial<Options<AddCourseRequirementData>>
): UseMutationOptions<
  AddCourseRequirementResponse,
  AddCourseRequirementError,
  Options<AddCourseRequirementData>
> => {
  const mutationOptions: UseMutationOptions<
    AddCourseRequirementResponse,
    AddCourseRequirementError,
    Options<AddCourseRequirementData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await addCourseRequirement({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getCourseLessonsQueryKey = (options: Options<GetCourseLessonsData>) =>
  createQueryKey('getCourseLessons', options);

/**
 * Get course lessons
 * Retrieves all lessons for a specific course in sequence order.
 */
export const getCourseLessonsOptions = (options: Options<GetCourseLessonsData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getCourseLessons({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getCourseLessonsQueryKey(options),
  });
};

export const getCourseLessonsInfiniteQueryKey = (
  options: Options<GetCourseLessonsData>
): QueryKey<Options<GetCourseLessonsData>> => createQueryKey('getCourseLessons', options, true);

/**
 * Get course lessons
 * Retrieves all lessons for a specific course in sequence order.
 */
export const getCourseLessonsInfiniteOptions = (options: Options<GetCourseLessonsData>) => {
  return infiniteQueryOptions<
    GetCourseLessonsResponse,
    GetCourseLessonsError,
    InfiniteData<GetCourseLessonsResponse>,
    QueryKey<Options<GetCourseLessonsData>>,
    number | Pick<QueryKey<Options<GetCourseLessonsData>>[0], 'body' | 'headers' | 'path' | 'query'>
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<GetCourseLessonsData>>[0],
          'body' | 'headers' | 'path' | 'query'
        > =
          typeof pageParam === 'object'
            ? pageParam
            : {
                query: {
                  'pageable.page': pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getCourseLessons({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: getCourseLessonsInfiniteQueryKey(options),
    }
  );
};

export const addCourseLessonQueryKey = (options: Options<AddCourseLessonData>) =>
  createQueryKey('addCourseLesson', options);

/**
 * Add lesson to course
 * Creates a new lesson associated with the specified course.
 */
export const addCourseLessonOptions = (options: Options<AddCourseLessonData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await addCourseLesson({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: addCourseLessonQueryKey(options),
  });
};

/**
 * Add lesson to course
 * Creates a new lesson associated with the specified course.
 */
export const addCourseLessonMutation = (
  options?: Partial<Options<AddCourseLessonData>>
): UseMutationOptions<
  AddCourseLessonResponse,
  AddCourseLessonError,
  Options<AddCourseLessonData>
> => {
  const mutationOptions: UseMutationOptions<
    AddCourseLessonResponse,
    AddCourseLessonError,
    Options<AddCourseLessonData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await addCourseLesson({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getLessonContentQueryKey = (options: Options<GetLessonContentData>) =>
  createQueryKey('getLessonContent', options);

/**
 * Get lesson content
 * Retrieves all content for a lesson in display order with computed properties.
 */
export const getLessonContentOptions = (options: Options<GetLessonContentData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getLessonContent({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getLessonContentQueryKey(options),
  });
};

export const addLessonContentQueryKey = (options: Options<AddLessonContentData>) =>
  createQueryKey('addLessonContent', options);

/**
 * Add content to lesson
 * Adds new content item to a specific lesson with automatic ordering.
 */
export const addLessonContentOptions = (options: Options<AddLessonContentData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await addLessonContent({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: addLessonContentQueryKey(options),
  });
};

/**
 * Add content to lesson
 * Adds new content item to a specific lesson with automatic ordering.
 */
export const addLessonContentMutation = (
  options?: Partial<Options<AddLessonContentData>>
): UseMutationOptions<
  AddLessonContentResponse,
  AddLessonContentError,
  Options<AddLessonContentData>
> => {
  const mutationOptions: UseMutationOptions<
    AddLessonContentResponse,
    AddLessonContentError,
    Options<AddLessonContentData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await addLessonContent({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const uploadLessonMediaQueryKey = (options: Options<UploadLessonMediaData>) =>
  createQueryKey('uploadLessonMedia', options);

/**
 * Upload media for lesson content
 * Uploads a media file (PDF, image, audio, video) for a specific lesson and creates a LessonContent record.
 *
 * **Use cases:**
 * - Course creators attaching PDFs, videos, or audio during course content authoring.
 * - Rich text editors (e.g. Tiptap) uploading inline images and receiving a public URL to embed in HTML.
 *
 * **File handling:**
 * - Files are stored via the platform StorageService under the `course_materials` folder, partitioned by course and lesson UUID.
 * - The returned LessonContentDTO will have `file_url`, `mime_type`, and `file_size_bytes` populated.
 *
 * To use this for a rich text editor image upload, call this endpoint with an `image` content type
 * and then embed the returned `file_url` in the editor HTML.
 *
 */
export const uploadLessonMediaOptions = (options: Options<UploadLessonMediaData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await uploadLessonMedia({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: uploadLessonMediaQueryKey(options),
  });
};

/**
 * Upload media for lesson content
 * Uploads a media file (PDF, image, audio, video) for a specific lesson and creates a LessonContent record.
 *
 * **Use cases:**
 * - Course creators attaching PDFs, videos, or audio during course content authoring.
 * - Rich text editors (e.g. Tiptap) uploading inline images and receiving a public URL to embed in HTML.
 *
 * **File handling:**
 * - Files are stored via the platform StorageService under the `course_materials` folder, partitioned by course and lesson UUID.
 * - The returned LessonContentDTO will have `file_url`, `mime_type`, and `file_size_bytes` populated.
 *
 * To use this for a rich text editor image upload, call this endpoint with an `image` content type
 * and then embed the returned `file_url` in the editor HTML.
 *
 */
export const uploadLessonMediaMutation = (
  options?: Partial<Options<UploadLessonMediaData>>
): UseMutationOptions<
  UploadLessonMediaResponse,
  UploadLessonMediaError,
  Options<UploadLessonMediaData>
> => {
  const mutationOptions: UseMutationOptions<
    UploadLessonMediaResponse,
    UploadLessonMediaError,
    Options<UploadLessonMediaData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await uploadLessonMedia({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const reorderLessonContentQueryKey = (options: Options<ReorderLessonContentData>) =>
  createQueryKey('reorderLessonContent', options);

/**
 * Reorder lesson content
 * Updates the display order of content items within a lesson.
 */
export const reorderLessonContentOptions = (options: Options<ReorderLessonContentData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await reorderLessonContent({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: reorderLessonContentQueryKey(options),
  });
};

/**
 * Reorder lesson content
 * Updates the display order of content items within a lesson.
 */
export const reorderLessonContentMutation = (
  options?: Partial<Options<ReorderLessonContentData>>
): UseMutationOptions<
  ReorderLessonContentResponse,
  ReorderLessonContentError,
  Options<ReorderLessonContentData>
> => {
  const mutationOptions: UseMutationOptions<
    ReorderLessonContentResponse,
    ReorderLessonContentError,
    Options<ReorderLessonContentData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await reorderLessonContent({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getCourseAssessmentsQueryKey = (options: Options<GetCourseAssessmentsData>) =>
  createQueryKey('getCourseAssessments', options);

/**
 * Get course assessments
 * Retrieves all assessments for a specific course.
 */
export const getCourseAssessmentsOptions = (options: Options<GetCourseAssessmentsData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getCourseAssessments({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getCourseAssessmentsQueryKey(options),
  });
};

export const getCourseAssessmentsInfiniteQueryKey = (
  options: Options<GetCourseAssessmentsData>
): QueryKey<Options<GetCourseAssessmentsData>> =>
  createQueryKey('getCourseAssessments', options, true);

/**
 * Get course assessments
 * Retrieves all assessments for a specific course.
 */
export const getCourseAssessmentsInfiniteOptions = (options: Options<GetCourseAssessmentsData>) => {
  return infiniteQueryOptions<
    GetCourseAssessmentsResponse,
    GetCourseAssessmentsError,
    InfiniteData<GetCourseAssessmentsResponse>,
    QueryKey<Options<GetCourseAssessmentsData>>,
    | number
    | Pick<QueryKey<Options<GetCourseAssessmentsData>>[0], 'body' | 'headers' | 'path' | 'query'>
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<GetCourseAssessmentsData>>[0],
          'body' | 'headers' | 'path' | 'query'
        > =
          typeof pageParam === 'object'
            ? pageParam
            : {
                query: {
                  'pageable.page': pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getCourseAssessments({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: getCourseAssessmentsInfiniteQueryKey(options),
    }
  );
};

export const addCourseAssessmentQueryKey = (options: Options<AddCourseAssessmentData>) =>
  createQueryKey('addCourseAssessment', options);

/**
 * Add assessment to course
 * Creates a new assessment for the course with optional rubric association.
 */
export const addCourseAssessmentOptions = (options: Options<AddCourseAssessmentData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await addCourseAssessment({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: addCourseAssessmentQueryKey(options),
  });
};

/**
 * Add assessment to course
 * Creates a new assessment for the course with optional rubric association.
 */
export const addCourseAssessmentMutation = (
  options?: Partial<Options<AddCourseAssessmentData>>
): UseMutationOptions<
  AddCourseAssessmentResponse,
  AddCourseAssessmentError,
  Options<AddCourseAssessmentData>
> => {
  const mutationOptions: UseMutationOptions<
    AddCourseAssessmentResponse,
    AddCourseAssessmentError,
    Options<AddCourseAssessmentData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await addCourseAssessment({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getAllCourseCreatorsQueryKey = (options: Options<GetAllCourseCreatorsData>) =>
  createQueryKey('getAllCourseCreators', options);

/**
 * Get all course creators
 * Fetches a paginated list of all course creator profiles in the system.
 */
export const getAllCourseCreatorsOptions = (options: Options<GetAllCourseCreatorsData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getAllCourseCreators({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getAllCourseCreatorsQueryKey(options),
  });
};

export const getAllCourseCreatorsInfiniteQueryKey = (
  options: Options<GetAllCourseCreatorsData>
): QueryKey<Options<GetAllCourseCreatorsData>> =>
  createQueryKey('getAllCourseCreators', options, true);

/**
 * Get all course creators
 * Fetches a paginated list of all course creator profiles in the system.
 */
export const getAllCourseCreatorsInfiniteOptions = (options: Options<GetAllCourseCreatorsData>) => {
  return infiniteQueryOptions<
    GetAllCourseCreatorsResponse,
    GetAllCourseCreatorsError,
    InfiniteData<GetAllCourseCreatorsResponse>,
    QueryKey<Options<GetAllCourseCreatorsData>>,
    | number
    | Pick<QueryKey<Options<GetAllCourseCreatorsData>>[0], 'body' | 'headers' | 'path' | 'query'>
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<GetAllCourseCreatorsData>>[0],
          'body' | 'headers' | 'path' | 'query'
        > =
          typeof pageParam === 'object'
            ? pageParam
            : {
                query: {
                  'pageable.page': pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getAllCourseCreators({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: getAllCourseCreatorsInfiniteQueryKey(options),
    }
  );
};

export const createCourseCreatorQueryKey = (options: Options<CreateCourseCreatorData>) =>
  createQueryKey('createCourseCreator', options);

/**
 * Create a new course creator
 * Saves a new course creator profile in the system. The course creator will be unverified by default and require admin verification.
 */
export const createCourseCreatorOptions = (options: Options<CreateCourseCreatorData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await createCourseCreator({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: createCourseCreatorQueryKey(options),
  });
};

/**
 * Create a new course creator
 * Saves a new course creator profile in the system. The course creator will be unverified by default and require admin verification.
 */
export const createCourseCreatorMutation = (
  options?: Partial<Options<CreateCourseCreatorData>>
): UseMutationOptions<
  CreateCourseCreatorResponse,
  CreateCourseCreatorError,
  Options<CreateCourseCreatorData>
> => {
  const mutationOptions: UseMutationOptions<
    CreateCourseCreatorResponse,
    CreateCourseCreatorError,
    Options<CreateCourseCreatorData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await createCourseCreator({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const verifyCourseCreatorQueryKey = (options: Options<VerifyCourseCreatorData>) =>
  createQueryKey('verifyCourseCreator', options);

/**
 * Verify a course creator
 * Marks a course creator as verified by an administrator. Only system admins can perform this operation.
 */
export const verifyCourseCreatorOptions = (options: Options<VerifyCourseCreatorData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await verifyCourseCreator({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: verifyCourseCreatorQueryKey(options),
  });
};

/**
 * Verify a course creator
 * Marks a course creator as verified by an administrator. Only system admins can perform this operation.
 */
export const verifyCourseCreatorMutation = (
  options?: Partial<Options<VerifyCourseCreatorData>>
): UseMutationOptions<
  VerifyCourseCreatorResponse,
  VerifyCourseCreatorError,
  Options<VerifyCourseCreatorData>
> => {
  const mutationOptions: UseMutationOptions<
    VerifyCourseCreatorResponse,
    VerifyCourseCreatorError,
    Options<VerifyCourseCreatorData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await verifyCourseCreator({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const unverifyCourseCreatorQueryKey = (options: Options<UnverifyCourseCreatorData>) =>
  createQueryKey('unverifyCourseCreator', options);

/**
 * Unverify a course creator
 * Removes verification status from a course creator. Only system admins can perform this operation.
 */
export const unverifyCourseCreatorOptions = (options: Options<UnverifyCourseCreatorData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await unverifyCourseCreator({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: unverifyCourseCreatorQueryKey(options),
  });
};

/**
 * Unverify a course creator
 * Removes verification status from a course creator. Only system admins can perform this operation.
 */
export const unverifyCourseCreatorMutation = (
  options?: Partial<Options<UnverifyCourseCreatorData>>
): UseMutationOptions<
  UnverifyCourseCreatorResponse,
  UnverifyCourseCreatorError,
  Options<UnverifyCourseCreatorData>
> => {
  const mutationOptions: UseMutationOptions<
    UnverifyCourseCreatorResponse,
    UnverifyCourseCreatorError,
    Options<UnverifyCourseCreatorData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await unverifyCourseCreator({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getCourseCreatorSkillsQueryKey = (options: Options<GetCourseCreatorSkillsData>) =>
  createQueryKey('getCourseCreatorSkills', options);

/**
 * List course creator skills
 * Retrieves all recorded skills for a specific course creator.
 */
export const getCourseCreatorSkillsOptions = (options: Options<GetCourseCreatorSkillsData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getCourseCreatorSkills({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getCourseCreatorSkillsQueryKey(options),
  });
};

export const getCourseCreatorSkillsInfiniteQueryKey = (
  options: Options<GetCourseCreatorSkillsData>
): QueryKey<Options<GetCourseCreatorSkillsData>> =>
  createQueryKey('getCourseCreatorSkills', options, true);

/**
 * List course creator skills
 * Retrieves all recorded skills for a specific course creator.
 */
export const getCourseCreatorSkillsInfiniteOptions = (
  options: Options<GetCourseCreatorSkillsData>
) => {
  return infiniteQueryOptions<
    GetCourseCreatorSkillsResponse,
    GetCourseCreatorSkillsError,
    InfiniteData<GetCourseCreatorSkillsResponse>,
    QueryKey<Options<GetCourseCreatorSkillsData>>,
    | number
    | Pick<QueryKey<Options<GetCourseCreatorSkillsData>>[0], 'body' | 'headers' | 'path' | 'query'>
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<GetCourseCreatorSkillsData>>[0],
          'body' | 'headers' | 'path' | 'query'
        > =
          typeof pageParam === 'object'
            ? pageParam
            : {
                query: {
                  'pageable.page': pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getCourseCreatorSkills({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: getCourseCreatorSkillsInfiniteQueryKey(options),
    }
  );
};

export const addCourseCreatorSkillQueryKey = (options: Options<AddCourseCreatorSkillData>) =>
  createQueryKey('addCourseCreatorSkill', options);

/**
 * Add skill to course creator
 * Captures a new competency for a course creator profile.
 */
export const addCourseCreatorSkillOptions = (options: Options<AddCourseCreatorSkillData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await addCourseCreatorSkill({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: addCourseCreatorSkillQueryKey(options),
  });
};

/**
 * Add skill to course creator
 * Captures a new competency for a course creator profile.
 */
export const addCourseCreatorSkillMutation = (
  options?: Partial<Options<AddCourseCreatorSkillData>>
): UseMutationOptions<
  AddCourseCreatorSkillResponse,
  AddCourseCreatorSkillError,
  Options<AddCourseCreatorSkillData>
> => {
  const mutationOptions: UseMutationOptions<
    AddCourseCreatorSkillResponse,
    AddCourseCreatorSkillError,
    Options<AddCourseCreatorSkillData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await addCourseCreatorSkill({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getCourseCreatorMembershipsQueryKey = (
  options: Options<GetCourseCreatorMembershipsData>
) => createQueryKey('getCourseCreatorMemberships', options);

/**
 * Get professional memberships
 * Retrieves memberships for a specific course creator.
 */
export const getCourseCreatorMembershipsOptions = (
  options: Options<GetCourseCreatorMembershipsData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getCourseCreatorMemberships({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getCourseCreatorMembershipsQueryKey(options),
  });
};

export const getCourseCreatorMembershipsInfiniteQueryKey = (
  options: Options<GetCourseCreatorMembershipsData>
): QueryKey<Options<GetCourseCreatorMembershipsData>> =>
  createQueryKey('getCourseCreatorMemberships', options, true);

/**
 * Get professional memberships
 * Retrieves memberships for a specific course creator.
 */
export const getCourseCreatorMembershipsInfiniteOptions = (
  options: Options<GetCourseCreatorMembershipsData>
) => {
  return infiniteQueryOptions<
    GetCourseCreatorMembershipsResponse,
    GetCourseCreatorMembershipsError,
    InfiniteData<GetCourseCreatorMembershipsResponse>,
    QueryKey<Options<GetCourseCreatorMembershipsData>>,
    | number
    | Pick<
        QueryKey<Options<GetCourseCreatorMembershipsData>>[0],
        'body' | 'headers' | 'path' | 'query'
      >
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<GetCourseCreatorMembershipsData>>[0],
          'body' | 'headers' | 'path' | 'query'
        > =
          typeof pageParam === 'object'
            ? pageParam
            : {
                query: {
                  'pageable.page': pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getCourseCreatorMemberships({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: getCourseCreatorMembershipsInfiniteQueryKey(options),
    }
  );
};

export const addCourseCreatorMembershipQueryKey = (
  options: Options<AddCourseCreatorMembershipData>
) => createQueryKey('addCourseCreatorMembership', options);

/**
 * Add professional membership
 * Captures an association or membership for a course creator.
 */
export const addCourseCreatorMembershipOptions = (
  options: Options<AddCourseCreatorMembershipData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await addCourseCreatorMembership({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: addCourseCreatorMembershipQueryKey(options),
  });
};

/**
 * Add professional membership
 * Captures an association or membership for a course creator.
 */
export const addCourseCreatorMembershipMutation = (
  options?: Partial<Options<AddCourseCreatorMembershipData>>
): UseMutationOptions<
  AddCourseCreatorMembershipResponse,
  AddCourseCreatorMembershipError,
  Options<AddCourseCreatorMembershipData>
> => {
  const mutationOptions: UseMutationOptions<
    AddCourseCreatorMembershipResponse,
    AddCourseCreatorMembershipError,
    Options<AddCourseCreatorMembershipData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await addCourseCreatorMembership({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getCourseCreatorExperienceQueryKey = (
  options: Options<GetCourseCreatorExperienceData>
) => createQueryKey('getCourseCreatorExperience', options);

/**
 * Get experience history
 * Retrieves professional experience entries for a course creator.
 */
export const getCourseCreatorExperienceOptions = (
  options: Options<GetCourseCreatorExperienceData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getCourseCreatorExperience({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getCourseCreatorExperienceQueryKey(options),
  });
};

export const getCourseCreatorExperienceInfiniteQueryKey = (
  options: Options<GetCourseCreatorExperienceData>
): QueryKey<Options<GetCourseCreatorExperienceData>> =>
  createQueryKey('getCourseCreatorExperience', options, true);

/**
 * Get experience history
 * Retrieves professional experience entries for a course creator.
 */
export const getCourseCreatorExperienceInfiniteOptions = (
  options: Options<GetCourseCreatorExperienceData>
) => {
  return infiniteQueryOptions<
    GetCourseCreatorExperienceResponse,
    GetCourseCreatorExperienceError,
    InfiniteData<GetCourseCreatorExperienceResponse>,
    QueryKey<Options<GetCourseCreatorExperienceData>>,
    | number
    | Pick<
        QueryKey<Options<GetCourseCreatorExperienceData>>[0],
        'body' | 'headers' | 'path' | 'query'
      >
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<GetCourseCreatorExperienceData>>[0],
          'body' | 'headers' | 'path' | 'query'
        > =
          typeof pageParam === 'object'
            ? pageParam
            : {
                query: {
                  'pageable.page': pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getCourseCreatorExperience({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: getCourseCreatorExperienceInfiniteQueryKey(options),
    }
  );
};

export const addCourseCreatorExperienceQueryKey = (
  options: Options<AddCourseCreatorExperienceData>
) => createQueryKey('addCourseCreatorExperience', options);

/**
 * Add experience record
 * Captures professional experience for a course creator.
 */
export const addCourseCreatorExperienceOptions = (
  options: Options<AddCourseCreatorExperienceData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await addCourseCreatorExperience({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: addCourseCreatorExperienceQueryKey(options),
  });
};

/**
 * Add experience record
 * Captures professional experience for a course creator.
 */
export const addCourseCreatorExperienceMutation = (
  options?: Partial<Options<AddCourseCreatorExperienceData>>
): UseMutationOptions<
  AddCourseCreatorExperienceResponse,
  AddCourseCreatorExperienceError,
  Options<AddCourseCreatorExperienceData>
> => {
  const mutationOptions: UseMutationOptions<
    AddCourseCreatorExperienceResponse,
    AddCourseCreatorExperienceError,
    Options<AddCourseCreatorExperienceData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await addCourseCreatorExperience({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getCourseCreatorEducationQueryKey = (
  options: Options<GetCourseCreatorEducationData>
) => createQueryKey('getCourseCreatorEducation', options);

/**
 * Get course creator education
 * Retrieves all education history for a course creator.
 */
export const getCourseCreatorEducationOptions = (
  options: Options<GetCourseCreatorEducationData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getCourseCreatorEducation({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getCourseCreatorEducationQueryKey(options),
  });
};

export const getCourseCreatorEducationInfiniteQueryKey = (
  options: Options<GetCourseCreatorEducationData>
): QueryKey<Options<GetCourseCreatorEducationData>> =>
  createQueryKey('getCourseCreatorEducation', options, true);

/**
 * Get course creator education
 * Retrieves all education history for a course creator.
 */
export const getCourseCreatorEducationInfiniteOptions = (
  options: Options<GetCourseCreatorEducationData>
) => {
  return infiniteQueryOptions<
    GetCourseCreatorEducationResponse,
    GetCourseCreatorEducationError,
    InfiniteData<GetCourseCreatorEducationResponse>,
    QueryKey<Options<GetCourseCreatorEducationData>>,
    | number
    | Pick<
        QueryKey<Options<GetCourseCreatorEducationData>>[0],
        'body' | 'headers' | 'path' | 'query'
      >
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<GetCourseCreatorEducationData>>[0],
          'body' | 'headers' | 'path' | 'query'
        > =
          typeof pageParam === 'object'
            ? pageParam
            : {
                query: {
                  'pageable.page': pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getCourseCreatorEducation({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: getCourseCreatorEducationInfiniteQueryKey(options),
    }
  );
};

export const addCourseCreatorEducationQueryKey = (
  options: Options<AddCourseCreatorEducationData>
) => createQueryKey('addCourseCreatorEducation', options);

/**
 * Add education record
 * Captures an academic qualification for a course creator.
 */
export const addCourseCreatorEducationOptions = (
  options: Options<AddCourseCreatorEducationData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await addCourseCreatorEducation({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: addCourseCreatorEducationQueryKey(options),
  });
};

/**
 * Add education record
 * Captures an academic qualification for a course creator.
 */
export const addCourseCreatorEducationMutation = (
  options?: Partial<Options<AddCourseCreatorEducationData>>
): UseMutationOptions<
  AddCourseCreatorEducationResponse,
  AddCourseCreatorEducationError,
  Options<AddCourseCreatorEducationData>
> => {
  const mutationOptions: UseMutationOptions<
    AddCourseCreatorEducationResponse,
    AddCourseCreatorEducationError,
    Options<AddCourseCreatorEducationData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await addCourseCreatorEducation({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getCourseCreatorCertificationsQueryKey = (
  options: Options<GetCourseCreatorCertificationsData>
) => createQueryKey('getCourseCreatorCertifications', options);

/**
 * Get certifications
 * Retrieves certification records for a course creator.
 */
export const getCourseCreatorCertificationsOptions = (
  options: Options<GetCourseCreatorCertificationsData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getCourseCreatorCertifications({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getCourseCreatorCertificationsQueryKey(options),
  });
};

export const getCourseCreatorCertificationsInfiniteQueryKey = (
  options: Options<GetCourseCreatorCertificationsData>
): QueryKey<Options<GetCourseCreatorCertificationsData>> =>
  createQueryKey('getCourseCreatorCertifications', options, true);

/**
 * Get certifications
 * Retrieves certification records for a course creator.
 */
export const getCourseCreatorCertificationsInfiniteOptions = (
  options: Options<GetCourseCreatorCertificationsData>
) => {
  return infiniteQueryOptions<
    GetCourseCreatorCertificationsResponse,
    GetCourseCreatorCertificationsError,
    InfiniteData<GetCourseCreatorCertificationsResponse>,
    QueryKey<Options<GetCourseCreatorCertificationsData>>,
    | number
    | Pick<
        QueryKey<Options<GetCourseCreatorCertificationsData>>[0],
        'body' | 'headers' | 'path' | 'query'
      >
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<GetCourseCreatorCertificationsData>>[0],
          'body' | 'headers' | 'path' | 'query'
        > =
          typeof pageParam === 'object'
            ? pageParam
            : {
                query: {
                  'pageable.page': pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getCourseCreatorCertifications({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: getCourseCreatorCertificationsInfiniteQueryKey(options),
    }
  );
};

export const addCourseCreatorCertificationQueryKey = (
  options: Options<AddCourseCreatorCertificationData>
) => createQueryKey('addCourseCreatorCertification', options);

/**
 * Add certification record
 * Captures a certification or accreditation held by a course creator.
 */
export const addCourseCreatorCertificationOptions = (
  options: Options<AddCourseCreatorCertificationData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await addCourseCreatorCertification({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: addCourseCreatorCertificationQueryKey(options),
  });
};

/**
 * Add certification record
 * Captures a certification or accreditation held by a course creator.
 */
export const addCourseCreatorCertificationMutation = (
  options?: Partial<Options<AddCourseCreatorCertificationData>>
): UseMutationOptions<
  AddCourseCreatorCertificationResponse,
  AddCourseCreatorCertificationError,
  Options<AddCourseCreatorCertificationData>
> => {
  const mutationOptions: UseMutationOptions<
    AddCourseCreatorCertificationResponse,
    AddCourseCreatorCertificationError,
    Options<AddCourseCreatorCertificationData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await addCourseCreatorCertification({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getAllGradingLevelsQueryKey = (options: Options<GetAllGradingLevelsData>) =>
  createQueryKey('getAllGradingLevels', options);

/**
 * Get all grading levels
 * Retrieves paginated list of all grading levels.
 */
export const getAllGradingLevelsOptions = (options: Options<GetAllGradingLevelsData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getAllGradingLevels({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getAllGradingLevelsQueryKey(options),
  });
};

export const getAllGradingLevelsInfiniteQueryKey = (
  options: Options<GetAllGradingLevelsData>
): QueryKey<Options<GetAllGradingLevelsData>> =>
  createQueryKey('getAllGradingLevels', options, true);

/**
 * Get all grading levels
 * Retrieves paginated list of all grading levels.
 */
export const getAllGradingLevelsInfiniteOptions = (options: Options<GetAllGradingLevelsData>) => {
  return infiniteQueryOptions<
    GetAllGradingLevelsResponse,
    GetAllGradingLevelsError,
    InfiniteData<GetAllGradingLevelsResponse>,
    QueryKey<Options<GetAllGradingLevelsData>>,
    | number
    | Pick<QueryKey<Options<GetAllGradingLevelsData>>[0], 'body' | 'headers' | 'path' | 'query'>
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<GetAllGradingLevelsData>>[0],
          'body' | 'headers' | 'path' | 'query'
        > =
          typeof pageParam === 'object'
            ? pageParam
            : {
                query: {
                  'pageable.page': pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getAllGradingLevels({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: getAllGradingLevelsInfiniteQueryKey(options),
    }
  );
};

export const createGradingLevelQueryKey = (options: Options<CreateGradingLevelData>) =>
  createQueryKey('createGradingLevel', options);

/**
 * Create grading level
 * Creates a new grading level for assessment scoring.
 */
export const createGradingLevelOptions = (options: Options<CreateGradingLevelData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await createGradingLevel({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: createGradingLevelQueryKey(options),
  });
};

/**
 * Create grading level
 * Creates a new grading level for assessment scoring.
 */
export const createGradingLevelMutation = (
  options?: Partial<Options<CreateGradingLevelData>>
): UseMutationOptions<
  CreateGradingLevelResponse,
  CreateGradingLevelError,
  Options<CreateGradingLevelData>
> => {
  const mutationOptions: UseMutationOptions<
    CreateGradingLevelResponse,
    CreateGradingLevelError,
    Options<CreateGradingLevelData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await createGradingLevel({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getAllDifficultyLevelsQueryKey = (options?: Options<GetAllDifficultyLevelsData>) =>
  createQueryKey('getAllDifficultyLevels', options);

/**
 * Get all difficulty levels
 * Retrieves all difficulty levels in order.
 */
export const getAllDifficultyLevelsOptions = (options?: Options<GetAllDifficultyLevelsData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getAllDifficultyLevels({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getAllDifficultyLevelsQueryKey(options),
  });
};

export const createDifficultyLevelQueryKey = (options: Options<CreateDifficultyLevelData>) =>
  createQueryKey('createDifficultyLevel', options);

/**
 * Create difficulty level
 * Creates a new difficulty level for course classification.
 */
export const createDifficultyLevelOptions = (options: Options<CreateDifficultyLevelData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await createDifficultyLevel({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: createDifficultyLevelQueryKey(options),
  });
};

/**
 * Create difficulty level
 * Creates a new difficulty level for course classification.
 */
export const createDifficultyLevelMutation = (
  options?: Partial<Options<CreateDifficultyLevelData>>
): UseMutationOptions<
  CreateDifficultyLevelResponse,
  CreateDifficultyLevelError,
  Options<CreateDifficultyLevelData>
> => {
  const mutationOptions: UseMutationOptions<
    CreateDifficultyLevelResponse,
    CreateDifficultyLevelError,
    Options<CreateDifficultyLevelData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await createDifficultyLevel({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const reorderDifficultyLevelsQueryKey = (options: Options<ReorderDifficultyLevelsData>) =>
  createQueryKey('reorderDifficultyLevels', options);

/**
 * Reorder difficulty levels
 * Updates the order of difficulty levels.
 */
export const reorderDifficultyLevelsOptions = (options: Options<ReorderDifficultyLevelsData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await reorderDifficultyLevels({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: reorderDifficultyLevelsQueryKey(options),
  });
};

/**
 * Reorder difficulty levels
 * Updates the order of difficulty levels.
 */
export const reorderDifficultyLevelsMutation = (
  options?: Partial<Options<ReorderDifficultyLevelsData>>
): UseMutationOptions<
  ReorderDifficultyLevelsResponse,
  ReorderDifficultyLevelsError,
  Options<ReorderDifficultyLevelsData>
> => {
  const mutationOptions: UseMutationOptions<
    ReorderDifficultyLevelsResponse,
    ReorderDifficultyLevelsError,
    Options<ReorderDifficultyLevelsData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await reorderDifficultyLevels({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getAllContentTypesQueryKey = (options: Options<GetAllContentTypesData>) =>
  createQueryKey('getAllContentTypes', options);

/**
 * Get all content types
 * Retrieves paginated list of all content types.
 */
export const getAllContentTypesOptions = (options: Options<GetAllContentTypesData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getAllContentTypes({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getAllContentTypesQueryKey(options),
  });
};

export const getAllContentTypesInfiniteQueryKey = (
  options: Options<GetAllContentTypesData>
): QueryKey<Options<GetAllContentTypesData>> => createQueryKey('getAllContentTypes', options, true);

/**
 * Get all content types
 * Retrieves paginated list of all content types.
 */
export const getAllContentTypesInfiniteOptions = (options: Options<GetAllContentTypesData>) => {
  return infiniteQueryOptions<
    GetAllContentTypesResponse,
    GetAllContentTypesError,
    InfiniteData<GetAllContentTypesResponse>,
    QueryKey<Options<GetAllContentTypesData>>,
    | number
    | Pick<QueryKey<Options<GetAllContentTypesData>>[0], 'body' | 'headers' | 'path' | 'query'>
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<GetAllContentTypesData>>[0],
          'body' | 'headers' | 'path' | 'query'
        > =
          typeof pageParam === 'object'
            ? pageParam
            : {
                query: {
                  'pageable.page': pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getAllContentTypes({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: getAllContentTypesInfiniteQueryKey(options),
    }
  );
};

export const createContentTypeQueryKey = (options: Options<CreateContentTypeData>) =>
  createQueryKey('createContentType', options);

/**
 * Create content type
 * Creates a new content type for lesson content classification.
 */
export const createContentTypeOptions = (options: Options<CreateContentTypeData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await createContentType({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: createContentTypeQueryKey(options),
  });
};

/**
 * Create content type
 * Creates a new content type for lesson content classification.
 */
export const createContentTypeMutation = (
  options?: Partial<Options<CreateContentTypeData>>
): UseMutationOptions<
  CreateContentTypeResponse,
  CreateContentTypeError,
  Options<CreateContentTypeData>
> => {
  const mutationOptions: UseMutationOptions<
    CreateContentTypeResponse,
    CreateContentTypeError,
    Options<CreateContentTypeData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await createContentType({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getAllCategoriesQueryKey = (options: Options<GetAllCategoriesData>) =>
  createQueryKey('getAllCategories', options);

/**
 * Get all categories
 * Retrieves paginated list of all categories.
 */
export const getAllCategoriesOptions = (options: Options<GetAllCategoriesData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getAllCategories({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getAllCategoriesQueryKey(options),
  });
};

export const getAllCategoriesInfiniteQueryKey = (
  options: Options<GetAllCategoriesData>
): QueryKey<Options<GetAllCategoriesData>> => createQueryKey('getAllCategories', options, true);

/**
 * Get all categories
 * Retrieves paginated list of all categories.
 */
export const getAllCategoriesInfiniteOptions = (options: Options<GetAllCategoriesData>) => {
  return infiniteQueryOptions<
    GetAllCategoriesResponse,
    GetAllCategoriesError,
    InfiniteData<GetAllCategoriesResponse>,
    QueryKey<Options<GetAllCategoriesData>>,
    number | Pick<QueryKey<Options<GetAllCategoriesData>>[0], 'body' | 'headers' | 'path' | 'query'>
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<GetAllCategoriesData>>[0],
          'body' | 'headers' | 'path' | 'query'
        > =
          typeof pageParam === 'object'
            ? pageParam
            : {
                query: {
                  'pageable.page': pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getAllCategories({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: getAllCategoriesInfiniteQueryKey(options),
    }
  );
};

export const createCategoryQueryKey = (options: Options<CreateCategoryData>) =>
  createQueryKey('createCategory', options);

/**
 * Create category
 * Creates a new category for organizing courses and programs.
 */
export const createCategoryOptions = (options: Options<CreateCategoryData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await createCategory({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: createCategoryQueryKey(options),
  });
};

/**
 * Create category
 * Creates a new category for organizing courses and programs.
 */
export const createCategoryMutation = (
  options?: Partial<Options<CreateCategoryData>>
): UseMutationOptions<CreateCategoryResponse, CreateCategoryError, Options<CreateCategoryData>> => {
  const mutationOptions: UseMutationOptions<
    CreateCategoryResponse,
    CreateCategoryError,
    Options<CreateCategoryData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await createCategory({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const completeCheckoutQueryKey = (options: Options<CompleteCheckoutData>) =>
  createQueryKey('completeCheckout', options);

/**
 * Complete checkout
 * Performs the full checkout flow including customer association and payment selection
 */
export const completeCheckoutOptions = (options: Options<CompleteCheckoutData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await completeCheckout({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: completeCheckoutQueryKey(options),
  });
};

/**
 * Complete checkout
 * Performs the full checkout flow including customer association and payment selection
 */
export const completeCheckoutMutation = (
  options?: Partial<Options<CompleteCheckoutData>>
): UseMutationOptions<
  CompleteCheckoutResponse,
  CompleteCheckoutError,
  Options<CompleteCheckoutData>
> => {
  const mutationOptions: UseMutationOptions<
    CompleteCheckoutResponse,
    CompleteCheckoutError,
    Options<CompleteCheckoutData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await completeCheckout({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const listCatalogItemsQueryKey = (options?: Options<ListCatalogItemsData>) =>
  createQueryKey('listCatalogItems', options);

/**
 * List catalogue mappings
 * Returns catalogue items optionally filtered by active status
 */
export const listCatalogItemsOptions = (options?: Options<ListCatalogItemsData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await listCatalogItems({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: listCatalogItemsQueryKey(options),
  });
};

export const createCatalogItemQueryKey = (options: Options<CreateCatalogItemData>) =>
  createQueryKey('createCatalogItem', options);

/**
 * Create catalogue mapping
 * Creates a catalogue mapping for a course or class
 */
export const createCatalogItemOptions = (options: Options<CreateCatalogItemData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await createCatalogItem({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: createCatalogItemQueryKey(options),
  });
};

/**
 * Create catalogue mapping
 * Creates a catalogue mapping for a course or class
 */
export const createCatalogItemMutation = (
  options?: Partial<Options<CreateCatalogItemData>>
): UseMutationOptions<
  CreateCatalogItemResponse,
  CreateCatalogItemError,
  Options<CreateCatalogItemData>
> => {
  const mutationOptions: UseMutationOptions<
    CreateCatalogItemResponse,
    CreateCatalogItemError,
    Options<CreateCatalogItemData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await createCatalogItem({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const backfillCatalogueQueryKey = (options?: Options<BackfillCatalogueData>) =>
  createQueryKey('backfillCatalogue', options);

/**
 * Backfill catalogue
 * Rebuilds catalogue items for all published courses/classes
 */
export const backfillCatalogueOptions = (options?: Options<BackfillCatalogueData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await backfillCatalogue({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: backfillCatalogueQueryKey(options),
  });
};

/**
 * Backfill catalogue
 * Rebuilds catalogue items for all published courses/classes
 */
export const backfillCatalogueMutation = (
  options?: Partial<Options<BackfillCatalogueData>>
): UseMutationOptions<
  BackfillCatalogueResponse,
  BackfillCatalogueError,
  Options<BackfillCatalogueData>
> => {
  const mutationOptions: UseMutationOptions<
    BackfillCatalogueResponse,
    BackfillCatalogueError,
    Options<BackfillCatalogueData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await backfillCatalogue({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const createCartQueryKey = (options: Options<CreateCartData>) =>
  createQueryKey('createCart', options);

/**
 * Create a new cart
 * Initialises a new cart that can be used for checkout flows
 */
export const createCartOptions = (options: Options<CreateCartData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await createCart({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: createCartQueryKey(options),
  });
};

/**
 * Create a new cart
 * Initialises a new cart that can be used for checkout flows
 */
export const createCartMutation = (
  options?: Partial<Options<CreateCartData>>
): UseMutationOptions<CreateCartResponse, CreateCartError, Options<CreateCartData>> => {
  const mutationOptions: UseMutationOptions<
    CreateCartResponse,
    CreateCartError,
    Options<CreateCartData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await createCart({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const selectPaymentSessionQueryKey = (options: Options<SelectPaymentSessionData>) =>
  createQueryKey('selectPaymentSession', options);

/**
 * Select payment session
 * Locks the cart to a particular payment provider
 */
export const selectPaymentSessionOptions = (options: Options<SelectPaymentSessionData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await selectPaymentSession({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: selectPaymentSessionQueryKey(options),
  });
};

/**
 * Select payment session
 * Locks the cart to a particular payment provider
 */
export const selectPaymentSessionMutation = (
  options?: Partial<Options<SelectPaymentSessionData>>
): UseMutationOptions<
  SelectPaymentSessionResponse,
  SelectPaymentSessionError,
  Options<SelectPaymentSessionData>
> => {
  const mutationOptions: UseMutationOptions<
    SelectPaymentSessionResponse,
    SelectPaymentSessionError,
    Options<SelectPaymentSessionData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await selectPaymentSession({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const addItemQueryKey = (options: Options<AddItemData>) =>
  createQueryKey('addItem', options);

/**
 * Add an item to a cart
 * Adds or increments a line item on an existing cart
 */
export const addItemOptions = (options: Options<AddItemData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await addItem({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: addItemQueryKey(options),
  });
};

/**
 * Add an item to a cart
 * Adds or increments a line item on an existing cart
 */
export const addItemMutation = (
  options?: Partial<Options<AddItemData>>
): UseMutationOptions<AddItemResponse, AddItemError, Options<AddItemData>> => {
  const mutationOptions: UseMutationOptions<AddItemResponse, AddItemError, Options<AddItemData>> = {
    mutationFn: async localOptions => {
      const { data } = await addItem({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const completeCartQueryKey = (options: Options<CompleteCartData>) =>
  createQueryKey('completeCart', options);

/**
 * Complete cart
 * Finalises the cart and creates an order
 */
export const completeCartOptions = (options: Options<CompleteCartData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await completeCart({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: completeCartQueryKey(options),
  });
};

/**
 * Complete cart
 * Finalises the cart and creates an order
 */
export const completeCartMutation = (
  options?: Partial<Options<CompleteCartData>>
): UseMutationOptions<CompleteCartResponse, CompleteCartError, Options<CompleteCartData>> => {
  const mutationOptions: UseMutationOptions<
    CompleteCartResponse,
    CompleteCartError,
    Options<CompleteCartData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await completeCart({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const createClassDefinitionQueryKey = (options: Options<CreateClassDefinitionData>) =>
  createQueryKey('createClassDefinition', options);

/**
 * Create a new class definition
 */
export const createClassDefinitionOptions = (options: Options<CreateClassDefinitionData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await createClassDefinition({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: createClassDefinitionQueryKey(options),
  });
};

/**
 * Create a new class definition
 */
export const createClassDefinitionMutation = (
  options?: Partial<Options<CreateClassDefinitionData>>
): UseMutationOptions<
  CreateClassDefinitionResponse,
  CreateClassDefinitionError,
  Options<CreateClassDefinitionData>
> => {
  const mutationOptions: UseMutationOptions<
    CreateClassDefinitionResponse,
    CreateClassDefinitionError,
    Options<CreateClassDefinitionData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await createClassDefinition({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getQuizSchedulesQueryKey = (options: Options<GetQuizSchedulesData>) =>
  createQueryKey('getQuizSchedules', options);

/**
 * List quiz schedules for a class definition
 */
export const getQuizSchedulesOptions = (options: Options<GetQuizSchedulesData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getQuizSchedules({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getQuizSchedulesQueryKey(options),
  });
};

export const createQuizScheduleQueryKey = (options: Options<CreateQuizScheduleData>) =>
  createQueryKey('createQuizSchedule', options);

/**
 * Create a quiz schedule for a class definition
 */
export const createQuizScheduleOptions = (options: Options<CreateQuizScheduleData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await createQuizSchedule({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: createQuizScheduleQueryKey(options),
  });
};

/**
 * Create a quiz schedule for a class definition
 */
export const createQuizScheduleMutation = (
  options?: Partial<Options<CreateQuizScheduleData>>
): UseMutationOptions<
  CreateQuizScheduleResponse,
  CreateQuizScheduleError,
  Options<CreateQuizScheduleData>
> => {
  const mutationOptions: UseMutationOptions<
    CreateQuizScheduleResponse,
    CreateQuizScheduleError,
    Options<CreateQuizScheduleData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await createQuizSchedule({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getAssignmentSchedulesQueryKey = (options: Options<GetAssignmentSchedulesData>) =>
  createQueryKey('getAssignmentSchedules', options);

/**
 * List assignment schedules for a class definition
 */
export const getAssignmentSchedulesOptions = (options: Options<GetAssignmentSchedulesData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getAssignmentSchedules({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getAssignmentSchedulesQueryKey(options),
  });
};

export const createAssignmentScheduleQueryKey = (options: Options<CreateAssignmentScheduleData>) =>
  createQueryKey('createAssignmentSchedule', options);

/**
 * Create an assignment schedule for a class definition
 */
export const createAssignmentScheduleOptions = (options: Options<CreateAssignmentScheduleData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await createAssignmentSchedule({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: createAssignmentScheduleQueryKey(options),
  });
};

/**
 * Create an assignment schedule for a class definition
 */
export const createAssignmentScheduleMutation = (
  options?: Partial<Options<CreateAssignmentScheduleData>>
): UseMutationOptions<
  CreateAssignmentScheduleResponse,
  CreateAssignmentScheduleError,
  Options<CreateAssignmentScheduleData>
> => {
  const mutationOptions: UseMutationOptions<
    CreateAssignmentScheduleResponse,
    CreateAssignmentScheduleError,
    Options<CreateAssignmentScheduleData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await createAssignmentSchedule({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getAllCertificatesQueryKey = (options: Options<GetAllCertificatesData>) =>
  createQueryKey('getAllCertificates', options);

/**
 * Get all certificates
 * Retrieves paginated list of all certificates with filtering support.
 */
export const getAllCertificatesOptions = (options: Options<GetAllCertificatesData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getAllCertificates({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getAllCertificatesQueryKey(options),
  });
};

export const getAllCertificatesInfiniteQueryKey = (
  options: Options<GetAllCertificatesData>
): QueryKey<Options<GetAllCertificatesData>> => createQueryKey('getAllCertificates', options, true);

/**
 * Get all certificates
 * Retrieves paginated list of all certificates with filtering support.
 */
export const getAllCertificatesInfiniteOptions = (options: Options<GetAllCertificatesData>) => {
  return infiniteQueryOptions<
    GetAllCertificatesResponse,
    GetAllCertificatesError,
    InfiniteData<GetAllCertificatesResponse>,
    QueryKey<Options<GetAllCertificatesData>>,
    | number
    | Pick<QueryKey<Options<GetAllCertificatesData>>[0], 'body' | 'headers' | 'path' | 'query'>
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<GetAllCertificatesData>>[0],
          'body' | 'headers' | 'path' | 'query'
        > =
          typeof pageParam === 'object'
            ? pageParam
            : {
                query: {
                  'pageable.page': pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getAllCertificates({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: getAllCertificatesInfiniteQueryKey(options),
    }
  );
};

export const createCertificateQueryKey = (options: Options<CreateCertificateData>) =>
  createQueryKey('createCertificate', options);

/**
 * Create a new certificate
 * Manually creates a certificate record with automatic number generation.
 */
export const createCertificateOptions = (options: Options<CreateCertificateData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await createCertificate({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: createCertificateQueryKey(options),
  });
};

/**
 * Create a new certificate
 * Manually creates a certificate record with automatic number generation.
 */
export const createCertificateMutation = (
  options?: Partial<Options<CreateCertificateData>>
): UseMutationOptions<
  CreateCertificateResponse,
  CreateCertificateError,
  Options<CreateCertificateData>
> => {
  const mutationOptions: UseMutationOptions<
    CreateCertificateResponse,
    CreateCertificateError,
    Options<CreateCertificateData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await createCertificate({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const uploadCertificatePdfQueryKey = (options: Options<UploadCertificatePdfData>) =>
  createQueryKey('uploadCertificatePdf', options);

/**
 * Upload certificate PDF
 * Uploads an externally generated certificate PDF file for an existing certificate record and updates its download URL.
 *
 * **File requirements:**
 * - Must be a PDF (`application/pdf`).
 * - Stored via the platform StorageService under the `certificates` folder.
 *
 * Frontend clients should call this after a certificate record exists, then use the returned `certificate_url`
 * to power download links in student dashboards and admin UIs.
 *
 */
export const uploadCertificatePdfOptions = (options: Options<UploadCertificatePdfData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await uploadCertificatePdf({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: uploadCertificatePdfQueryKey(options),
  });
};

/**
 * Upload certificate PDF
 * Uploads an externally generated certificate PDF file for an existing certificate record and updates its download URL.
 *
 * **File requirements:**
 * - Must be a PDF (`application/pdf`).
 * - Stored via the platform StorageService under the `certificates` folder.
 *
 * Frontend clients should call this after a certificate record exists, then use the returned `certificate_url`
 * to power download links in student dashboards and admin UIs.
 *
 */
export const uploadCertificatePdfMutation = (
  options?: Partial<Options<UploadCertificatePdfData>>
): UseMutationOptions<
  UploadCertificatePdfResponse,
  UploadCertificatePdfError,
  Options<UploadCertificatePdfData>
> => {
  const mutationOptions: UseMutationOptions<
    UploadCertificatePdfResponse,
    UploadCertificatePdfError,
    Options<UploadCertificatePdfData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await uploadCertificatePdf({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const revokeCertificateQueryKey = (options: Options<RevokeCertificateData>) =>
  createQueryKey('revokeCertificate', options);

/**
 * Revoke certificate
 * Revokes a certificate with reason, making it invalid.
 */
export const revokeCertificateOptions = (options: Options<RevokeCertificateData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await revokeCertificate({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: revokeCertificateQueryKey(options),
  });
};

/**
 * Revoke certificate
 * Revokes a certificate with reason, making it invalid.
 */
export const revokeCertificateMutation = (
  options?: Partial<Options<RevokeCertificateData>>
): UseMutationOptions<
  RevokeCertificateResponse,
  RevokeCertificateError,
  Options<RevokeCertificateData>
> => {
  const mutationOptions: UseMutationOptions<
    RevokeCertificateResponse,
    RevokeCertificateError,
    Options<RevokeCertificateData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await revokeCertificate({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const generateCertificateUrlQueryKey = (options: Options<GenerateCertificateUrlData>) =>
  createQueryKey('generateCertificateUrl', options);

/**
 * Generate certificate URL
 * Generates and updates the downloadable URL for a certificate.
 */
export const generateCertificateUrlOptions = (options: Options<GenerateCertificateUrlData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await generateCertificateUrl({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: generateCertificateUrlQueryKey(options),
  });
};

/**
 * Generate certificate URL
 * Generates and updates the downloadable URL for a certificate.
 */
export const generateCertificateUrlMutation = (
  options?: Partial<Options<GenerateCertificateUrlData>>
): UseMutationOptions<
  GenerateCertificateUrlResponse,
  GenerateCertificateUrlError,
  Options<GenerateCertificateUrlData>
> => {
  const mutationOptions: UseMutationOptions<
    GenerateCertificateUrlResponse,
    GenerateCertificateUrlError,
    Options<GenerateCertificateUrlData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await generateCertificateUrl({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getCertificateTemplatesQueryKey = (options: Options<GetCertificateTemplatesData>) =>
  createQueryKey('getCertificateTemplates', options);

/**
 * Get certificate templates
 * Retrieves all available certificate templates.
 */
export const getCertificateTemplatesOptions = (options: Options<GetCertificateTemplatesData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getCertificateTemplates({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getCertificateTemplatesQueryKey(options),
  });
};

export const getCertificateTemplatesInfiniteQueryKey = (
  options: Options<GetCertificateTemplatesData>
): QueryKey<Options<GetCertificateTemplatesData>> =>
  createQueryKey('getCertificateTemplates', options, true);

/**
 * Get certificate templates
 * Retrieves all available certificate templates.
 */
export const getCertificateTemplatesInfiniteOptions = (
  options: Options<GetCertificateTemplatesData>
) => {
  return infiniteQueryOptions<
    GetCertificateTemplatesResponse,
    GetCertificateTemplatesError,
    InfiniteData<GetCertificateTemplatesResponse>,
    QueryKey<Options<GetCertificateTemplatesData>>,
    | number
    | Pick<QueryKey<Options<GetCertificateTemplatesData>>[0], 'body' | 'headers' | 'path' | 'query'>
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<GetCertificateTemplatesData>>[0],
          'body' | 'headers' | 'path' | 'query'
        > =
          typeof pageParam === 'object'
            ? pageParam
            : {
                query: {
                  'pageable.page': pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getCertificateTemplates({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: getCertificateTemplatesInfiniteQueryKey(options),
    }
  );
};

export const createCertificateTemplateQueryKey = (
  options: Options<CreateCertificateTemplateData>
) => createQueryKey('createCertificateTemplate', options);

/**
 * Create certificate template
 * Creates a new certificate template for generating certificates.
 */
export const createCertificateTemplateOptions = (
  options: Options<CreateCertificateTemplateData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await createCertificateTemplate({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: createCertificateTemplateQueryKey(options),
  });
};

/**
 * Create certificate template
 * Creates a new certificate template for generating certificates.
 */
export const createCertificateTemplateMutation = (
  options?: Partial<Options<CreateCertificateTemplateData>>
): UseMutationOptions<
  CreateCertificateTemplateResponse,
  CreateCertificateTemplateError,
  Options<CreateCertificateTemplateData>
> => {
  const mutationOptions: UseMutationOptions<
    CreateCertificateTemplateResponse,
    CreateCertificateTemplateError,
    Options<CreateCertificateTemplateData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await createCertificateTemplate({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const generateProgramCertificateQueryKey = (
  options: Options<GenerateProgramCertificateData>
) => createQueryKey('generateProgramCertificate', options);

/**
 * Generate program certificate
 * Automatically generates a certificate upon program completion.
 */
export const generateProgramCertificateOptions = (
  options: Options<GenerateProgramCertificateData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await generateProgramCertificate({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: generateProgramCertificateQueryKey(options),
  });
};

/**
 * Generate program certificate
 * Automatically generates a certificate upon program completion.
 */
export const generateProgramCertificateMutation = (
  options?: Partial<Options<GenerateProgramCertificateData>>
): UseMutationOptions<
  GenerateProgramCertificateResponse,
  GenerateProgramCertificateError,
  Options<GenerateProgramCertificateData>
> => {
  const mutationOptions: UseMutationOptions<
    GenerateProgramCertificateResponse,
    GenerateProgramCertificateError,
    Options<GenerateProgramCertificateData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await generateProgramCertificate({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const generateCourseCertificateQueryKey = (
  options: Options<GenerateCourseCertificateData>
) => createQueryKey('generateCourseCertificate', options);

/**
 * Generate course certificate
 * Automatically generates a certificate upon course completion.
 */
export const generateCourseCertificateOptions = (
  options: Options<GenerateCourseCertificateData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await generateCourseCertificate({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: generateCourseCertificateQueryKey(options),
  });
};

/**
 * Generate course certificate
 * Automatically generates a certificate upon course completion.
 */
export const generateCourseCertificateMutation = (
  options?: Partial<Options<GenerateCourseCertificateData>>
): UseMutationOptions<
  GenerateCourseCertificateResponse,
  GenerateCourseCertificateError,
  Options<GenerateCourseCertificateData>
> => {
  const mutationOptions: UseMutationOptions<
    GenerateCourseCertificateResponse,
    GenerateCourseCertificateError,
    Options<GenerateCourseCertificateData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await generateCourseCertificate({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const createBookingQueryKey = (options: Options<CreateBookingData>) =>
  createQueryKey('createBooking', options);

/**
 * Create a booking for a course/instructor slot
 */
export const createBookingOptions = (options: Options<CreateBookingData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await createBooking({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: createBookingQueryKey(options),
  });
};

/**
 * Create a booking for a course/instructor slot
 */
export const createBookingMutation = (
  options?: Partial<Options<CreateBookingData>>
): UseMutationOptions<CreateBookingResponse, CreateBookingError, Options<CreateBookingData>> => {
  const mutationOptions: UseMutationOptions<
    CreateBookingResponse,
    CreateBookingError,
    Options<CreateBookingData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await createBooking({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const requestPaymentQueryKey = (options: Options<RequestPaymentData>) =>
  createQueryKey('requestPayment', options);

/**
 * Request payment for a booking
 */
export const requestPaymentOptions = (options: Options<RequestPaymentData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await requestPayment({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: requestPaymentQueryKey(options),
  });
};

/**
 * Request payment for a booking
 */
export const requestPaymentMutation = (
  options?: Partial<Options<RequestPaymentData>>
): UseMutationOptions<RequestPaymentResponse, RequestPaymentError, Options<RequestPaymentData>> => {
  const mutationOptions: UseMutationOptions<
    RequestPaymentResponse,
    RequestPaymentError,
    Options<RequestPaymentData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await requestPayment({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const paymentCallbackQueryKey = (options: Options<PaymentCallbackData>) =>
  createQueryKey('paymentCallback', options);

/**
 * Payment callback to update booking status
 */
export const paymentCallbackOptions = (options: Options<PaymentCallbackData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await paymentCallback({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: paymentCallbackQueryKey(options),
  });
};

/**
 * Payment callback to update booking status
 */
export const paymentCallbackMutation = (
  options?: Partial<Options<PaymentCallbackData>>
): UseMutationOptions<
  PaymentCallbackResponse,
  PaymentCallbackError,
  Options<PaymentCallbackData>
> => {
  const mutationOptions: UseMutationOptions<
    PaymentCallbackResponse,
    PaymentCallbackError,
    Options<PaymentCallbackData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await paymentCallback({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const cancelBookingQueryKey = (options: Options<CancelBookingData>) =>
  createQueryKey('cancelBooking', options);

/**
 * Cancel a booking and release the reserved slot
 */
export const cancelBookingOptions = (options: Options<CancelBookingData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await cancelBooking({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: cancelBookingQueryKey(options),
  });
};

/**
 * Cancel a booking and release the reserved slot
 */
export const cancelBookingMutation = (
  options?: Partial<Options<CancelBookingData>>
): UseMutationOptions<CancelBookingResponse, CancelBookingError, Options<CancelBookingData>> => {
  const mutationOptions: UseMutationOptions<
    CancelBookingResponse,
    CancelBookingError,
    Options<CancelBookingData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await cancelBooking({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getAllAssignmentsQueryKey = (options: Options<GetAllAssignmentsData>) =>
  createQueryKey('getAllAssignments', options);

/**
 * Get all assignments
 * Retrieves paginated list of all assignments with filtering support.
 */
export const getAllAssignmentsOptions = (options: Options<GetAllAssignmentsData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getAllAssignments({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getAllAssignmentsQueryKey(options),
  });
};

export const getAllAssignmentsInfiniteQueryKey = (
  options: Options<GetAllAssignmentsData>
): QueryKey<Options<GetAllAssignmentsData>> => createQueryKey('getAllAssignments', options, true);

/**
 * Get all assignments
 * Retrieves paginated list of all assignments with filtering support.
 */
export const getAllAssignmentsInfiniteOptions = (options: Options<GetAllAssignmentsData>) => {
  return infiniteQueryOptions<
    GetAllAssignmentsResponse,
    GetAllAssignmentsError,
    InfiniteData<GetAllAssignmentsResponse>,
    QueryKey<Options<GetAllAssignmentsData>>,
    | number
    | Pick<QueryKey<Options<GetAllAssignmentsData>>[0], 'body' | 'headers' | 'path' | 'query'>
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<GetAllAssignmentsData>>[0],
          'body' | 'headers' | 'path' | 'query'
        > =
          typeof pageParam === 'object'
            ? pageParam
            : {
                query: {
                  'pageable.page': pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getAllAssignments({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: getAllAssignmentsInfiniteQueryKey(options),
    }
  );
};

export const createAssignmentQueryKey = (options: Options<CreateAssignmentData>) =>
  createQueryKey('createAssignment', options);

/**
 * Create a new assignment
 * Creates a new assignment with default DRAFT status and inactive state.
 */
export const createAssignmentOptions = (options: Options<CreateAssignmentData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await createAssignment({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: createAssignmentQueryKey(options),
  });
};

/**
 * Create a new assignment
 * Creates a new assignment with default DRAFT status and inactive state.
 */
export const createAssignmentMutation = (
  options?: Partial<Options<CreateAssignmentData>>
): UseMutationOptions<
  CreateAssignmentResponse,
  CreateAssignmentError,
  Options<CreateAssignmentData>
> => {
  const mutationOptions: UseMutationOptions<
    CreateAssignmentResponse,
    CreateAssignmentError,
    Options<CreateAssignmentData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await createAssignment({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const submitAssignmentQueryKey = (options: Options<SubmitAssignmentData>) =>
  createQueryKey('submitAssignment', options);

/**
 * Submit assignment
 * Creates a new submission for an assignment by a student.
 */
export const submitAssignmentOptions = (options: Options<SubmitAssignmentData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await submitAssignment({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: submitAssignmentQueryKey(options),
  });
};

/**
 * Submit assignment
 * Creates a new submission for an assignment by a student.
 */
export const submitAssignmentMutation = (
  options?: Partial<Options<SubmitAssignmentData>>
): UseMutationOptions<
  SubmitAssignmentResponse,
  SubmitAssignmentError,
  Options<SubmitAssignmentData>
> => {
  const mutationOptions: UseMutationOptions<
    SubmitAssignmentResponse,
    SubmitAssignmentError,
    Options<SubmitAssignmentData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await submitAssignment({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const returnSubmissionQueryKey = (options: Options<ReturnSubmissionData>) =>
  createQueryKey('returnSubmission', options);

/**
 * Return submission for revision
 * Returns a submission to student with feedback for revision.
 */
export const returnSubmissionOptions = (options: Options<ReturnSubmissionData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await returnSubmission({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: returnSubmissionQueryKey(options),
  });
};

/**
 * Return submission for revision
 * Returns a submission to student with feedback for revision.
 */
export const returnSubmissionMutation = (
  options?: Partial<Options<ReturnSubmissionData>>
): UseMutationOptions<
  ReturnSubmissionResponse,
  ReturnSubmissionError,
  Options<ReturnSubmissionData>
> => {
  const mutationOptions: UseMutationOptions<
    ReturnSubmissionResponse,
    ReturnSubmissionError,
    Options<ReturnSubmissionData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await returnSubmission({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const gradeSubmissionQueryKey = (options: Options<GradeSubmissionData>) =>
  createQueryKey('gradeSubmission', options);

/**
 * Grade submission
 * Grades a student's assignment submission with score and comments.
 */
export const gradeSubmissionOptions = (options: Options<GradeSubmissionData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await gradeSubmission({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: gradeSubmissionQueryKey(options),
  });
};

/**
 * Grade submission
 * Grades a student's assignment submission with score and comments.
 */
export const gradeSubmissionMutation = (
  options?: Partial<Options<GradeSubmissionData>>
): UseMutationOptions<
  GradeSubmissionResponse,
  GradeSubmissionError,
  Options<GradeSubmissionData>
> => {
  const mutationOptions: UseMutationOptions<
    GradeSubmissionResponse,
    GradeSubmissionError,
    Options<GradeSubmissionData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await gradeSubmission({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const assignAdminDomainQueryKey = (options: Options<AssignAdminDomainData>) =>
  createQueryKey('assignAdminDomain', options);

/**
 * Assign admin domain to user
 * Assigns admin domain privileges to a user. This grants the user administrative access either globally (system admin) or within specific organizational contexts. Only existing system administrators can perform this operation.
 */
export const assignAdminDomainOptions = (options: Options<AssignAdminDomainData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await assignAdminDomain({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: assignAdminDomainQueryKey(options),
  });
};

/**
 * Assign admin domain to user
 * Assigns admin domain privileges to a user. This grants the user administrative access either globally (system admin) or within specific organizational contexts. Only existing system administrators can perform this operation.
 */
export const assignAdminDomainMutation = (
  options?: Partial<Options<AssignAdminDomainData>>
): UseMutationOptions<
  AssignAdminDomainResponse,
  AssignAdminDomainError,
  Options<AssignAdminDomainData>
> => {
  const mutationOptions: UseMutationOptions<
    AssignAdminDomainResponse,
    AssignAdminDomainError,
    Options<AssignAdminDomainData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await assignAdminDomain({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getAdminUsersQueryKey = (options: Options<GetAdminUsersData>) =>
  createQueryKey('getAdminUsers', options);

/**
 * Get all admin users
 * Retrieves a paginated list of all users with administrative privileges. Includes both system administrators and organization administrators. Supports filtering by admin level, status, and other criteria.
 */
export const getAdminUsersOptions = (options: Options<GetAdminUsersData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getAdminUsers({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getAdminUsersQueryKey(options),
  });
};

export const getAdminUsersInfiniteQueryKey = (
  options: Options<GetAdminUsersData>
): QueryKey<Options<GetAdminUsersData>> => createQueryKey('getAdminUsers', options, true);

/**
 * Get all admin users
 * Retrieves a paginated list of all users with administrative privileges. Includes both system administrators and organization administrators. Supports filtering by admin level, status, and other criteria.
 */
export const getAdminUsersInfiniteOptions = (options: Options<GetAdminUsersData>) => {
  return infiniteQueryOptions<
    GetAdminUsersResponse,
    GetAdminUsersError,
    InfiniteData<GetAdminUsersResponse>,
    QueryKey<Options<GetAdminUsersData>>,
    number | Pick<QueryKey<Options<GetAdminUsersData>>[0], 'body' | 'headers' | 'path' | 'query'>
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<GetAdminUsersData>>[0],
          'body' | 'headers' | 'path' | 'query'
        > =
          typeof pageParam === 'object'
            ? pageParam
            : {
                query: {
                  'pageable.page': pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getAdminUsers({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: getAdminUsersInfiniteQueryKey(options),
    }
  );
};

export const createAdminUserQueryKey = (options: Options<CreateAdminUserData>) =>
  createQueryKey('createAdminUser', options);

/**
 * Create a new admin user
 * Creates a new admin user in Keycloak and the local database. If the email already exists in Keycloak, an error is returned so the client can instead promote the existing user using domain assignment.
 */
export const createAdminUserOptions = (options: Options<CreateAdminUserData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await createAdminUser({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: createAdminUserQueryKey(options),
  });
};

/**
 * Create a new admin user
 * Creates a new admin user in Keycloak and the local database. If the email already exists in Keycloak, an error is returned so the client can instead promote the existing user using domain assignment.
 */
export const createAdminUserMutation = (
  options?: Partial<Options<CreateAdminUserData>>
): UseMutationOptions<
  CreateAdminUserResponse,
  CreateAdminUserError,
  Options<CreateAdminUserData>
> => {
  const mutationOptions: UseMutationOptions<
    CreateAdminUserResponse,
    CreateAdminUserError,
    Options<CreateAdminUserData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await createAdminUser({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const moderateOrganisationQueryKey = (options: Options<ModerateOrganisationData>) =>
  createQueryKey('moderateOrganisation', options);

/**
 * Moderate organization verification
 * Handles organization approval workflows using a single endpoint. Supports approving, rejecting, or revoking admin verification status.
 */
export const moderateOrganisationOptions = (options: Options<ModerateOrganisationData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await moderateOrganisation({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: moderateOrganisationQueryKey(options),
  });
};

/**
 * Moderate organization verification
 * Handles organization approval workflows using a single endpoint. Supports approving, rejecting, or revoking admin verification status.
 */
export const moderateOrganisationMutation = (
  options?: Partial<Options<ModerateOrganisationData>>
): UseMutationOptions<
  ModerateOrganisationResponse,
  ModerateOrganisationError,
  Options<ModerateOrganisationData>
> => {
  const mutationOptions: UseMutationOptions<
    ModerateOrganisationResponse,
    ModerateOrganisationError,
    Options<ModerateOrganisationData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await moderateOrganisation({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const createOrganisationUserQueryKey = (options: Options<CreateOrganisationUserData>) =>
  createQueryKey('createOrganisationUser', options);

/**
 * Create a new organisation user with domain
 * Creates a new user, provisions them in Keycloak, assigns them to the organisation with the specified domain and optional branch. If the email already exists in Keycloak or locally, an error is returned so the client can use the existing email to assign roles instead.
 */
export const createOrganisationUserOptions = (options: Options<CreateOrganisationUserData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await createOrganisationUser({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: createOrganisationUserQueryKey(options),
  });
};

/**
 * Create a new organisation user with domain
 * Creates a new user, provisions them in Keycloak, assigns them to the organisation with the specified domain and optional branch. If the email already exists in Keycloak or locally, an error is returned so the client can use the existing email to assign roles instead.
 */
export const createOrganisationUserMutation = (
  options?: Partial<Options<CreateOrganisationUserData>>
): UseMutationOptions<
  CreateOrganisationUserResponse,
  CreateOrganisationUserError,
  Options<CreateOrganisationUserData>
> => {
  const mutationOptions: UseMutationOptions<
    CreateOrganisationUserResponse,
    CreateOrganisationUserError,
    Options<CreateOrganisationUserData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await createOrganisationUser({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const verifyInstructorQueryKey = (options: Options<VerifyInstructorData>) =>
  createQueryKey('verifyInstructor', options);

/**
 * Verify an instructor
 * Verifies/approves an instructor by setting the admin_verified flag to true. Only system administrators can perform this operation. Verified instructors gain access to additional platform features and display verification badges.
 */
export const verifyInstructorOptions = (options: Options<VerifyInstructorData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await verifyInstructor({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: verifyInstructorQueryKey(options),
  });
};

/**
 * Verify an instructor
 * Verifies/approves an instructor by setting the admin_verified flag to true. Only system administrators can perform this operation. Verified instructors gain access to additional platform features and display verification badges.
 */
export const verifyInstructorMutation = (
  options?: Partial<Options<VerifyInstructorData>>
): UseMutationOptions<
  VerifyInstructorResponse,
  VerifyInstructorError,
  Options<VerifyInstructorData>
> => {
  const mutationOptions: UseMutationOptions<
    VerifyInstructorResponse,
    VerifyInstructorError,
    Options<VerifyInstructorData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await verifyInstructor({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const unverifyInstructorQueryKey = (options: Options<UnverifyInstructorData>) =>
  createQueryKey('unverifyInstructor', options);

/**
 * Remove verification from an instructor
 * Removes verification from an instructor by setting the admin_verified flag to false. Only system administrators can perform this operation. This may revoke access to certain platform features.
 */
export const unverifyInstructorOptions = (options: Options<UnverifyInstructorData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await unverifyInstructor({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: unverifyInstructorQueryKey(options),
  });
};

/**
 * Remove verification from an instructor
 * Removes verification from an instructor by setting the admin_verified flag to false. Only system administrators can perform this operation. This may revoke access to certain platform features.
 */
export const unverifyInstructorMutation = (
  options?: Partial<Options<UnverifyInstructorData>>
): UseMutationOptions<
  UnverifyInstructorResponse,
  UnverifyInstructorError,
  Options<UnverifyInstructorData>
> => {
  const mutationOptions: UseMutationOptions<
    UnverifyInstructorResponse,
    UnverifyInstructorError,
    Options<UnverifyInstructorData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await unverifyInstructor({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const listAllQueryKey = (options?: Options<ListAllData>) =>
  createQueryKey('listAll', options);

/**
 * List all platform currencies (active and inactive)
 */
export const listAllOptions = (options?: Options<ListAllData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await listAll({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: listAllQueryKey(options),
  });
};

export const createCurrencyQueryKey = (options: Options<CreateCurrencyData>) =>
  createQueryKey('createCurrency', options);

/**
 * Register a new currency
 */
export const createCurrencyOptions = (options: Options<CreateCurrencyData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await createCurrency({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: createCurrencyQueryKey(options),
  });
};

/**
 * Register a new currency
 */
export const createCurrencyMutation = (
  options?: Partial<Options<CreateCurrencyData>>
): UseMutationOptions<CreateCurrencyResponse, CreateCurrencyError, Options<CreateCurrencyData>> => {
  const mutationOptions: UseMutationOptions<
    CreateCurrencyResponse,
    CreateCurrencyError,
    Options<CreateCurrencyData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await createCurrency({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const makeDefaultQueryKey = (options: Options<MakeDefaultData>) =>
  createQueryKey('makeDefault', options);

/**
 * Set the default platform currency
 */
export const makeDefaultOptions = (options: Options<MakeDefaultData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await makeDefault({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: makeDefaultQueryKey(options),
  });
};

/**
 * Set the default platform currency
 */
export const makeDefaultMutation = (
  options?: Partial<Options<MakeDefaultData>>
): UseMutationOptions<MakeDefaultResponse, MakeDefaultError, Options<MakeDefaultData>> => {
  const mutationOptions: UseMutationOptions<
    MakeDefaultResponse,
    MakeDefaultError,
    Options<MakeDefaultData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await makeDefault({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const deactivateQueryKey = (options: Options<DeactivateData>) =>
  createQueryKey('deactivate', options);

/**
 * Deactivate a currency, preventing new use on the platform
 */
export const deactivateOptions = (options: Options<DeactivateData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await deactivate({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: deactivateQueryKey(options),
  });
};

/**
 * Deactivate a currency, preventing new use on the platform
 */
export const deactivateMutation = (
  options?: Partial<Options<DeactivateData>>
): UseMutationOptions<DeactivateResponse, DeactivateError, Options<DeactivateData>> => {
  const mutationOptions: UseMutationOptions<
    DeactivateResponse,
    DeactivateError,
    Options<DeactivateData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await deactivate({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const activateQueryKey = (options: Options<ActivateData>) =>
  createQueryKey('activate', options);

/**
 * Activate a currency for use on the platform
 */
export const activateOptions = (options: Options<ActivateData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await activate({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: activateQueryKey(options),
  });
};

/**
 * Activate a currency for use on the platform
 */
export const activateMutation = (
  options?: Partial<Options<ActivateData>>
): UseMutationOptions<ActivateResponse, ActivateError, Options<ActivateData>> => {
  const mutationOptions: UseMutationOptions<
    ActivateResponse,
    ActivateError,
    Options<ActivateData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await activate({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Update the status of a scheduled instance
 */
export const updateScheduledInstanceStatusMutation = (
  options?: Partial<Options<UpdateScheduledInstanceStatusData>>
): UseMutationOptions<
  UpdateScheduledInstanceStatusResponse,
  UpdateScheduledInstanceStatusError,
  Options<UpdateScheduledInstanceStatusData>
> => {
  const mutationOptions: UseMutationOptions<
    UpdateScheduledInstanceStatusResponse,
    UpdateScheduledInstanceStatusError,
    Options<UpdateScheduledInstanceStatusData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await updateScheduledInstanceStatus({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Reorder scoring levels
 * Updates the display order of scoring levels within the rubric. Provide a map of level UUIDs to their new order values.
 */
export const reorderScoringLevelsMutation = (
  options?: Partial<Options<ReorderScoringLevelsData>>
): UseMutationOptions<
  ReorderScoringLevelsResponse,
  ReorderScoringLevelsError,
  Options<ReorderScoringLevelsData>
> => {
  const mutationOptions: UseMutationOptions<
    ReorderScoringLevelsResponse,
    ReorderScoringLevelsError,
    Options<ReorderScoringLevelsData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await reorderScoringLevels({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Mark attendance for a student enrollment
 */
export const markAttendanceMutation = (
  options?: Partial<Options<MarkAttendanceData>>
): UseMutationOptions<MarkAttendanceResponse, MarkAttendanceError, Options<MarkAttendanceData>> => {
  const mutationOptions: UseMutationOptions<
    MarkAttendanceResponse,
    MarkAttendanceError,
    Options<MarkAttendanceData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await markAttendance({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getCartQueryKey = (options: Options<GetCartData>) =>
  createQueryKey('getCart', options);

/**
 * Retrieve cart details
 * Fetches the latest cart representation
 */
export const getCartOptions = (options: Options<GetCartData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getCart({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getCartQueryKey(options),
  });
};

/**
 * Update cart attributes
 * Updates cart details such as customer or addresses
 */
export const updateCartMutation = (
  options?: Partial<Options<UpdateCartData>>
): UseMutationOptions<UpdateCartResponse, UpdateCartError, Options<UpdateCartData>> => {
  const mutationOptions: UseMutationOptions<
    UpdateCartResponse,
    UpdateCartError,
    Options<UpdateCartData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await updateCart({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Delete a quiz schedule for a class definition
 */
export const deleteQuizScheduleMutation = (
  options?: Partial<Options<DeleteQuizScheduleData>>
): UseMutationOptions<unknown, DeleteQuizScheduleError, Options<DeleteQuizScheduleData>> => {
  const mutationOptions: UseMutationOptions<
    unknown,
    DeleteQuizScheduleError,
    Options<DeleteQuizScheduleData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await deleteQuizSchedule({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Update a quiz schedule for a class definition
 */
export const updateQuizScheduleMutation = (
  options?: Partial<Options<UpdateQuizScheduleData>>
): UseMutationOptions<
  UpdateQuizScheduleResponse,
  UpdateQuizScheduleError,
  Options<UpdateQuizScheduleData>
> => {
  const mutationOptions: UseMutationOptions<
    UpdateQuizScheduleResponse,
    UpdateQuizScheduleError,
    Options<UpdateQuizScheduleData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await updateQuizSchedule({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Delete an assignment schedule for a class definition
 */
export const deleteAssignmentScheduleMutation = (
  options?: Partial<Options<DeleteAssignmentScheduleData>>
): UseMutationOptions<
  unknown,
  DeleteAssignmentScheduleError,
  Options<DeleteAssignmentScheduleData>
> => {
  const mutationOptions: UseMutationOptions<
    unknown,
    DeleteAssignmentScheduleError,
    Options<DeleteAssignmentScheduleData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await deleteAssignmentSchedule({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Update an assignment schedule for a class definition
 */
export const updateAssignmentScheduleMutation = (
  options?: Partial<Options<UpdateAssignmentScheduleData>>
): UseMutationOptions<
  UpdateAssignmentScheduleResponse,
  UpdateAssignmentScheduleError,
  Options<UpdateAssignmentScheduleData>
> => {
  const mutationOptions: UseMutationOptions<
    UpdateAssignmentScheduleResponse,
    UpdateAssignmentScheduleError,
    Options<UpdateAssignmentScheduleData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await updateAssignmentSchedule({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getAllUsersQueryKey = (options: Options<GetAllUsersData>) =>
  createQueryKey('getAllUsers', options);

/**
 * Get all users
 * Fetches a paginated list of all users in the system. Supports pagination and sorting by any user field.
 */
export const getAllUsersOptions = (options: Options<GetAllUsersData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getAllUsers({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getAllUsersQueryKey(options),
  });
};

export const getAllUsersInfiniteQueryKey = (
  options: Options<GetAllUsersData>
): QueryKey<Options<GetAllUsersData>> => createQueryKey('getAllUsers', options, true);

/**
 * Get all users
 * Fetches a paginated list of all users in the system. Supports pagination and sorting by any user field.
 */
export const getAllUsersInfiniteOptions = (options: Options<GetAllUsersData>) => {
  return infiniteQueryOptions<
    GetAllUsersResponse,
    GetAllUsersError,
    InfiniteData<GetAllUsersResponse>,
    QueryKey<Options<GetAllUsersData>>,
    number | Pick<QueryKey<Options<GetAllUsersData>>[0], 'body' | 'headers' | 'path' | 'query'>
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<GetAllUsersData>>[0],
          'body' | 'headers' | 'path' | 'query'
        > =
          typeof pageParam === 'object'
            ? pageParam
            : {
                query: {
                  'pageable.page': pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getAllUsers({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: getAllUsersInfiniteQueryKey(options),
    }
  );
};

export const searchQueryKey = (options: Options<SearchData>) => createQueryKey('search', options);

/**
 * Search users
 * Fetches a paginated list of users based on optional filters. Supports pagination and sorting.
 */
export const searchOptions = (options: Options<SearchData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await search({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: searchQueryKey(options),
  });
};

export const searchInfiniteQueryKey = (
  options: Options<SearchData>
): QueryKey<Options<SearchData>> => createQueryKey('search', options, true);

/**
 * Search users
 * Fetches a paginated list of users based on optional filters. Supports pagination and sorting.
 */
export const searchInfiniteOptions = (options: Options<SearchData>) => {
  return infiniteQueryOptions<
    SearchResponse,
    SearchError,
    InfiniteData<SearchResponse>,
    QueryKey<Options<SearchData>>,
    number | Pick<QueryKey<Options<SearchData>>[0], 'body' | 'headers' | 'path' | 'query'>
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<SearchData>>[0], 'body' | 'headers' | 'path' | 'query'> =
          typeof pageParam === 'object'
            ? pageParam
            : {
                query: {
                  'pageable.page': pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await search({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: searchInfiniteQueryKey(options),
    }
  );
};

export const getProfileImageQueryKey = (options: Options<GetProfileImageData>) =>
  createQueryKey('getProfileImage', options);

/**
 * Get user profile image by file name
 */
export const getProfileImageOptions = (options: Options<GetProfileImageData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getProfileImage({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getProfileImageQueryKey(options),
  });
};

export const search1QueryKey = (options: Options<Search1Data>) =>
  createQueryKey('search1', options);

/**
 * Search training branches
 * Fetches a paginated list of training branches based on optional filters. Supports pagination and sorting.
 */
export const search1Options = (options: Options<Search1Data>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await search1({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: search1QueryKey(options),
  });
};

export const search1InfiniteQueryKey = (
  options: Options<Search1Data>
): QueryKey<Options<Search1Data>> => createQueryKey('search1', options, true);

/**
 * Search training branches
 * Fetches a paginated list of training branches based on optional filters. Supports pagination and sorting.
 */
export const search1InfiniteOptions = (options: Options<Search1Data>) => {
  return infiniteQueryOptions<
    Search1Response,
    Search1Error,
    InfiniteData<Search1Response>,
    QueryKey<Options<Search1Data>>,
    number | Pick<QueryKey<Options<Search1Data>>[0], 'body' | 'headers' | 'path' | 'query'>
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<Search1Data>>[0], 'body' | 'headers' | 'path' | 'query'> =
          typeof pageParam === 'object'
            ? pageParam
            : {
                query: {
                  'pageable.page': pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await search1({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: search1InfiniteQueryKey(options),
    }
  );
};

export const getTrainingBranchesByOrganisation1QueryKey = (
  options: Options<GetTrainingBranchesByOrganisation1Data>
) => createQueryKey('getTrainingBranchesByOrganisation1', options);

/**
 * Get training branches by organisation UUID
 */
export const getTrainingBranchesByOrganisation1Options = (
  options: Options<GetTrainingBranchesByOrganisation1Data>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getTrainingBranchesByOrganisation1({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getTrainingBranchesByOrganisation1QueryKey(options),
  });
};

export const getTrainingBranchesByOrganisation1InfiniteQueryKey = (
  options: Options<GetTrainingBranchesByOrganisation1Data>
): QueryKey<Options<GetTrainingBranchesByOrganisation1Data>> =>
  createQueryKey('getTrainingBranchesByOrganisation1', options, true);

/**
 * Get training branches by organisation UUID
 */
export const getTrainingBranchesByOrganisation1InfiniteOptions = (
  options: Options<GetTrainingBranchesByOrganisation1Data>
) => {
  return infiniteQueryOptions<
    GetTrainingBranchesByOrganisation1Response,
    GetTrainingBranchesByOrganisation1Error,
    InfiniteData<GetTrainingBranchesByOrganisation1Response>,
    QueryKey<Options<GetTrainingBranchesByOrganisation1Data>>,
    | number
    | Pick<
        QueryKey<Options<GetTrainingBranchesByOrganisation1Data>>[0],
        'body' | 'headers' | 'path' | 'query'
      >
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<GetTrainingBranchesByOrganisation1Data>>[0],
          'body' | 'headers' | 'path' | 'query'
        > =
          typeof pageParam === 'object'
            ? pageParam
            : {
                query: {
                  'pageable.page': pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getTrainingBranchesByOrganisation1({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: getTrainingBranchesByOrganisation1InfiniteQueryKey(options),
    }
  );
};

/**
 * Cancel a scheduled class instance
 */
export const cancelScheduledClassMutation = (
  options?: Partial<Options<CancelScheduledClassData>>
): UseMutationOptions<
  CancelScheduledClassResponse,
  CancelScheduledClassError,
  Options<CancelScheduledClassData>
> => {
  const mutationOptions: UseMutationOptions<
    CancelScheduledClassResponse,
    CancelScheduledClassError,
    Options<CancelScheduledClassData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await cancelScheduledClass({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getScheduledInstanceQueryKey = (options: Options<GetScheduledInstanceData>) =>
  createQueryKey('getScheduledInstance', options);

/**
 * Get a scheduled instance by UUID
 */
export const getScheduledInstanceOptions = (options: Options<GetScheduledInstanceData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getScheduledInstance({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getScheduledInstanceQueryKey(options),
  });
};

export const getInstructorScheduleQueryKey = (options: Options<GetInstructorScheduleData>) =>
  createQueryKey('getInstructorSchedule', options);

/**
 * Get schedule for a specific instructor within a date range
 */
export const getInstructorScheduleOptions = (options: Options<GetInstructorScheduleData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getInstructorSchedule({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getInstructorScheduleQueryKey(options),
  });
};

export const getInstructorScheduleInfiniteQueryKey = (
  options: Options<GetInstructorScheduleData>
): QueryKey<Options<GetInstructorScheduleData>> =>
  createQueryKey('getInstructorSchedule', options, true);

/**
 * Get schedule for a specific instructor within a date range
 */
export const getInstructorScheduleInfiniteOptions = (
  options: Options<GetInstructorScheduleData>
) => {
  return infiniteQueryOptions<
    GetInstructorScheduleResponse,
    GetInstructorScheduleError,
    InfiniteData<GetInstructorScheduleResponse>,
    QueryKey<Options<GetInstructorScheduleData>>,
    | Date
    | Pick<QueryKey<Options<GetInstructorScheduleData>>[0], 'body' | 'headers' | 'path' | 'query'>
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<GetInstructorScheduleData>>[0],
          'body' | 'headers' | 'path' | 'query'
        > =
          typeof pageParam === 'object'
            ? pageParam
            : {
                query: {
                  start: pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getInstructorSchedule({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: getInstructorScheduleInfiniteQueryKey(options),
    }
  );
};

export const getStudentBookingsQueryKey = (options: Options<GetStudentBookingsData>) =>
  createQueryKey('getStudentBookings', options);

/**
 * Get student bookings
 */
export const getStudentBookingsOptions = (options: Options<GetStudentBookingsData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getStudentBookings({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getStudentBookingsQueryKey(options),
  });
};

export const getStudentBookingsInfiniteQueryKey = (
  options: Options<GetStudentBookingsData>
): QueryKey<Options<GetStudentBookingsData>> => createQueryKey('getStudentBookings', options, true);

/**
 * Get student bookings
 */
export const getStudentBookingsInfiniteOptions = (options: Options<GetStudentBookingsData>) => {
  return infiniteQueryOptions<
    GetStudentBookingsResponse,
    GetStudentBookingsError,
    InfiniteData<GetStudentBookingsResponse>,
    QueryKey<Options<GetStudentBookingsData>>,
    | number
    | Pick<QueryKey<Options<GetStudentBookingsData>>[0], 'body' | 'headers' | 'path' | 'query'>
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<GetStudentBookingsData>>[0],
          'body' | 'headers' | 'path' | 'query'
        > =
          typeof pageParam === 'object'
            ? pageParam
            : {
                query: {
                  'pageable.page': pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getStudentBookings({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: getStudentBookingsInfiniteQueryKey(options),
    }
  );
};

export const searchStudentsQueryKey = (options: Options<SearchStudentsData>) =>
  createQueryKey('searchStudents', options);

/**
 * Search students
 * Search for students based on criteria.
 */
export const searchStudentsOptions = (options: Options<SearchStudentsData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await searchStudents({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: searchStudentsQueryKey(options),
  });
};

export const searchStudentsInfiniteQueryKey = (
  options: Options<SearchStudentsData>
): QueryKey<Options<SearchStudentsData>> => createQueryKey('searchStudents', options, true);

/**
 * Search students
 * Search for students based on criteria.
 */
export const searchStudentsInfiniteOptions = (options: Options<SearchStudentsData>) => {
  return infiniteQueryOptions<
    SearchStudentsResponse,
    SearchStudentsError,
    InfiniteData<SearchStudentsResponse>,
    QueryKey<Options<SearchStudentsData>>,
    number | Pick<QueryKey<Options<SearchStudentsData>>[0], 'body' | 'headers' | 'path' | 'query'>
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<SearchStudentsData>>[0],
          'body' | 'headers' | 'path' | 'query'
        > =
          typeof pageParam === 'object'
            ? pageParam
            : {
                query: {
                  'pageable.page': pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await searchStudents({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: searchStudentsInfiniteQueryKey(options),
    }
  );
};

export const validateMatrixQueryKey = (options: Options<ValidateMatrixData>) =>
  createQueryKey('validateMatrix', options);

/**
 * Validate rubric matrix
 * Validates the matrix for completeness and consistency before use in assessments.
 */
export const validateMatrixOptions = (options: Options<ValidateMatrixData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await validateMatrix({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: validateMatrixQueryKey(options),
  });
};

export const getPassingScoringLevelsQueryKey = (options: Options<GetPassingScoringLevelsData>) =>
  createQueryKey('getPassingScoringLevels', options);

/**
 * Get passing scoring levels
 * Retrieves only the scoring levels that are marked as passing for the specified rubric.
 */
export const getPassingScoringLevelsOptions = (options: Options<GetPassingScoringLevelsData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getPassingScoringLevels({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getPassingScoringLevelsQueryKey(options),
  });
};

export const getPassingScoringLevelsInfiniteQueryKey = (
  options: Options<GetPassingScoringLevelsData>
): QueryKey<Options<GetPassingScoringLevelsData>> =>
  createQueryKey('getPassingScoringLevels', options, true);

/**
 * Get passing scoring levels
 * Retrieves only the scoring levels that are marked as passing for the specified rubric.
 */
export const getPassingScoringLevelsInfiniteOptions = (
  options: Options<GetPassingScoringLevelsData>
) => {
  return infiniteQueryOptions<
    GetPassingScoringLevelsResponse,
    GetPassingScoringLevelsError,
    InfiniteData<GetPassingScoringLevelsResponse>,
    QueryKey<Options<GetPassingScoringLevelsData>>,
    | number
    | Pick<QueryKey<Options<GetPassingScoringLevelsData>>[0], 'body' | 'headers' | 'path' | 'query'>
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<GetPassingScoringLevelsData>>[0],
          'body' | 'headers' | 'path' | 'query'
        > =
          typeof pageParam === 'object'
            ? pageParam
            : {
                query: {
                  'pageable.page': pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getPassingScoringLevels({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: getPassingScoringLevelsInfiniteQueryKey(options),
    }
  );
};

export const getHighestScoringLevelQueryKey = (options: Options<GetHighestScoringLevelData>) =>
  createQueryKey('getHighestScoringLevel', options);

/**
 * Get highest scoring level
 * Retrieves the highest performance scoring level (level_order = 1) for the specified rubric.
 */
export const getHighestScoringLevelOptions = (options: Options<GetHighestScoringLevelData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getHighestScoringLevel({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getHighestScoringLevelQueryKey(options),
  });
};

export const getRubricMatrixQueryKey = (options: Options<GetRubricMatrixData>) =>
  createQueryKey('getRubricMatrix', options);

/**
 * Get complete rubric matrix
 * Retrieves the complete rubric matrix including all criteria, scoring levels, matrix cells, and statistics.
 */
export const getRubricMatrixOptions = (options: Options<GetRubricMatrixData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getRubricMatrix({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getRubricMatrixQueryKey(options),
  });
};

export const validateMatrix1QueryKey = (options: Options<ValidateMatrix1Data>) =>
  createQueryKey('validateMatrix1', options);

/**
 * Validate rubric matrix
 * Validates the rubric matrix for completeness, weight consistency, and readiness for use.
 */
export const validateMatrix1Options = (options: Options<ValidateMatrix1Data>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await validateMatrix1({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: validateMatrix1QueryKey(options),
  });
};

export const getMatrixStatisticsQueryKey = (options: Options<GetMatrixStatisticsData>) =>
  createQueryKey('getMatrixStatistics', options);

/**
 * Get matrix statistics
 * Retrieves statistical information about the matrix including completion percentage and score calculations.
 */
export const getMatrixStatisticsOptions = (options: Options<GetMatrixStatisticsData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getMatrixStatistics({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getMatrixStatisticsQueryKey(options),
  });
};

export const checkMatrixReadinessQueryKey = (options: Options<CheckMatrixReadinessData>) =>
  createQueryKey('checkMatrixReadiness', options);

/**
 * Check matrix readiness
 * Quick check to determine if the rubric matrix is ready for use in assessments.
 */
export const checkMatrixReadinessOptions = (options: Options<CheckMatrixReadinessData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await checkMatrixReadiness({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: checkMatrixReadinessQueryKey(options),
  });
};

export const getRubricMatrixViewQueryKey = (options: Options<GetRubricMatrixViewData>) =>
  createQueryKey('getRubricMatrixView', options);

/**
 * Get rubric matrix view
 * Retrieves the complete rubric matrix with all criteria, scoring levels, and cell intersections.
 */
export const getRubricMatrixViewOptions = (options: Options<GetRubricMatrixViewData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getRubricMatrixView({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getRubricMatrixViewQueryKey(options),
  });
};

export const searchAssessmentRubricsQueryKey = (options: Options<SearchAssessmentRubricsData>) =>
  createQueryKey('searchAssessmentRubrics', options);

/**
 * Search for assessment rubrics
 * Searches for assessment rubrics based on a set of filter criteria.
 */
export const searchAssessmentRubricsOptions = (options: Options<SearchAssessmentRubricsData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await searchAssessmentRubrics({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: searchAssessmentRubricsQueryKey(options),
  });
};

export const searchAssessmentRubricsInfiniteQueryKey = (
  options: Options<SearchAssessmentRubricsData>
): QueryKey<Options<SearchAssessmentRubricsData>> =>
  createQueryKey('searchAssessmentRubrics', options, true);

/**
 * Search for assessment rubrics
 * Searches for assessment rubrics based on a set of filter criteria.
 */
export const searchAssessmentRubricsInfiniteOptions = (
  options: Options<SearchAssessmentRubricsData>
) => {
  return infiniteQueryOptions<
    SearchAssessmentRubricsResponse,
    SearchAssessmentRubricsError,
    InfiniteData<SearchAssessmentRubricsResponse>,
    QueryKey<Options<SearchAssessmentRubricsData>>,
    | number
    | Pick<QueryKey<Options<SearchAssessmentRubricsData>>[0], 'body' | 'headers' | 'path' | 'query'>
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<SearchAssessmentRubricsData>>[0],
          'body' | 'headers' | 'path' | 'query'
        > =
          typeof pageParam === 'object'
            ? pageParam
            : {
                query: {
                  'pageable.page': pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await searchAssessmentRubrics({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: searchAssessmentRubricsInfiniteQueryKey(options),
    }
  );
};

export const getRubricsByTypeQueryKey = (options: Options<GetRubricsByTypeData>) =>
  createQueryKey('getRubricsByType', options);

/**
 * Browse rubrics by type
 * Retrieves public rubrics filtered by a specific rubric type.
 */
export const getRubricsByTypeOptions = (options: Options<GetRubricsByTypeData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getRubricsByType({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getRubricsByTypeQueryKey(options),
  });
};

export const getRubricsByTypeInfiniteQueryKey = (
  options: Options<GetRubricsByTypeData>
): QueryKey<Options<GetRubricsByTypeData>> => createQueryKey('getRubricsByType', options, true);

/**
 * Browse rubrics by type
 * Retrieves public rubrics filtered by a specific rubric type.
 */
export const getRubricsByTypeInfiniteOptions = (options: Options<GetRubricsByTypeData>) => {
  return infiniteQueryOptions<
    GetRubricsByTypeResponse,
    GetRubricsByTypeError,
    InfiniteData<GetRubricsByTypeResponse>,
    QueryKey<Options<GetRubricsByTypeData>>,
    number | Pick<QueryKey<Options<GetRubricsByTypeData>>[0], 'body' | 'headers' | 'path' | 'query'>
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<GetRubricsByTypeData>>[0],
          'body' | 'headers' | 'path' | 'query'
        > =
          typeof pageParam === 'object'
            ? pageParam
            : {
                query: {
                  'pageable.page': pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getRubricsByType({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: getRubricsByTypeInfiniteQueryKey(options),
    }
  );
};

export const getRubricsByStatusQueryKey = (options: Options<GetRubricsByStatusData>) =>
  createQueryKey('getRubricsByStatus', options);

/**
 * Get rubrics by status
 * Retrieves rubrics filtered by their content status (e.g., DRAFT, PUBLISHED, ARCHIVED).
 */
export const getRubricsByStatusOptions = (options: Options<GetRubricsByStatusData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getRubricsByStatus({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getRubricsByStatusQueryKey(options),
  });
};

export const getRubricsByStatusInfiniteQueryKey = (
  options: Options<GetRubricsByStatusData>
): QueryKey<Options<GetRubricsByStatusData>> => createQueryKey('getRubricsByStatus', options, true);

/**
 * Get rubrics by status
 * Retrieves rubrics filtered by their content status (e.g., DRAFT, PUBLISHED, ARCHIVED).
 */
export const getRubricsByStatusInfiniteOptions = (options: Options<GetRubricsByStatusData>) => {
  return infiniteQueryOptions<
    GetRubricsByStatusResponse,
    GetRubricsByStatusError,
    InfiniteData<GetRubricsByStatusResponse>,
    QueryKey<Options<GetRubricsByStatusData>>,
    | number
    | Pick<QueryKey<Options<GetRubricsByStatusData>>[0], 'body' | 'headers' | 'path' | 'query'>
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<GetRubricsByStatusData>>[0],
          'body' | 'headers' | 'path' | 'query'
        > =
          typeof pageParam === 'object'
            ? pageParam
            : {
                query: {
                  'pageable.page': pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getRubricsByStatus({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: getRubricsByStatusInfiniteQueryKey(options),
    }
  );
};

export const getRubricStatisticsQueryKey = (options?: Options<GetRubricStatisticsData>) =>
  createQueryKey('getRubricStatistics', options);

/**
 * Get rubric usage statistics
 * Retrieves overall statistics about rubric usage, including counts of public rubrics, total rubrics, etc.
 */
export const getRubricStatisticsOptions = (options?: Options<GetRubricStatisticsData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getRubricStatistics({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getRubricStatisticsQueryKey(options),
  });
};

export const getCourseCreatorRubricStatisticsQueryKey = (
  options: Options<GetCourseCreatorRubricStatisticsData>
) => createQueryKey('getCourseCreatorRubricStatistics', options);

/**
 * Get course creator rubric statistics
 * Retrieves statistics about a specific course creator's rubrics, including counts by visibility and status.
 */
export const getCourseCreatorRubricStatisticsOptions = (
  options: Options<GetCourseCreatorRubricStatisticsData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getCourseCreatorRubricStatistics({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getCourseCreatorRubricStatisticsQueryKey(options),
  });
};

export const searchPublicRubricsQueryKey = (options: Options<SearchPublicRubricsData>) =>
  createQueryKey('searchPublicRubrics', options);

/**
 * Search public rubrics
 * Searches public rubrics by title, description, and optionally by rubric type.
 */
export const searchPublicRubricsOptions = (options: Options<SearchPublicRubricsData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await searchPublicRubrics({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: searchPublicRubricsQueryKey(options),
  });
};

export const searchPublicRubricsInfiniteQueryKey = (
  options: Options<SearchPublicRubricsData>
): QueryKey<Options<SearchPublicRubricsData>> =>
  createQueryKey('searchPublicRubrics', options, true);

/**
 * Search public rubrics
 * Searches public rubrics by title, description, and optionally by rubric type.
 */
export const searchPublicRubricsInfiniteOptions = (options: Options<SearchPublicRubricsData>) => {
  return infiniteQueryOptions<
    SearchPublicRubricsResponse,
    SearchPublicRubricsError,
    InfiniteData<SearchPublicRubricsResponse>,
    QueryKey<Options<SearchPublicRubricsData>>,
    | number
    | Pick<QueryKey<Options<SearchPublicRubricsData>>[0], 'body' | 'headers' | 'path' | 'query'>
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<SearchPublicRubricsData>>[0],
          'body' | 'headers' | 'path' | 'query'
        > =
          typeof pageParam === 'object'
            ? pageParam
            : {
                query: {
                  'pageable.page': pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await searchPublicRubrics({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: searchPublicRubricsInfiniteQueryKey(options),
    }
  );
};

export const getPublicRubricsQueryKey = (options: Options<GetPublicRubricsData>) =>
  createQueryKey('getPublicRubrics', options);

/**
 * Browse all public rubrics
 * Retrieves all public rubrics available for reuse across courses, ordered by creation date.
 */
export const getPublicRubricsOptions = (options: Options<GetPublicRubricsData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getPublicRubrics({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getPublicRubricsQueryKey(options),
  });
};

export const getPublicRubricsInfiniteQueryKey = (
  options: Options<GetPublicRubricsData>
): QueryKey<Options<GetPublicRubricsData>> => createQueryKey('getPublicRubrics', options, true);

/**
 * Browse all public rubrics
 * Retrieves all public rubrics available for reuse across courses, ordered by creation date.
 */
export const getPublicRubricsInfiniteOptions = (options: Options<GetPublicRubricsData>) => {
  return infiniteQueryOptions<
    GetPublicRubricsResponse,
    GetPublicRubricsError,
    InfiniteData<GetPublicRubricsResponse>,
    QueryKey<Options<GetPublicRubricsData>>,
    number | Pick<QueryKey<Options<GetPublicRubricsData>>[0], 'body' | 'headers' | 'path' | 'query'>
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<GetPublicRubricsData>>[0],
          'body' | 'headers' | 'path' | 'query'
        > =
          typeof pageParam === 'object'
            ? pageParam
            : {
                query: {
                  'pageable.page': pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getPublicRubrics({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: getPublicRubricsInfiniteQueryKey(options),
    }
  );
};

export const getPopularRubricsQueryKey = (options: Options<GetPopularRubricsData>) =>
  createQueryKey('getPopularRubrics', options);

/**
 * Get popular rubrics
 * Retrieves the most popular public rubrics based on usage across multiple courses.
 */
export const getPopularRubricsOptions = (options: Options<GetPopularRubricsData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getPopularRubrics({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getPopularRubricsQueryKey(options),
  });
};

export const getPopularRubricsInfiniteQueryKey = (
  options: Options<GetPopularRubricsData>
): QueryKey<Options<GetPopularRubricsData>> => createQueryKey('getPopularRubrics', options, true);

/**
 * Get popular rubrics
 * Retrieves the most popular public rubrics based on usage across multiple courses.
 */
export const getPopularRubricsInfiniteOptions = (options: Options<GetPopularRubricsData>) => {
  return infiniteQueryOptions<
    GetPopularRubricsResponse,
    GetPopularRubricsError,
    InfiniteData<GetPopularRubricsResponse>,
    QueryKey<Options<GetPopularRubricsData>>,
    | number
    | Pick<QueryKey<Options<GetPopularRubricsData>>[0], 'body' | 'headers' | 'path' | 'query'>
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<GetPopularRubricsData>>[0],
          'body' | 'headers' | 'path' | 'query'
        > =
          typeof pageParam === 'object'
            ? pageParam
            : {
                query: {
                  'pageable.page': pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getPopularRubrics({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: getPopularRubricsInfiniteQueryKey(options),
    }
  );
};

export const getGeneralRubricsQueryKey = (options: Options<GetGeneralRubricsData>) =>
  createQueryKey('getGeneralRubrics', options);

/**
 * Get general rubrics
 * Retrieves general-purpose rubrics that are not tied to any specific course.
 */
export const getGeneralRubricsOptions = (options: Options<GetGeneralRubricsData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getGeneralRubrics({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getGeneralRubricsQueryKey(options),
  });
};

export const getGeneralRubricsInfiniteQueryKey = (
  options: Options<GetGeneralRubricsData>
): QueryKey<Options<GetGeneralRubricsData>> => createQueryKey('getGeneralRubrics', options, true);

/**
 * Get general rubrics
 * Retrieves general-purpose rubrics that are not tied to any specific course.
 */
export const getGeneralRubricsInfiniteOptions = (options: Options<GetGeneralRubricsData>) => {
  return infiniteQueryOptions<
    GetGeneralRubricsResponse,
    GetGeneralRubricsError,
    InfiniteData<GetGeneralRubricsResponse>,
    QueryKey<Options<GetGeneralRubricsData>>,
    | number
    | Pick<QueryKey<Options<GetGeneralRubricsData>>[0], 'body' | 'headers' | 'path' | 'query'>
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<GetGeneralRubricsData>>[0],
          'body' | 'headers' | 'path' | 'query'
        > =
          typeof pageParam === 'object'
            ? pageParam
            : {
                query: {
                  'pageable.page': pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getGeneralRubrics({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: getGeneralRubricsInfiniteQueryKey(options),
    }
  );
};

export const getCourseCreatorRubricsQueryKey = (options: Options<GetCourseCreatorRubricsData>) =>
  createQueryKey('getCourseCreatorRubrics', options);

/**
 * Get course creator's rubrics
 * Retrieves rubrics defined by a specific course creator, with option to include private rubrics.
 */
export const getCourseCreatorRubricsOptions = (options: Options<GetCourseCreatorRubricsData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getCourseCreatorRubrics({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getCourseCreatorRubricsQueryKey(options),
  });
};

export const getCourseCreatorRubricsInfiniteQueryKey = (
  options: Options<GetCourseCreatorRubricsData>
): QueryKey<Options<GetCourseCreatorRubricsData>> =>
  createQueryKey('getCourseCreatorRubrics', options, true);

/**
 * Get course creator's rubrics
 * Retrieves rubrics defined by a specific course creator, with option to include private rubrics.
 */
export const getCourseCreatorRubricsInfiniteOptions = (
  options: Options<GetCourseCreatorRubricsData>
) => {
  return infiniteQueryOptions<
    GetCourseCreatorRubricsResponse,
    GetCourseCreatorRubricsError,
    InfiniteData<GetCourseCreatorRubricsResponse>,
    QueryKey<Options<GetCourseCreatorRubricsData>>,
    | number
    | Pick<QueryKey<Options<GetCourseCreatorRubricsData>>[0], 'body' | 'headers' | 'path' | 'query'>
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<GetCourseCreatorRubricsData>>[0],
          'body' | 'headers' | 'path' | 'query'
        > =
          typeof pageParam === 'object'
            ? pageParam
            : {
                query: {
                  'pageable.page': pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getCourseCreatorRubrics({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: getCourseCreatorRubricsInfiniteQueryKey(options),
    }
  );
};

export const getQuizTotalPointsQueryKey = (options: Options<GetQuizTotalPointsData>) =>
  createQueryKey('getQuizTotalPoints', options);

/**
 * Get quiz total points
 * Returns the maximum possible points for a quiz.
 */
export const getQuizTotalPointsOptions = (options: Options<GetQuizTotalPointsData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getQuizTotalPoints({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getQuizTotalPointsQueryKey(options),
  });
};

export const getQuestionDistributionQueryKey = (options: Options<GetQuestionDistributionData>) =>
  createQueryKey('getQuestionDistribution', options);

/**
 * Get question category distribution
 * Returns distribution of question types within a quiz.
 */
export const getQuestionDistributionOptions = (options: Options<GetQuestionDistributionData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getQuestionDistribution({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getQuestionDistributionQueryKey(options),
  });
};

export const getQuizAttemptsQueryKey = (options: Options<GetQuizAttemptsData>) =>
  createQueryKey('getQuizAttempts', options);

/**
 * Get quiz attempts
 * Retrieves all attempts for a specific quiz with scoring data.
 */
export const getQuizAttemptsOptions = (options: Options<GetQuizAttemptsData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getQuizAttempts({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getQuizAttemptsQueryKey(options),
  });
};

export const getQuizAttemptsInfiniteQueryKey = (
  options: Options<GetQuizAttemptsData>
): QueryKey<Options<GetQuizAttemptsData>> => createQueryKey('getQuizAttempts', options, true);

/**
 * Get quiz attempts
 * Retrieves all attempts for a specific quiz with scoring data.
 */
export const getQuizAttemptsInfiniteOptions = (options: Options<GetQuizAttemptsData>) => {
  return infiniteQueryOptions<
    GetQuizAttemptsResponse,
    GetQuizAttemptsError,
    InfiniteData<GetQuizAttemptsResponse>,
    QueryKey<Options<GetQuizAttemptsData>>,
    number | Pick<QueryKey<Options<GetQuizAttemptsData>>[0], 'body' | 'headers' | 'path' | 'query'>
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<GetQuizAttemptsData>>[0],
          'body' | 'headers' | 'path' | 'query'
        > =
          typeof pageParam === 'object'
            ? pageParam
            : {
                query: {
                  'pageable.page': pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getQuizAttempts({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: getQuizAttemptsInfiniteQueryKey(options),
    }
  );
};

export const searchQuizzesQueryKey = (options: Options<SearchQuizzesData>) =>
  createQueryKey('searchQuizzes', options);

/**
 * Search quizzes
 * Advanced quiz search with flexible criteria and operators.
 *
 * **Common Quiz Search Examples:**
 * - `title_like=midterm` - Quizzes with "midterm" in title
 * - `lessonUuid=uuid` - Quizzes for specific lesson
 * - `status=PUBLISHED` - Only published quizzes
 * - `active=true` - Only active quizzes
 * - `timeLimitMinutes_gte=30` - Quizzes with 30+ minute time limit
 * - `attemptsAllowed_lte=3` - Quizzes with 3 or fewer attempts allowed
 * - `passingScore_gte=70` - Quizzes with passing score 70%+
 *
 */
export const searchQuizzesOptions = (options: Options<SearchQuizzesData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await searchQuizzes({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: searchQuizzesQueryKey(options),
  });
};

export const searchQuizzesInfiniteQueryKey = (
  options: Options<SearchQuizzesData>
): QueryKey<Options<SearchQuizzesData>> => createQueryKey('searchQuizzes', options, true);

/**
 * Search quizzes
 * Advanced quiz search with flexible criteria and operators.
 *
 * **Common Quiz Search Examples:**
 * - `title_like=midterm` - Quizzes with "midterm" in title
 * - `lessonUuid=uuid` - Quizzes for specific lesson
 * - `status=PUBLISHED` - Only published quizzes
 * - `active=true` - Only active quizzes
 * - `timeLimitMinutes_gte=30` - Quizzes with 30+ minute time limit
 * - `attemptsAllowed_lte=3` - Quizzes with 3 or fewer attempts allowed
 * - `passingScore_gte=70` - Quizzes with passing score 70%+
 *
 */
export const searchQuizzesInfiniteOptions = (options: Options<SearchQuizzesData>) => {
  return infiniteQueryOptions<
    SearchQuizzesResponse,
    SearchQuizzesError,
    InfiniteData<SearchQuizzesResponse>,
    QueryKey<Options<SearchQuizzesData>>,
    number | Pick<QueryKey<Options<SearchQuizzesData>>[0], 'body' | 'headers' | 'path' | 'query'>
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<SearchQuizzesData>>[0],
          'body' | 'headers' | 'path' | 'query'
        > =
          typeof pageParam === 'object'
            ? pageParam
            : {
                query: {
                  'pageable.page': pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await searchQuizzes({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: searchQuizzesInfiniteQueryKey(options),
    }
  );
};

export const searchQuestionsQueryKey = (options: Options<SearchQuestionsData>) =>
  createQueryKey('searchQuestions', options);

/**
 * Search quiz questions
 * Search questions across all quizzes.
 *
 * **Common Question Search Examples:**
 * - `quizUuid=uuid` - All questions for specific quiz
 * - `questionType=MULTIPLE_CHOICE` - Only multiple choice questions
 * - `points_gte=2` - Questions worth 2+ points
 * - `questionText_like=calculate` - Questions containing "calculate"
 *
 */
export const searchQuestionsOptions = (options: Options<SearchQuestionsData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await searchQuestions({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: searchQuestionsQueryKey(options),
  });
};

export const searchQuestionsInfiniteQueryKey = (
  options: Options<SearchQuestionsData>
): QueryKey<Options<SearchQuestionsData>> => createQueryKey('searchQuestions', options, true);

/**
 * Search quiz questions
 * Search questions across all quizzes.
 *
 * **Common Question Search Examples:**
 * - `quizUuid=uuid` - All questions for specific quiz
 * - `questionType=MULTIPLE_CHOICE` - Only multiple choice questions
 * - `points_gte=2` - Questions worth 2+ points
 * - `questionText_like=calculate` - Questions containing "calculate"
 *
 */
export const searchQuestionsInfiniteOptions = (options: Options<SearchQuestionsData>) => {
  return infiniteQueryOptions<
    SearchQuestionsResponse,
    SearchQuestionsError,
    InfiniteData<SearchQuestionsResponse>,
    QueryKey<Options<SearchQuestionsData>>,
    number | Pick<QueryKey<Options<SearchQuestionsData>>[0], 'body' | 'headers' | 'path' | 'query'>
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<SearchQuestionsData>>[0],
          'body' | 'headers' | 'path' | 'query'
        > =
          typeof pageParam === 'object'
            ? pageParam
            : {
                query: {
                  'pageable.page': pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await searchQuestions({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: searchQuestionsInfiniteQueryKey(options),
    }
  );
};

export const searchAttemptsQueryKey = (options: Options<SearchAttemptsData>) =>
  createQueryKey('searchAttempts', options);

/**
 * Search quiz attempts
 * Search quiz attempts across all quizzes.
 *
 * **Common Attempt Search Examples:**
 * - `quizUuid=uuid` - All attempts for specific quiz
 * - `enrollmentUuid=uuid` - All attempts by specific student
 * - `status=COMPLETED` - Only completed attempts
 * - `isPassed=true` - Only passing attempts
 * - `percentage_gte=85` - Attempts with 85%+ score
 * - `startedAt_gte=2024-01-01T00:00:00` - Attempts from 2024
 *
 */
export const searchAttemptsOptions = (options: Options<SearchAttemptsData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await searchAttempts({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: searchAttemptsQueryKey(options),
  });
};

export const searchAttemptsInfiniteQueryKey = (
  options: Options<SearchAttemptsData>
): QueryKey<Options<SearchAttemptsData>> => createQueryKey('searchAttempts', options, true);

/**
 * Search quiz attempts
 * Search quiz attempts across all quizzes.
 *
 * **Common Attempt Search Examples:**
 * - `quizUuid=uuid` - All attempts for specific quiz
 * - `enrollmentUuid=uuid` - All attempts by specific student
 * - `status=COMPLETED` - Only completed attempts
 * - `isPassed=true` - Only passing attempts
 * - `percentage_gte=85` - Attempts with 85%+ score
 * - `startedAt_gte=2024-01-01T00:00:00` - Attempts from 2024
 *
 */
export const searchAttemptsInfiniteOptions = (options: Options<SearchAttemptsData>) => {
  return infiniteQueryOptions<
    SearchAttemptsResponse,
    SearchAttemptsError,
    InfiniteData<SearchAttemptsResponse>,
    QueryKey<Options<SearchAttemptsData>>,
    number | Pick<QueryKey<Options<SearchAttemptsData>>[0], 'body' | 'headers' | 'path' | 'query'>
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<SearchAttemptsData>>[0],
          'body' | 'headers' | 'path' | 'query'
        > =
          typeof pageParam === 'object'
            ? pageParam
            : {
                query: {
                  'pageable.page': pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await searchAttempts({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: searchAttemptsInfiniteQueryKey(options),
    }
  );
};

export const getProgramEnrollmentsQueryKey = (options: Options<GetProgramEnrollmentsData>) =>
  createQueryKey('getProgramEnrollments', options);

/**
 * Get program enrollments
 * Retrieves enrollment data for a specific program with completion analytics.
 */
export const getProgramEnrollmentsOptions = (options: Options<GetProgramEnrollmentsData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getProgramEnrollments({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getProgramEnrollmentsQueryKey(options),
  });
};

export const getProgramEnrollmentsInfiniteQueryKey = (
  options: Options<GetProgramEnrollmentsData>
): QueryKey<Options<GetProgramEnrollmentsData>> =>
  createQueryKey('getProgramEnrollments', options, true);

/**
 * Get program enrollments
 * Retrieves enrollment data for a specific program with completion analytics.
 */
export const getProgramEnrollmentsInfiniteOptions = (
  options: Options<GetProgramEnrollmentsData>
) => {
  return infiniteQueryOptions<
    GetProgramEnrollmentsResponse,
    GetProgramEnrollmentsError,
    InfiniteData<GetProgramEnrollmentsResponse>,
    QueryKey<Options<GetProgramEnrollmentsData>>,
    | number
    | Pick<QueryKey<Options<GetProgramEnrollmentsData>>[0], 'body' | 'headers' | 'path' | 'query'>
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<GetProgramEnrollmentsData>>[0],
          'body' | 'headers' | 'path' | 'query'
        > =
          typeof pageParam === 'object'
            ? pageParam
            : {
                query: {
                  'pageable.page': pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getProgramEnrollments({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: getProgramEnrollmentsInfiniteQueryKey(options),
    }
  );
};

export const getRequiredCoursesQueryKey = (options: Options<GetRequiredCoursesData>) =>
  createQueryKey('getRequiredCourses', options);

/**
 * Get required courses
 * Retrieves only the required courses for a program.
 */
export const getRequiredCoursesOptions = (options: Options<GetRequiredCoursesData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getRequiredCourses({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getRequiredCoursesQueryKey(options),
  });
};

export const getOptionalCoursesQueryKey = (options: Options<GetOptionalCoursesData>) =>
  createQueryKey('getOptionalCourses', options);

/**
 * Get optional courses
 * Retrieves only the optional courses for a program.
 */
export const getOptionalCoursesOptions = (options: Options<GetOptionalCoursesData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getOptionalCourses({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getOptionalCoursesQueryKey(options),
  });
};

export const getProgramCompletionRateQueryKey = (options: Options<GetProgramCompletionRateData>) =>
  createQueryKey('getProgramCompletionRate', options);

/**
 * Get program completion rate
 * Returns the completion rate percentage for a program.
 */
export const getProgramCompletionRateOptions = (options: Options<GetProgramCompletionRateData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getProgramCompletionRate({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getProgramCompletionRateQueryKey(options),
  });
};

export const getProgramCertificatesQueryKey = (options: Options<GetProgramCertificatesData>) =>
  createQueryKey('getProgramCertificates', options);

/**
 * Get program certificates
 * Retrieves all certificates issued for program completions.
 */
export const getProgramCertificatesOptions = (options: Options<GetProgramCertificatesData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getProgramCertificates({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getProgramCertificatesQueryKey(options),
  });
};

export const getProgramCertificatesInfiniteQueryKey = (
  options: Options<GetProgramCertificatesData>
): QueryKey<Options<GetProgramCertificatesData>> =>
  createQueryKey('getProgramCertificates', options, true);

/**
 * Get program certificates
 * Retrieves all certificates issued for program completions.
 */
export const getProgramCertificatesInfiniteOptions = (
  options: Options<GetProgramCertificatesData>
) => {
  return infiniteQueryOptions<
    GetProgramCertificatesResponse,
    GetProgramCertificatesError,
    InfiniteData<GetProgramCertificatesResponse>,
    QueryKey<Options<GetProgramCertificatesData>>,
    | number
    | Pick<QueryKey<Options<GetProgramCertificatesData>>[0], 'body' | 'headers' | 'path' | 'query'>
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<GetProgramCertificatesData>>[0],
          'body' | 'headers' | 'path' | 'query'
        > =
          typeof pageParam === 'object'
            ? pageParam
            : {
                query: {
                  'pageable.page': pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getProgramCertificates({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: getProgramCertificatesInfiniteQueryKey(options),
    }
  );
};

export const searchTrainingProgramsQueryKey = (options: Options<SearchTrainingProgramsData>) =>
  createQueryKey('searchTrainingPrograms', options);

/**
 * Search training programs
 * Advanced program search with flexible criteria and operators.
 *
 * **Common Program Search Examples:**
 * - `title_like=data science` - Programs with titles containing "data science"
 * - `status=PUBLISHED` - Only published programs
 * - `active=true` - Only active programs
 * - `status_in=PUBLISHED,ACTIVE` - Published or active programs
 * - `price_lte=500.00` - Programs priced at $500 or less
 * - `price=null` - Free programs
 * - `instructorUuid=uuid` - Programs by specific instructor
 * - `categoryUuid=uuid` - Programs in specific category
 * - `totalDurationHours_gte=40` - Programs 40+ hours long
 * - `totalDurationHours_between=20,100` - Programs between 20-100 hours
 * - `createdDate_gte=2024-01-01T00:00:00` - Programs created after Jan 1, 2024
 *
 * **Advanced Program Queries:**
 * - `status=PUBLISHED&active=true&price_lte=100` - Published, active programs under $100
 * - `title_like=certification&totalDurationHours_gte=50` - Certification programs 50+ hours
 * - `instructorUuid=uuid&status=PUBLISHED` - Published programs by specific instructor
 *
 * For complete operator documentation, see the instructor search endpoint.
 *
 */
export const searchTrainingProgramsOptions = (options: Options<SearchTrainingProgramsData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await searchTrainingPrograms({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: searchTrainingProgramsQueryKey(options),
  });
};

export const searchTrainingProgramsInfiniteQueryKey = (
  options: Options<SearchTrainingProgramsData>
): QueryKey<Options<SearchTrainingProgramsData>> =>
  createQueryKey('searchTrainingPrograms', options, true);

/**
 * Search training programs
 * Advanced program search with flexible criteria and operators.
 *
 * **Common Program Search Examples:**
 * - `title_like=data science` - Programs with titles containing "data science"
 * - `status=PUBLISHED` - Only published programs
 * - `active=true` - Only active programs
 * - `status_in=PUBLISHED,ACTIVE` - Published or active programs
 * - `price_lte=500.00` - Programs priced at $500 or less
 * - `price=null` - Free programs
 * - `instructorUuid=uuid` - Programs by specific instructor
 * - `categoryUuid=uuid` - Programs in specific category
 * - `totalDurationHours_gte=40` - Programs 40+ hours long
 * - `totalDurationHours_between=20,100` - Programs between 20-100 hours
 * - `createdDate_gte=2024-01-01T00:00:00` - Programs created after Jan 1, 2024
 *
 * **Advanced Program Queries:**
 * - `status=PUBLISHED&active=true&price_lte=100` - Published, active programs under $100
 * - `title_like=certification&totalDurationHours_gte=50` - Certification programs 50+ hours
 * - `instructorUuid=uuid&status=PUBLISHED` - Published programs by specific instructor
 *
 * For complete operator documentation, see the instructor search endpoint.
 *
 */
export const searchTrainingProgramsInfiniteOptions = (
  options: Options<SearchTrainingProgramsData>
) => {
  return infiniteQueryOptions<
    SearchTrainingProgramsResponse,
    SearchTrainingProgramsError,
    InfiniteData<SearchTrainingProgramsResponse>,
    QueryKey<Options<SearchTrainingProgramsData>>,
    | number
    | Pick<QueryKey<Options<SearchTrainingProgramsData>>[0], 'body' | 'headers' | 'path' | 'query'>
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<SearchTrainingProgramsData>>[0],
          'body' | 'headers' | 'path' | 'query'
        > =
          typeof pageParam === 'object'
            ? pageParam
            : {
                query: {
                  'pageable.page': pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await searchTrainingPrograms({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: searchTrainingProgramsInfiniteQueryKey(options),
    }
  );
};

export const searchProgramRequirementsQueryKey = (
  options: Options<SearchProgramRequirementsData>
) => createQueryKey('searchProgramRequirements', options);

/**
 * Search program requirements
 * Search program requirements and prerequisites.
 *
 * **Common Program Requirement Search Examples:**
 * - `programUuid=uuid` - All requirements for specific program
 * - `requirementType=PREREQUISITE` - Only prerequisites
 * - `isMandatory=true` - Only mandatory requirements
 * - `requirementText_like=certification` - Requirements mentioning "certification"
 *
 */
export const searchProgramRequirementsOptions = (
  options: Options<SearchProgramRequirementsData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await searchProgramRequirements({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: searchProgramRequirementsQueryKey(options),
  });
};

export const searchProgramRequirementsInfiniteQueryKey = (
  options: Options<SearchProgramRequirementsData>
): QueryKey<Options<SearchProgramRequirementsData>> =>
  createQueryKey('searchProgramRequirements', options, true);

/**
 * Search program requirements
 * Search program requirements and prerequisites.
 *
 * **Common Program Requirement Search Examples:**
 * - `programUuid=uuid` - All requirements for specific program
 * - `requirementType=PREREQUISITE` - Only prerequisites
 * - `isMandatory=true` - Only mandatory requirements
 * - `requirementText_like=certification` - Requirements mentioning "certification"
 *
 */
export const searchProgramRequirementsInfiniteOptions = (
  options: Options<SearchProgramRequirementsData>
) => {
  return infiniteQueryOptions<
    SearchProgramRequirementsResponse,
    SearchProgramRequirementsError,
    InfiniteData<SearchProgramRequirementsResponse>,
    QueryKey<Options<SearchProgramRequirementsData>>,
    | number
    | Pick<
        QueryKey<Options<SearchProgramRequirementsData>>[0],
        'body' | 'headers' | 'path' | 'query'
      >
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<SearchProgramRequirementsData>>[0],
          'body' | 'headers' | 'path' | 'query'
        > =
          typeof pageParam === 'object'
            ? pageParam
            : {
                query: {
                  'pageable.page': pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await searchProgramRequirements({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: searchProgramRequirementsInfiniteQueryKey(options),
    }
  );
};

export const getPublishedProgramsQueryKey = (options: Options<GetPublishedProgramsData>) =>
  createQueryKey('getPublishedPrograms', options);

/**
 * Get published programs
 * Retrieves all published programs available for enrollment.
 */
export const getPublishedProgramsOptions = (options: Options<GetPublishedProgramsData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getPublishedPrograms({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getPublishedProgramsQueryKey(options),
  });
};

export const getPublishedProgramsInfiniteQueryKey = (
  options: Options<GetPublishedProgramsData>
): QueryKey<Options<GetPublishedProgramsData>> =>
  createQueryKey('getPublishedPrograms', options, true);

/**
 * Get published programs
 * Retrieves all published programs available for enrollment.
 */
export const getPublishedProgramsInfiniteOptions = (options: Options<GetPublishedProgramsData>) => {
  return infiniteQueryOptions<
    GetPublishedProgramsResponse,
    GetPublishedProgramsError,
    InfiniteData<GetPublishedProgramsResponse>,
    QueryKey<Options<GetPublishedProgramsData>>,
    | number
    | Pick<QueryKey<Options<GetPublishedProgramsData>>[0], 'body' | 'headers' | 'path' | 'query'>
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<GetPublishedProgramsData>>[0],
          'body' | 'headers' | 'path' | 'query'
        > =
          typeof pageParam === 'object'
            ? pageParam
            : {
                query: {
                  'pageable.page': pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getPublishedPrograms({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: getPublishedProgramsInfiniteQueryKey(options),
    }
  );
};

export const getProgramsByInstructorQueryKey = (options: Options<GetProgramsByInstructorData>) =>
  createQueryKey('getProgramsByInstructor', options);

/**
 * Get programs by instructor
 * Retrieves all programs created by a specific instructor.
 */
export const getProgramsByInstructorOptions = (options: Options<GetProgramsByInstructorData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getProgramsByInstructor({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getProgramsByInstructorQueryKey(options),
  });
};

export const getProgramsByInstructorInfiniteQueryKey = (
  options: Options<GetProgramsByInstructorData>
): QueryKey<Options<GetProgramsByInstructorData>> =>
  createQueryKey('getProgramsByInstructor', options, true);

/**
 * Get programs by instructor
 * Retrieves all programs created by a specific instructor.
 */
export const getProgramsByInstructorInfiniteOptions = (
  options: Options<GetProgramsByInstructorData>
) => {
  return infiniteQueryOptions<
    GetProgramsByInstructorResponse,
    GetProgramsByInstructorError,
    InfiniteData<GetProgramsByInstructorResponse>,
    QueryKey<Options<GetProgramsByInstructorData>>,
    | number
    | Pick<QueryKey<Options<GetProgramsByInstructorData>>[0], 'body' | 'headers' | 'path' | 'query'>
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<GetProgramsByInstructorData>>[0],
          'body' | 'headers' | 'path' | 'query'
        > =
          typeof pageParam === 'object'
            ? pageParam
            : {
                query: {
                  'pageable.page': pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getProgramsByInstructor({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: getProgramsByInstructorInfiniteQueryKey(options),
    }
  );
};

export const getFreeProgramsQueryKey = (options: Options<GetFreeProgramsData>) =>
  createQueryKey('getFreePrograms', options);

/**
 * Get free programs
 * Retrieves all programs available at no cost.
 */
export const getFreeProgramsOptions = (options: Options<GetFreeProgramsData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getFreePrograms({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getFreeProgramsQueryKey(options),
  });
};

export const getFreeProgramsInfiniteQueryKey = (
  options: Options<GetFreeProgramsData>
): QueryKey<Options<GetFreeProgramsData>> => createQueryKey('getFreePrograms', options, true);

/**
 * Get free programs
 * Retrieves all programs available at no cost.
 */
export const getFreeProgramsInfiniteOptions = (options: Options<GetFreeProgramsData>) => {
  return infiniteQueryOptions<
    GetFreeProgramsResponse,
    GetFreeProgramsError,
    InfiniteData<GetFreeProgramsResponse>,
    QueryKey<Options<GetFreeProgramsData>>,
    number | Pick<QueryKey<Options<GetFreeProgramsData>>[0], 'body' | 'headers' | 'path' | 'query'>
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<GetFreeProgramsData>>[0],
          'body' | 'headers' | 'path' | 'query'
        > =
          typeof pageParam === 'object'
            ? pageParam
            : {
                query: {
                  'pageable.page': pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getFreePrograms({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: getFreeProgramsInfiniteQueryKey(options),
    }
  );
};

export const searchProgramEnrollmentsQueryKey = (options: Options<SearchProgramEnrollmentsData>) =>
  createQueryKey('searchProgramEnrollments', options);

/**
 * Search program enrollments
 * Search enrollment records across all programs.
 *
 * **Common Program Enrollment Search Examples:**
 * - `programUuid=uuid` - All enrollments for specific program
 * - `studentUuid=uuid` - All program enrollments for specific student
 * - `status=COMPLETED` - Only completed program enrollments
 * - `progressPercentage_gte=90` - Students with 90%+ program progress
 * - `enrollmentDate_gte=2024-01-01T00:00:00` - Program enrollments from 2024
 * - `finalGrade_gte=85` - Program completions with grade 85+
 *
 */
export const searchProgramEnrollmentsOptions = (options: Options<SearchProgramEnrollmentsData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await searchProgramEnrollments({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: searchProgramEnrollmentsQueryKey(options),
  });
};

export const searchProgramEnrollmentsInfiniteQueryKey = (
  options: Options<SearchProgramEnrollmentsData>
): QueryKey<Options<SearchProgramEnrollmentsData>> =>
  createQueryKey('searchProgramEnrollments', options, true);

/**
 * Search program enrollments
 * Search enrollment records across all programs.
 *
 * **Common Program Enrollment Search Examples:**
 * - `programUuid=uuid` - All enrollments for specific program
 * - `studentUuid=uuid` - All program enrollments for specific student
 * - `status=COMPLETED` - Only completed program enrollments
 * - `progressPercentage_gte=90` - Students with 90%+ program progress
 * - `enrollmentDate_gte=2024-01-01T00:00:00` - Program enrollments from 2024
 * - `finalGrade_gte=85` - Program completions with grade 85+
 *
 */
export const searchProgramEnrollmentsInfiniteOptions = (
  options: Options<SearchProgramEnrollmentsData>
) => {
  return infiniteQueryOptions<
    SearchProgramEnrollmentsResponse,
    SearchProgramEnrollmentsError,
    InfiniteData<SearchProgramEnrollmentsResponse>,
    QueryKey<Options<SearchProgramEnrollmentsData>>,
    | number
    | Pick<
        QueryKey<Options<SearchProgramEnrollmentsData>>[0],
        'body' | 'headers' | 'path' | 'query'
      >
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<SearchProgramEnrollmentsData>>[0],
          'body' | 'headers' | 'path' | 'query'
        > =
          typeof pageParam === 'object'
            ? pageParam
            : {
                query: {
                  'pageable.page': pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await searchProgramEnrollments({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: searchProgramEnrollmentsInfiniteQueryKey(options),
    }
  );
};

export const searchProgramCoursesQueryKey = (options: Options<SearchProgramCoursesData>) =>
  createQueryKey('searchProgramCourses', options);

/**
 * Search program courses
 * Search course associations within programs.
 *
 * **Common Program Course Search Examples:**
 * - `programUuid=uuid` - All courses for specific program
 * - `courseUuid=uuid` - All programs containing specific course
 * - `isRequired=true` - Only required course associations
 * - `sequenceOrder_gte=3` - Courses from sequence 3 onwards
 *
 */
export const searchProgramCoursesOptions = (options: Options<SearchProgramCoursesData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await searchProgramCourses({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: searchProgramCoursesQueryKey(options),
  });
};

export const searchProgramCoursesInfiniteQueryKey = (
  options: Options<SearchProgramCoursesData>
): QueryKey<Options<SearchProgramCoursesData>> =>
  createQueryKey('searchProgramCourses', options, true);

/**
 * Search program courses
 * Search course associations within programs.
 *
 * **Common Program Course Search Examples:**
 * - `programUuid=uuid` - All courses for specific program
 * - `courseUuid=uuid` - All programs containing specific course
 * - `isRequired=true` - Only required course associations
 * - `sequenceOrder_gte=3` - Courses from sequence 3 onwards
 *
 */
export const searchProgramCoursesInfiniteOptions = (options: Options<SearchProgramCoursesData>) => {
  return infiniteQueryOptions<
    SearchProgramCoursesResponse,
    SearchProgramCoursesError,
    InfiniteData<SearchProgramCoursesResponse>,
    QueryKey<Options<SearchProgramCoursesData>>,
    | number
    | Pick<QueryKey<Options<SearchProgramCoursesData>>[0], 'body' | 'headers' | 'path' | 'query'>
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<SearchProgramCoursesData>>[0],
          'body' | 'headers' | 'path' | 'query'
        > =
          typeof pageParam === 'object'
            ? pageParam
            : {
                query: {
                  'pageable.page': pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await searchProgramCourses({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: searchProgramCoursesInfiniteQueryKey(options),
    }
  );
};

export const getProgramsByCategoryQueryKey = (options: Options<GetProgramsByCategoryData>) =>
  createQueryKey('getProgramsByCategory', options);

/**
 * Get programs by category
 * Retrieves all programs in a specific category.
 */
export const getProgramsByCategoryOptions = (options: Options<GetProgramsByCategoryData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getProgramsByCategory({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getProgramsByCategoryQueryKey(options),
  });
};

export const getProgramsByCategoryInfiniteQueryKey = (
  options: Options<GetProgramsByCategoryData>
): QueryKey<Options<GetProgramsByCategoryData>> =>
  createQueryKey('getProgramsByCategory', options, true);

/**
 * Get programs by category
 * Retrieves all programs in a specific category.
 */
export const getProgramsByCategoryInfiniteOptions = (
  options: Options<GetProgramsByCategoryData>
) => {
  return infiniteQueryOptions<
    GetProgramsByCategoryResponse,
    GetProgramsByCategoryError,
    InfiniteData<GetProgramsByCategoryResponse>,
    QueryKey<Options<GetProgramsByCategoryData>>,
    | number
    | Pick<QueryKey<Options<GetProgramsByCategoryData>>[0], 'body' | 'headers' | 'path' | 'query'>
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<GetProgramsByCategoryData>>[0],
          'body' | 'headers' | 'path' | 'query'
        > =
          typeof pageParam === 'object'
            ? pageParam
            : {
                query: {
                  'pageable.page': pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getProgramsByCategory({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: getProgramsByCategoryInfiniteQueryKey(options),
    }
  );
};

export const getActiveProgramsQueryKey = (options: Options<GetActiveProgramsData>) =>
  createQueryKey('getActivePrograms', options);

/**
 * Get active programs
 * Retrieves all currently active and published programs.
 */
export const getActiveProgramsOptions = (options: Options<GetActiveProgramsData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getActivePrograms({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getActiveProgramsQueryKey(options),
  });
};

export const getActiveProgramsInfiniteQueryKey = (
  options: Options<GetActiveProgramsData>
): QueryKey<Options<GetActiveProgramsData>> => createQueryKey('getActivePrograms', options, true);

/**
 * Get active programs
 * Retrieves all currently active and published programs.
 */
export const getActiveProgramsInfiniteOptions = (options: Options<GetActiveProgramsData>) => {
  return infiniteQueryOptions<
    GetActiveProgramsResponse,
    GetActiveProgramsError,
    InfiniteData<GetActiveProgramsResponse>,
    QueryKey<Options<GetActiveProgramsData>>,
    | number
    | Pick<QueryKey<Options<GetActiveProgramsData>>[0], 'body' | 'headers' | 'path' | 'query'>
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<GetActiveProgramsData>>[0],
          'body' | 'headers' | 'path' | 'query'
        > =
          typeof pageParam === 'object'
            ? pageParam
            : {
                query: {
                  'pageable.page': pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getActivePrograms({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: getActiveProgramsInfiniteQueryKey(options),
    }
  );
};

export const getUsersByOrganisationQueryKey = (options: Options<GetUsersByOrganisationData>) =>
  createQueryKey('getUsersByOrganisation', options);

/**
 * Get users by organisation ID
 */
export const getUsersByOrganisationOptions = (options: Options<GetUsersByOrganisationData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getUsersByOrganisation({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getUsersByOrganisationQueryKey(options),
  });
};

export const getUsersByOrganisationInfiniteQueryKey = (
  options: Options<GetUsersByOrganisationData>
): QueryKey<Options<GetUsersByOrganisationData>> =>
  createQueryKey('getUsersByOrganisation', options, true);

/**
 * Get users by organisation ID
 */
export const getUsersByOrganisationInfiniteOptions = (
  options: Options<GetUsersByOrganisationData>
) => {
  return infiniteQueryOptions<
    GetUsersByOrganisationResponse,
    GetUsersByOrganisationError,
    InfiniteData<GetUsersByOrganisationResponse>,
    QueryKey<Options<GetUsersByOrganisationData>>,
    | number
    | Pick<QueryKey<Options<GetUsersByOrganisationData>>[0], 'body' | 'headers' | 'path' | 'query'>
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<GetUsersByOrganisationData>>[0],
          'body' | 'headers' | 'path' | 'query'
        > =
          typeof pageParam === 'object'
            ? pageParam
            : {
                query: {
                  'pageable.page': pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getUsersByOrganisation({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: getUsersByOrganisationInfiniteQueryKey(options),
    }
  );
};

export const getUsersByOrganisationAndDomainQueryKey = (
  options: Options<GetUsersByOrganisationAndDomainData>
) => createQueryKey('getUsersByOrganisationAndDomain', options);

/**
 * Get users by organisation and domain
 * Retrieves all users in the organisation filtered by their role/domain. This endpoint is useful for getting all instructors, students, or admins within an organisation.
 */
export const getUsersByOrganisationAndDomainOptions = (
  options: Options<GetUsersByOrganisationAndDomainData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getUsersByOrganisationAndDomain({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getUsersByOrganisationAndDomainQueryKey(options),
  });
};

export const getBranchUsersQueryKey = (options: Options<GetBranchUsersData>) =>
  createQueryKey('getBranchUsers', options);

/**
 * Get users assigned to training branch
 * Retrieves all users that are assigned to a specific training branch within the organization. This includes users with any role/domain within the branch.
 */
export const getBranchUsersOptions = (options: Options<GetBranchUsersData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getBranchUsers({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getBranchUsersQueryKey(options),
  });
};

export const getBranchUsersByDomainQueryKey = (options: Options<GetBranchUsersByDomainData>) =>
  createQueryKey('getBranchUsersByDomain', options);

/**
 * Get users by training branch and domain
 * Retrieves all users in the training branch filtered by their role/domain. This endpoint is useful for getting all instructors, students, or admins within a specific branch.
 */
export const getBranchUsersByDomainOptions = (options: Options<GetBranchUsersByDomainData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getBranchUsersByDomain({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getBranchUsersByDomainQueryKey(options),
  });
};

export const search2QueryKey = (options: Options<Search2Data>) =>
  createQueryKey('search2', options);

/**
 * Search organisations
 * Fetches a paginated list of organisations based on optional filters. Supports pagination and sorting. Available filters include:
 * - `name` - Filter by organisation name (partial match)
 * - `active` - Filter by active status (true/false)
 * - `admin_verified` - Filter by verification status (true/false)
 * - `country` - Filter by country
 * - `location` - Filter by location
 *
 * Examples:
 * - `/search?admin_verified=true` - Get verified organisations
 * - `/search?admin_verified=false` - Get unverified organisations
 * - `/search?active=true&admin_verified=true` - Get active verified organisations
 */
export const search2Options = (options: Options<Search2Data>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await search2({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: search2QueryKey(options),
  });
};

export const search2InfiniteQueryKey = (
  options: Options<Search2Data>
): QueryKey<Options<Search2Data>> => createQueryKey('search2', options, true);

/**
 * Search organisations
 * Fetches a paginated list of organisations based on optional filters. Supports pagination and sorting. Available filters include:
 * - `name` - Filter by organisation name (partial match)
 * - `active` - Filter by active status (true/false)
 * - `admin_verified` - Filter by verification status (true/false)
 * - `country` - Filter by country
 * - `location` - Filter by location
 *
 * Examples:
 * - `/search?admin_verified=true` - Get verified organisations
 * - `/search?admin_verified=false` - Get unverified organisations
 * - `/search?active=true&admin_verified=true` - Get active verified organisations
 */
export const search2InfiniteOptions = (options: Options<Search2Data>) => {
  return infiniteQueryOptions<
    Search2Response,
    Search2Error,
    InfiniteData<Search2Response>,
    QueryKey<Options<Search2Data>>,
    number | Pick<QueryKey<Options<Search2Data>>[0], 'body' | 'headers' | 'path' | 'query'>
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<Search2Data>>[0], 'body' | 'headers' | 'path' | 'query'> =
          typeof pageParam === 'object'
            ? pageParam
            : {
                query: {
                  'pageable.page': pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await search2({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: search2InfiniteQueryKey(options),
    }
  );
};

export const getInstructorRatingSummaryQueryKey = (
  options: Options<GetInstructorRatingSummaryData>
) => createQueryKey('getInstructorRatingSummary', options);

/**
 * Get instructor rating summary
 * Returns average rating and total review count for an instructor.
 */
export const getInstructorRatingSummaryOptions = (
  options: Options<GetInstructorRatingSummaryData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getInstructorRatingSummary({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getInstructorRatingSummaryQueryKey(options),
  });
};

export const getInstructorBookingsQueryKey = (options: Options<GetInstructorBookingsData>) =>
  createQueryKey('getInstructorBookings', options);

/**
 * Get instructor bookings
 */
export const getInstructorBookingsOptions = (options: Options<GetInstructorBookingsData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getInstructorBookings({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getInstructorBookingsQueryKey(options),
  });
};

export const getInstructorBookingsInfiniteQueryKey = (
  options: Options<GetInstructorBookingsData>
): QueryKey<Options<GetInstructorBookingsData>> =>
  createQueryKey('getInstructorBookings', options, true);

/**
 * Get instructor bookings
 */
export const getInstructorBookingsInfiniteOptions = (
  options: Options<GetInstructorBookingsData>
) => {
  return infiniteQueryOptions<
    GetInstructorBookingsResponse,
    GetInstructorBookingsError,
    InfiniteData<GetInstructorBookingsResponse>,
    QueryKey<Options<GetInstructorBookingsData>>,
    | number
    | Pick<QueryKey<Options<GetInstructorBookingsData>>[0], 'body' | 'headers' | 'path' | 'query'>
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<GetInstructorBookingsData>>[0],
          'body' | 'headers' | 'path' | 'query'
        > =
          typeof pageParam === 'object'
            ? pageParam
            : {
                query: {
                  'pageable.page': pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getInstructorBookings({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: getInstructorBookingsInfiniteQueryKey(options),
    }
  );
};

export const checkAvailabilityQueryKey = (options: Options<CheckAvailabilityData>) =>
  createQueryKey('checkAvailability', options);

/**
 * Check if instructor is available during a time period
 * Checks whether an instructor is available for the entire specified time period.
 *
 * Returns true unless a blocked slot overlaps the requested window.
 *
 */
export const checkAvailabilityOptions = (options: Options<CheckAvailabilityData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await checkAvailability({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: checkAvailabilityQueryKey(options),
  });
};

export const checkAvailabilityInfiniteQueryKey = (
  options: Options<CheckAvailabilityData>
): QueryKey<Options<CheckAvailabilityData>> => createQueryKey('checkAvailability', options, true);

/**
 * Check if instructor is available during a time period
 * Checks whether an instructor is available for the entire specified time period.
 *
 * Returns true unless a blocked slot overlaps the requested window.
 *
 */
export const checkAvailabilityInfiniteOptions = (options: Options<CheckAvailabilityData>) => {
  return infiniteQueryOptions<
    CheckAvailabilityResponse,
    CheckAvailabilityError,
    InfiniteData<CheckAvailabilityResponse>,
    QueryKey<Options<CheckAvailabilityData>>,
    Date | Pick<QueryKey<Options<CheckAvailabilityData>>[0], 'body' | 'headers' | 'path' | 'query'>
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<CheckAvailabilityData>>[0],
          'body' | 'headers' | 'path' | 'query'
        > =
          typeof pageParam === 'object'
            ? pageParam
            : {
                query: {
                  start: pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await checkAvailability({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: checkAvailabilityInfiniteQueryKey(options),
    }
  );
};

export const getInstructorCalendarQueryKey = (options: Options<GetInstructorCalendarData>) =>
  createQueryKey('getInstructorCalendar', options);

/**
 * Get merged instructor calendar
 * Returns a merged feed of availability slots, blocked time, and scheduled instances for the instructor within a date range.
 */
export const getInstructorCalendarOptions = (options: Options<GetInstructorCalendarData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getInstructorCalendar({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getInstructorCalendarQueryKey(options),
  });
};

export const searchSkillsQueryKey = (options: Options<SearchSkillsData>) =>
  createQueryKey('searchSkills', options);

/**
 * Search instructor skills
 * Search skills with flexible criteria.
 *
 * **Common Skills Search Examples:**
 * - `instructorUuid=uuid` - All skills for specific instructor
 * - `skillName_like=java` - Skills containing "java"
 * - `proficiencyLevel=EXPERT` - Expert level skills only
 * - `proficiencyLevel_in=ADVANCED,EXPERT` - Advanced or expert skills
 * - `skillName_startswith=Data` - Skills starting with "Data"
 * - `proficiencyLevel_noteq=BEGINNER` - Non-beginner skills
 *
 * **Skills Analysis Queries:**
 * - `skillName_like=programming&proficiencyLevel_in=ADVANCED,EXPERT` - Advanced programming skills
 * - `createdDate_gte=2024-01-01&proficiencyLevel=EXPERT` - Recently added expert skills
 *
 * **Proficiency Levels:** BEGINNER, INTERMEDIATE, ADVANCED, EXPERT
 *
 * For complete operator documentation, see the main search endpoint.
 *
 */
export const searchSkillsOptions = (options: Options<SearchSkillsData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await searchSkills({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: searchSkillsQueryKey(options),
  });
};

export const searchSkillsInfiniteQueryKey = (
  options: Options<SearchSkillsData>
): QueryKey<Options<SearchSkillsData>> => createQueryKey('searchSkills', options, true);

/**
 * Search instructor skills
 * Search skills with flexible criteria.
 *
 * **Common Skills Search Examples:**
 * - `instructorUuid=uuid` - All skills for specific instructor
 * - `skillName_like=java` - Skills containing "java"
 * - `proficiencyLevel=EXPERT` - Expert level skills only
 * - `proficiencyLevel_in=ADVANCED,EXPERT` - Advanced or expert skills
 * - `skillName_startswith=Data` - Skills starting with "Data"
 * - `proficiencyLevel_noteq=BEGINNER` - Non-beginner skills
 *
 * **Skills Analysis Queries:**
 * - `skillName_like=programming&proficiencyLevel_in=ADVANCED,EXPERT` - Advanced programming skills
 * - `createdDate_gte=2024-01-01&proficiencyLevel=EXPERT` - Recently added expert skills
 *
 * **Proficiency Levels:** BEGINNER, INTERMEDIATE, ADVANCED, EXPERT
 *
 * For complete operator documentation, see the main search endpoint.
 *
 */
export const searchSkillsInfiniteOptions = (options: Options<SearchSkillsData>) => {
  return infiniteQueryOptions<
    SearchSkillsResponse,
    SearchSkillsError,
    InfiniteData<SearchSkillsResponse>,
    QueryKey<Options<SearchSkillsData>>,
    number | Pick<QueryKey<Options<SearchSkillsData>>[0], 'body' | 'headers' | 'path' | 'query'>
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<SearchSkillsData>>[0],
          'body' | 'headers' | 'path' | 'query'
        > =
          typeof pageParam === 'object'
            ? pageParam
            : {
                query: {
                  'pageable.page': pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await searchSkills({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: searchSkillsInfiniteQueryKey(options),
    }
  );
};

export const searchInstructorsQueryKey = (options: Options<SearchInstructorsData>) =>
  createQueryKey('searchInstructors', options);

/**
 * Search instructors
 *  Search for instructors using flexible criteria with advanced operators.
 *
 * **Basic Search:**
 * - `field=value` - Exact match (default operation)
 * - `firstName=John` - Find instructors with firstName exactly "John"
 *
 * **Comparison Operators:**
 * - `field_gt=value` - Greater than
 * - `field_lt=value` - Less than
 * - `field_gte=value` - Greater than or equal
 * - `field_lte=value` - Less than or equal
 * - `createdDate_gte=2024-01-01T00:00:00` - Created after Jan 1, 2024
 *
 * **String Operations:**
 * - `field_like=value` - Contains (case-insensitive)
 * - `field_startswith=value` - Starts with (case-insensitive)
 * - `field_endswith=value` - Ends with (case-insensitive)
 * - `lastName_like=smith` - Last name contains "smith"
 *
 * **List Operations:**
 * - `field_in=val1,val2,val3` - Field is in list
 * - `field_notin=val1,val2` - Field is not in list
 * - `status_in=ACTIVE,PENDING` - Status is either ACTIVE or PENDING
 *
 * **Negation:**
 * - `field_noteq=value` - Not equal to value
 * - `isActive_noteq=false` - Is not false (i.e., is true)
 *
 * **Range Operations:**
 * - `field_between=start,end` - Value between start and end (inclusive)
 * - `createdDate_between=2024-01-01T00:00:00,2024-12-31T23:59:59` - Created in 2024
 *
 * **Complex Operations:**
 * - `field_notingroup=relationshipField,groupId` - Not in specific group
 *
 * **Nested Field Access:**
 * - `nestedObject.field=value` - Search in nested objects
 *
 * **Supported Data Types:**
 * - String, UUID, Boolean (true/false or 1/0), Integer, Long, Double, Float, BigDecimal
 * - Date (YYYY-MM-DD), Timestamp, LocalDateTime (ISO format)
 *
 * **Examples:**
 * - `/search?firstName_like=john&isActive=true&createdDate_gte=2024-01-01T00:00:00`
 * - `/search?experience_gt=5&status_in=ACTIVE,VERIFIED`
 * - `/search?email_endswith=@company.com&department_noteq=IT`
 *
 */
export const searchInstructorsOptions = (options: Options<SearchInstructorsData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await searchInstructors({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: searchInstructorsQueryKey(options),
  });
};

export const searchInstructorsInfiniteQueryKey = (
  options: Options<SearchInstructorsData>
): QueryKey<Options<SearchInstructorsData>> => createQueryKey('searchInstructors', options, true);

/**
 * Search instructors
 *  Search for instructors using flexible criteria with advanced operators.
 *
 * **Basic Search:**
 * - `field=value` - Exact match (default operation)
 * - `firstName=John` - Find instructors with firstName exactly "John"
 *
 * **Comparison Operators:**
 * - `field_gt=value` - Greater than
 * - `field_lt=value` - Less than
 * - `field_gte=value` - Greater than or equal
 * - `field_lte=value` - Less than or equal
 * - `createdDate_gte=2024-01-01T00:00:00` - Created after Jan 1, 2024
 *
 * **String Operations:**
 * - `field_like=value` - Contains (case-insensitive)
 * - `field_startswith=value` - Starts with (case-insensitive)
 * - `field_endswith=value` - Ends with (case-insensitive)
 * - `lastName_like=smith` - Last name contains "smith"
 *
 * **List Operations:**
 * - `field_in=val1,val2,val3` - Field is in list
 * - `field_notin=val1,val2` - Field is not in list
 * - `status_in=ACTIVE,PENDING` - Status is either ACTIVE or PENDING
 *
 * **Negation:**
 * - `field_noteq=value` - Not equal to value
 * - `isActive_noteq=false` - Is not false (i.e., is true)
 *
 * **Range Operations:**
 * - `field_between=start,end` - Value between start and end (inclusive)
 * - `createdDate_between=2024-01-01T00:00:00,2024-12-31T23:59:59` - Created in 2024
 *
 * **Complex Operations:**
 * - `field_notingroup=relationshipField,groupId` - Not in specific group
 *
 * **Nested Field Access:**
 * - `nestedObject.field=value` - Search in nested objects
 *
 * **Supported Data Types:**
 * - String, UUID, Boolean (true/false or 1/0), Integer, Long, Double, Float, BigDecimal
 * - Date (YYYY-MM-DD), Timestamp, LocalDateTime (ISO format)
 *
 * **Examples:**
 * - `/search?firstName_like=john&isActive=true&createdDate_gte=2024-01-01T00:00:00`
 * - `/search?experience_gt=5&status_in=ACTIVE,VERIFIED`
 * - `/search?email_endswith=@company.com&department_noteq=IT`
 *
 */
export const searchInstructorsInfiniteOptions = (options: Options<SearchInstructorsData>) => {
  return infiniteQueryOptions<
    SearchInstructorsResponse,
    SearchInstructorsError,
    InfiniteData<SearchInstructorsResponse>,
    QueryKey<Options<SearchInstructorsData>>,
    | number
    | Pick<QueryKey<Options<SearchInstructorsData>>[0], 'body' | 'headers' | 'path' | 'query'>
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<SearchInstructorsData>>[0],
          'body' | 'headers' | 'path' | 'query'
        > =
          typeof pageParam === 'object'
            ? pageParam
            : {
                query: {
                  'pageable.page': pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await searchInstructors({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: searchInstructorsInfiniteQueryKey(options),
    }
  );
};

export const searchMembershipsQueryKey = (options: Options<SearchMembershipsData>) =>
  createQueryKey('searchMemberships', options);

/**
 * Search instructor memberships
 * Search membership records with flexible criteria.
 *
 * **Common Membership Search Examples:**
 * - `instructorUuid=uuid` - All memberships for specific instructor
 * - `isActive=true` - Active memberships only
 * - `organizationName_like=professional` - Organizations with "professional" in name
 * - `startDate_gte=2023-01-01` - Memberships started in 2023 or later
 * - `endDate=null` - Ongoing memberships (no end date)
 * - `membershipNumber_startswith=PRO` - Numbers starting with "PRO"
 *
 * **Membership Analysis Queries:**
 * - `isActive=true&endDate=null` - Currently active ongoing memberships
 * - `isActive=false&endDate_gte=2024-01-01` - Recently expired memberships
 * - `startDate_between=2020-01-01,2023-12-31` - Joined between 2020-2023
 *
 * For complete operator documentation, see the main search endpoint.
 *
 */
export const searchMembershipsOptions = (options: Options<SearchMembershipsData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await searchMemberships({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: searchMembershipsQueryKey(options),
  });
};

export const searchMembershipsInfiniteQueryKey = (
  options: Options<SearchMembershipsData>
): QueryKey<Options<SearchMembershipsData>> => createQueryKey('searchMemberships', options, true);

/**
 * Search instructor memberships
 * Search membership records with flexible criteria.
 *
 * **Common Membership Search Examples:**
 * - `instructorUuid=uuid` - All memberships for specific instructor
 * - `isActive=true` - Active memberships only
 * - `organizationName_like=professional` - Organizations with "professional" in name
 * - `startDate_gte=2023-01-01` - Memberships started in 2023 or later
 * - `endDate=null` - Ongoing memberships (no end date)
 * - `membershipNumber_startswith=PRO` - Numbers starting with "PRO"
 *
 * **Membership Analysis Queries:**
 * - `isActive=true&endDate=null` - Currently active ongoing memberships
 * - `isActive=false&endDate_gte=2024-01-01` - Recently expired memberships
 * - `startDate_between=2020-01-01,2023-12-31` - Joined between 2020-2023
 *
 * For complete operator documentation, see the main search endpoint.
 *
 */
export const searchMembershipsInfiniteOptions = (options: Options<SearchMembershipsData>) => {
  return infiniteQueryOptions<
    SearchMembershipsResponse,
    SearchMembershipsError,
    InfiniteData<SearchMembershipsResponse>,
    QueryKey<Options<SearchMembershipsData>>,
    | number
    | Pick<QueryKey<Options<SearchMembershipsData>>[0], 'body' | 'headers' | 'path' | 'query'>
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<SearchMembershipsData>>[0],
          'body' | 'headers' | 'path' | 'query'
        > =
          typeof pageParam === 'object'
            ? pageParam
            : {
                query: {
                  'pageable.page': pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await searchMemberships({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: searchMembershipsInfiniteQueryKey(options),
    }
  );
};

export const searchExperienceQueryKey = (options: Options<SearchExperienceData>) =>
  createQueryKey('searchExperience', options);

/**
 * Search instructor experience
 * Search experience records with flexible criteria.
 *
 * **Common Experience Search Examples:**
 * - `instructorUuid=uuid` - All experience for specific instructor
 * - `isCurrentPosition=true` - Current positions only
 * - `position_like=manager` - Positions containing "manager"
 * - `organizationName_endswith=Ltd` - Organizations ending with "Ltd"
 * - `yearsOfExperience_gte=5` - 5+ years experience
 * - `startDate_gte=2020-01-01` - Started in 2020 or later
 * - `endDate=null` - Ongoing positions (no end date)
 * - `responsibilities_like=team` - Responsibilities mentioning "team"
 *
 * **Experience Analysis Queries:**
 * - `isCurrentPosition=false&endDate_gte=2023-01-01` - Recent past positions
 * - `yearsOfExperience_between=3,10` - Mid-level experience (3-10 years)
 *
 * For complete operator documentation, see the main search endpoint.
 *
 */
export const searchExperienceOptions = (options: Options<SearchExperienceData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await searchExperience({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: searchExperienceQueryKey(options),
  });
};

export const searchExperienceInfiniteQueryKey = (
  options: Options<SearchExperienceData>
): QueryKey<Options<SearchExperienceData>> => createQueryKey('searchExperience', options, true);

/**
 * Search instructor experience
 * Search experience records with flexible criteria.
 *
 * **Common Experience Search Examples:**
 * - `instructorUuid=uuid` - All experience for specific instructor
 * - `isCurrentPosition=true` - Current positions only
 * - `position_like=manager` - Positions containing "manager"
 * - `organizationName_endswith=Ltd` - Organizations ending with "Ltd"
 * - `yearsOfExperience_gte=5` - 5+ years experience
 * - `startDate_gte=2020-01-01` - Started in 2020 or later
 * - `endDate=null` - Ongoing positions (no end date)
 * - `responsibilities_like=team` - Responsibilities mentioning "team"
 *
 * **Experience Analysis Queries:**
 * - `isCurrentPosition=false&endDate_gte=2023-01-01` - Recent past positions
 * - `yearsOfExperience_between=3,10` - Mid-level experience (3-10 years)
 *
 * For complete operator documentation, see the main search endpoint.
 *
 */
export const searchExperienceInfiniteOptions = (options: Options<SearchExperienceData>) => {
  return infiniteQueryOptions<
    SearchExperienceResponse,
    SearchExperienceError,
    InfiniteData<SearchExperienceResponse>,
    QueryKey<Options<SearchExperienceData>>,
    number | Pick<QueryKey<Options<SearchExperienceData>>[0], 'body' | 'headers' | 'path' | 'query'>
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<SearchExperienceData>>[0],
          'body' | 'headers' | 'path' | 'query'
        > =
          typeof pageParam === 'object'
            ? pageParam
            : {
                query: {
                  'pageable.page': pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await searchExperience({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: searchExperienceInfiniteQueryKey(options),
    }
  );
};

export const searchEducationQueryKey = (options: Options<SearchEducationData>) =>
  createQueryKey('searchEducation', options);

/**
 * Search instructor education
 * Search education records with flexible criteria.
 *
 * **Common Education Search Examples:**
 * - `instructorUuid=uuid` - All education for specific instructor
 * - `qualification_like=degree` - Qualifications containing "degree"
 * - `schoolName_startswith=University` - Schools starting with "University"
 * - `yearCompleted_gte=2020` - Completed in 2020 or later
 * - `yearCompleted_between=2015,2020` - Completed between 2015-2020
 * - `certificateNumber_noteq=null` - Has certificate number
 *
 * For complete operator documentation, see the main search endpoint.
 *
 */
export const searchEducationOptions = (options: Options<SearchEducationData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await searchEducation({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: searchEducationQueryKey(options),
  });
};

export const searchEducationInfiniteQueryKey = (
  options: Options<SearchEducationData>
): QueryKey<Options<SearchEducationData>> => createQueryKey('searchEducation', options, true);

/**
 * Search instructor education
 * Search education records with flexible criteria.
 *
 * **Common Education Search Examples:**
 * - `instructorUuid=uuid` - All education for specific instructor
 * - `qualification_like=degree` - Qualifications containing "degree"
 * - `schoolName_startswith=University` - Schools starting with "University"
 * - `yearCompleted_gte=2020` - Completed in 2020 or later
 * - `yearCompleted_between=2015,2020` - Completed between 2015-2020
 * - `certificateNumber_noteq=null` - Has certificate number
 *
 * For complete operator documentation, see the main search endpoint.
 *
 */
export const searchEducationInfiniteOptions = (options: Options<SearchEducationData>) => {
  return infiniteQueryOptions<
    SearchEducationResponse,
    SearchEducationError,
    InfiniteData<SearchEducationResponse>,
    QueryKey<Options<SearchEducationData>>,
    number | Pick<QueryKey<Options<SearchEducationData>>[0], 'body' | 'headers' | 'path' | 'query'>
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<SearchEducationData>>[0],
          'body' | 'headers' | 'path' | 'query'
        > =
          typeof pageParam === 'object'
            ? pageParam
            : {
                query: {
                  'pageable.page': pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await searchEducation({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: searchEducationInfiniteQueryKey(options),
    }
  );
};

export const searchDocumentsQueryKey = (options: Options<SearchDocumentsData>) =>
  createQueryKey('searchDocuments', options);

/**
 * Search instructor documents
 * Search documents with flexible criteria using advanced operators.
 *
 * **Common Document Search Examples:**
 * - `instructorUuid=uuid` - All documents for specific instructor
 * - `isVerified=false` - Unverified documents
 * - `status=PENDING` - Documents with pending status
 * - `status_in=APPROVED,VERIFIED` - Approved or verified documents
 * - `expiryDate_lte=2025-12-31` - Documents expiring by end of 2025
 * - `mimeType_like=pdf` - PDF documents
 * - `fileSizeBytes_gt=1048576` - Files larger than 1MB
 * - `title_startswith=Certificate` - Titles starting with "Certificate"
 * - `createdDate_between=2024-01-01T00:00:00,2024-12-31T23:59:59` - Created in 2024
 *
 * **Special Document Queries:**
 * - `isVerified=false&expiryDate_lte=2025-12-31` - Unverified expiring documents
 * - `status_noteq=EXPIRED&expiryDate_lt=2025-07-02` - Non-expired but overdue docs
 *
 * For complete operator documentation, see the main search endpoint.
 *
 */
export const searchDocumentsOptions = (options: Options<SearchDocumentsData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await searchDocuments({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: searchDocumentsQueryKey(options),
  });
};

export const searchDocumentsInfiniteQueryKey = (
  options: Options<SearchDocumentsData>
): QueryKey<Options<SearchDocumentsData>> => createQueryKey('searchDocuments', options, true);

/**
 * Search instructor documents
 * Search documents with flexible criteria using advanced operators.
 *
 * **Common Document Search Examples:**
 * - `instructorUuid=uuid` - All documents for specific instructor
 * - `isVerified=false` - Unverified documents
 * - `status=PENDING` - Documents with pending status
 * - `status_in=APPROVED,VERIFIED` - Approved or verified documents
 * - `expiryDate_lte=2025-12-31` - Documents expiring by end of 2025
 * - `mimeType_like=pdf` - PDF documents
 * - `fileSizeBytes_gt=1048576` - Files larger than 1MB
 * - `title_startswith=Certificate` - Titles starting with "Certificate"
 * - `createdDate_between=2024-01-01T00:00:00,2024-12-31T23:59:59` - Created in 2024
 *
 * **Special Document Queries:**
 * - `isVerified=false&expiryDate_lte=2025-12-31` - Unverified expiring documents
 * - `status_noteq=EXPIRED&expiryDate_lt=2025-07-02` - Non-expired but overdue docs
 *
 * For complete operator documentation, see the main search endpoint.
 *
 */
export const searchDocumentsInfiniteOptions = (options: Options<SearchDocumentsData>) => {
  return infiniteQueryOptions<
    SearchDocumentsResponse,
    SearchDocumentsError,
    InfiniteData<SearchDocumentsResponse>,
    QueryKey<Options<SearchDocumentsData>>,
    number | Pick<QueryKey<Options<SearchDocumentsData>>[0], 'body' | 'headers' | 'path' | 'query'>
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<SearchDocumentsData>>[0],
          'body' | 'headers' | 'path' | 'query'
        > =
          typeof pageParam === 'object'
            ? pageParam
            : {
                query: {
                  'pageable.page': pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await searchDocuments({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: searchDocumentsInfiniteQueryKey(options),
    }
  );
};

export const getStudentDashboardQueryKey = (options: Options<GetStudentDashboardData>) =>
  createQueryKey('getStudentDashboard', options);

/**
 * Fetch learner dashboard for guardian access
 */
export const getStudentDashboardOptions = (options: Options<GetStudentDashboardData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getStudentDashboard({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getStudentDashboardQueryKey(options),
  });
};

export const getMyStudentsQueryKey = (options?: Options<GetMyStudentsData>) =>
  createQueryKey('getMyStudents', options);

/**
 * List guardian-linked students
 */
export const getMyStudentsOptions = (options?: Options<GetMyStudentsData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getMyStudents({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getMyStudentsQueryKey(options),
  });
};

/**
 * Cancel a student enrollment
 */
export const cancelEnrollmentMutation = (
  options?: Partial<Options<CancelEnrollmentData>>
): UseMutationOptions<
  CancelEnrollmentResponse,
  CancelEnrollmentError,
  Options<CancelEnrollmentData>
> => {
  const mutationOptions: UseMutationOptions<
    CancelEnrollmentResponse,
    CancelEnrollmentError,
    Options<CancelEnrollmentData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await cancelEnrollment({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getEnrollmentQueryKey = (options: Options<GetEnrollmentData>) =>
  createQueryKey('getEnrollment', options);

/**
 * Get an enrollment by UUID
 */
export const getEnrollmentOptions = (options: Options<GetEnrollmentData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getEnrollment({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getEnrollmentQueryKey(options),
  });
};

export const getStudentScheduleQueryKey = (options: Options<GetStudentScheduleData>) =>
  createQueryKey('getStudentSchedule', options);

/**
 * Get schedule for a specific student within a date range
 */
export const getStudentScheduleOptions = (options: Options<GetStudentScheduleData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getStudentSchedule({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getStudentScheduleQueryKey(options),
  });
};

export const getStudentScheduleInfiniteQueryKey = (
  options: Options<GetStudentScheduleData>
): QueryKey<Options<GetStudentScheduleData>> => createQueryKey('getStudentSchedule', options, true);

/**
 * Get schedule for a specific student within a date range
 */
export const getStudentScheduleInfiniteOptions = (options: Options<GetStudentScheduleData>) => {
  return infiniteQueryOptions<
    GetStudentScheduleResponse,
    GetStudentScheduleError,
    InfiniteData<GetStudentScheduleResponse>,
    QueryKey<Options<GetStudentScheduleData>>,
    Date | Pick<QueryKey<Options<GetStudentScheduleData>>[0], 'body' | 'headers' | 'path' | 'query'>
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<GetStudentScheduleData>>[0],
          'body' | 'headers' | 'path' | 'query'
        > =
          typeof pageParam === 'object'
            ? pageParam
            : {
                query: {
                  start: pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getStudentSchedule({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: getStudentScheduleInfiniteQueryKey(options),
    }
  );
};

export const getEnrollmentsForInstanceQueryKey = (
  options: Options<GetEnrollmentsForInstanceData>
) => createQueryKey('getEnrollmentsForInstance', options);

/**
 * Get all enrollments for a scheduled instance
 */
export const getEnrollmentsForInstanceOptions = (
  options: Options<GetEnrollmentsForInstanceData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getEnrollmentsForInstance({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getEnrollmentsForInstanceQueryKey(options),
  });
};

export const getEnrollmentCountQueryKey = (options: Options<GetEnrollmentCountData>) =>
  createQueryKey('getEnrollmentCount', options);

/**
 * Get enrollment count for a scheduled instance
 */
export const getEnrollmentCountOptions = (options: Options<GetEnrollmentCountData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getEnrollmentCount({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getEnrollmentCountQueryKey(options),
  });
};

export const hasCapacityForEnrollmentQueryKey = (options: Options<HasCapacityForEnrollmentData>) =>
  createQueryKey('hasCapacityForEnrollment', options);

/**
 * Check if a scheduled instance has capacity for new enrollments
 */
export const hasCapacityForEnrollmentOptions = (options: Options<HasCapacityForEnrollmentData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await hasCapacityForEnrollment({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: hasCapacityForEnrollmentQueryKey(options),
  });
};

export const listCurrenciesQueryKey = (options: Options<ListCurrenciesData>) =>
  createQueryKey('listCurrencies', options);

/**
 * List platform currencies (paginated)
 */
export const listCurrenciesOptions = (options: Options<ListCurrenciesData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await listCurrencies({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: listCurrenciesQueryKey(options),
  });
};

export const listCurrenciesInfiniteQueryKey = (
  options: Options<ListCurrenciesData>
): QueryKey<Options<ListCurrenciesData>> => createQueryKey('listCurrencies', options, true);

/**
 * List platform currencies (paginated)
 */
export const listCurrenciesInfiniteOptions = (options: Options<ListCurrenciesData>) => {
  return infiniteQueryOptions<
    ListCurrenciesResponse,
    ListCurrenciesError,
    InfiniteData<ListCurrenciesResponse>,
    QueryKey<Options<ListCurrenciesData>>,
    number | Pick<QueryKey<Options<ListCurrenciesData>>[0], 'body' | 'headers' | 'path' | 'query'>
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<ListCurrenciesData>>[0],
          'body' | 'headers' | 'path' | 'query'
        > =
          typeof pageParam === 'object'
            ? pageParam
            : {
                query: {
                  'pageable.page': pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await listCurrencies({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: listCurrenciesInfiniteQueryKey(options),
    }
  );
};

export const getDefaultCurrencyQueryKey = (options?: Options<GetDefaultCurrencyData>) =>
  createQueryKey('getDefaultCurrency', options);

/**
 * Get the platform default currency
 */
export const getDefaultCurrencyOptions = (options?: Options<GetDefaultCurrencyData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getDefaultCurrency({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getDefaultCurrencyQueryKey(options),
  });
};

export const getStatusTransitionsQueryKey = (options: Options<GetStatusTransitionsData>) =>
  createQueryKey('getStatusTransitions', options);

/**
 * Get available status transitions
 * Returns the list of valid status transitions for a course based on its current state and business rules.
 *
 * **Status Transition Rules:**
 * - DRAFT  IN_REVIEW, ARCHIVED
 * - IN_REVIEW  DRAFT, PUBLISHED, ARCHIVED
 * - PUBLISHED  DRAFT (if no active enrollments), ARCHIVED
 * - ARCHIVED  (no transitions - permanent state)
 *
 */
export const getStatusTransitionsOptions = (options: Options<GetStatusTransitionsData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getStatusTransitions({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getStatusTransitionsQueryKey(options),
  });
};

export const checkRubricAssociationQueryKey = (options: Options<CheckRubricAssociationData>) =>
  createQueryKey('checkRubricAssociation', options);

/**
 * Check if rubric is associated with course
 * Checks whether a specific rubric is already associated with the course.
 */
export const checkRubricAssociationOptions = (options: Options<CheckRubricAssociationData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await checkRubricAssociation({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: checkRubricAssociationQueryKey(options),
  });
};

export const getPrimaryRubricQueryKey = (options: Options<GetPrimaryRubricData>) =>
  createQueryKey('getPrimaryRubric', options);

/**
 * Get primary rubric for a course
 * Retrieves the primary rubric association for the specified course.
 */
export const getPrimaryRubricOptions = (options: Options<GetPrimaryRubricData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getPrimaryRubric({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getPrimaryRubricQueryKey(options),
  });
};

export const getRubricsByContextQueryKey = (options: Options<GetRubricsByContextData>) =>
  createQueryKey('getRubricsByContext', options);

/**
 * Get rubrics by usage context
 * Retrieves rubric associations for a specific usage context (e.g., 'midterm', 'final', 'assignment').
 */
export const getRubricsByContextOptions = (options: Options<GetRubricsByContextData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getRubricsByContext({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getRubricsByContextQueryKey(options),
  });
};

export const getRubricsByContextInfiniteQueryKey = (
  options: Options<GetRubricsByContextData>
): QueryKey<Options<GetRubricsByContextData>> =>
  createQueryKey('getRubricsByContext', options, true);

/**
 * Get rubrics by usage context
 * Retrieves rubric associations for a specific usage context (e.g., 'midterm', 'final', 'assignment').
 */
export const getRubricsByContextInfiniteOptions = (options: Options<GetRubricsByContextData>) => {
  return infiniteQueryOptions<
    GetRubricsByContextResponse,
    GetRubricsByContextError,
    InfiniteData<GetRubricsByContextResponse>,
    QueryKey<Options<GetRubricsByContextData>>,
    | number
    | Pick<QueryKey<Options<GetRubricsByContextData>>[0], 'body' | 'headers' | 'path' | 'query'>
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<GetRubricsByContextData>>[0],
          'body' | 'headers' | 'path' | 'query'
        > =
          typeof pageParam === 'object'
            ? pageParam
            : {
                query: {
                  'pageable.page': pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getRubricsByContext({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: getRubricsByContextInfiniteQueryKey(options),
    }
  );
};

export const getCourseEnrollmentsQueryKey = (options: Options<GetCourseEnrollmentsData>) =>
  createQueryKey('getCourseEnrollments', options);

/**
 * Get course enrollments
 * Retrieves enrollment data for a specific course with analytics.
 */
export const getCourseEnrollmentsOptions = (options: Options<GetCourseEnrollmentsData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getCourseEnrollments({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getCourseEnrollmentsQueryKey(options),
  });
};

export const getCourseEnrollmentsInfiniteQueryKey = (
  options: Options<GetCourseEnrollmentsData>
): QueryKey<Options<GetCourseEnrollmentsData>> =>
  createQueryKey('getCourseEnrollments', options, true);

/**
 * Get course enrollments
 * Retrieves enrollment data for a specific course with analytics.
 */
export const getCourseEnrollmentsInfiniteOptions = (options: Options<GetCourseEnrollmentsData>) => {
  return infiniteQueryOptions<
    GetCourseEnrollmentsResponse,
    GetCourseEnrollmentsError,
    InfiniteData<GetCourseEnrollmentsResponse>,
    QueryKey<Options<GetCourseEnrollmentsData>>,
    | number
    | Pick<QueryKey<Options<GetCourseEnrollmentsData>>[0], 'body' | 'headers' | 'path' | 'query'>
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<GetCourseEnrollmentsData>>[0],
          'body' | 'headers' | 'path' | 'query'
        > =
          typeof pageParam === 'object'
            ? pageParam
            : {
                query: {
                  'pageable.page': pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getCourseEnrollments({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: getCourseEnrollmentsInfiniteQueryKey(options),
    }
  );
};

export const getCourseCompletionRateQueryKey = (options: Options<GetCourseCompletionRateData>) =>
  createQueryKey('getCourseCompletionRate', options);

/**
 * Get course completion rate
 * Returns the completion rate percentage for a course.
 */
export const getCourseCompletionRateOptions = (options: Options<GetCourseCompletionRateData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getCourseCompletionRate({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getCourseCompletionRateQueryKey(options),
  });
};

/**
 * Remove all categories from course
 * Removes all category associations from a course.
 */
export const removeAllCategoriesFromCourseMutation = (
  options?: Partial<Options<RemoveAllCategoriesFromCourseData>>
): UseMutationOptions<
  RemoveAllCategoriesFromCourseResponse,
  RemoveAllCategoriesFromCourseError,
  Options<RemoveAllCategoriesFromCourseData>
> => {
  const mutationOptions: UseMutationOptions<
    RemoveAllCategoriesFromCourseResponse,
    RemoveAllCategoriesFromCourseError,
    Options<RemoveAllCategoriesFromCourseData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await removeAllCategoriesFromCourse({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getCourseCategoriesQueryKey = (options: Options<GetCourseCategoriesData>) =>
  createQueryKey('getCourseCategories', options);

/**
 * Get course categories
 * Retrieves all categories assigned to a specific course.
 */
export const getCourseCategoriesOptions = (options: Options<GetCourseCategoriesData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getCourseCategories({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getCourseCategoriesQueryKey(options),
  });
};

export const searchTrainingApplicationsQueryKey = (
  options: Options<SearchTrainingApplicationsData>
) => createQueryKey('searchTrainingApplications', options);

/**
 * Search training applications
 * Advanced search for training applications using flexible operators on any DTO field.
 * Supports filters such as `status`, `applicantType`, `courseUuid`, `applicantUuid`, `createdDate_between`, and more.
 *
 */
export const searchTrainingApplicationsOptions = (
  options: Options<SearchTrainingApplicationsData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await searchTrainingApplications({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: searchTrainingApplicationsQueryKey(options),
  });
};

export const searchTrainingApplicationsInfiniteQueryKey = (
  options: Options<SearchTrainingApplicationsData>
): QueryKey<Options<SearchTrainingApplicationsData>> =>
  createQueryKey('searchTrainingApplications', options, true);

/**
 * Search training applications
 * Advanced search for training applications using flexible operators on any DTO field.
 * Supports filters such as `status`, `applicantType`, `courseUuid`, `applicantUuid`, `createdDate_between`, and more.
 *
 */
export const searchTrainingApplicationsInfiniteOptions = (
  options: Options<SearchTrainingApplicationsData>
) => {
  return infiniteQueryOptions<
    SearchTrainingApplicationsResponse,
    SearchTrainingApplicationsError,
    InfiniteData<SearchTrainingApplicationsResponse>,
    QueryKey<Options<SearchTrainingApplicationsData>>,
    | number
    | Pick<
        QueryKey<Options<SearchTrainingApplicationsData>>[0],
        'body' | 'headers' | 'path' | 'query'
      >
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<SearchTrainingApplicationsData>>[0],
          'body' | 'headers' | 'path' | 'query'
        > =
          typeof pageParam === 'object'
            ? pageParam
            : {
                query: {
                  'pageable.page': pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await searchTrainingApplications({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: searchTrainingApplicationsInfiniteQueryKey(options),
    }
  );
};

export const searchCoursesQueryKey = (options: Options<SearchCoursesData>) =>
  createQueryKey('searchCourses', options);

/**
 * Search courses with enhanced category filtering
 * Advanced course search with flexible criteria and operators, including category-based filtering.
 *
 * **Category-Specific Search Examples:**
 * - `categoryUuids_in=uuid1,uuid2` - Courses in any of these categories
 * - `categoryUuids_contains=uuid` - Courses containing specific category
 * - `categoryNames_like=programming` - Courses in categories with "programming" in the name
 * - `categoryCount_gte=2` - Courses assigned to 2 or more categories
 * - `hasMultipleCategories=true` - Courses with multiple category assignments
 *
 * **Combined Search Examples:**
 * - `status=PUBLISHED&categoryUuids_in=uuid1,uuid2&price_lte=100` - Published courses under $100 in specific categories
 * - `name_like=java&categoryNames_like=programming&active=true` - Active Java courses in programming categories
 *
 * For complete operator documentation, see the general course search endpoint.
 *
 */
export const searchCoursesOptions = (options: Options<SearchCoursesData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await searchCourses({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: searchCoursesQueryKey(options),
  });
};

export const searchCoursesInfiniteQueryKey = (
  options: Options<SearchCoursesData>
): QueryKey<Options<SearchCoursesData>> => createQueryKey('searchCourses', options, true);

/**
 * Search courses with enhanced category filtering
 * Advanced course search with flexible criteria and operators, including category-based filtering.
 *
 * **Category-Specific Search Examples:**
 * - `categoryUuids_in=uuid1,uuid2` - Courses in any of these categories
 * - `categoryUuids_contains=uuid` - Courses containing specific category
 * - `categoryNames_like=programming` - Courses in categories with "programming" in the name
 * - `categoryCount_gte=2` - Courses assigned to 2 or more categories
 * - `hasMultipleCategories=true` - Courses with multiple category assignments
 *
 * **Combined Search Examples:**
 * - `status=PUBLISHED&categoryUuids_in=uuid1,uuid2&price_lte=100` - Published courses under $100 in specific categories
 * - `name_like=java&categoryNames_like=programming&active=true` - Active Java courses in programming categories
 *
 * For complete operator documentation, see the general course search endpoint.
 *
 */
export const searchCoursesInfiniteOptions = (options: Options<SearchCoursesData>) => {
  return infiniteQueryOptions<
    SearchCoursesResponse,
    SearchCoursesError,
    InfiniteData<SearchCoursesResponse>,
    QueryKey<Options<SearchCoursesData>>,
    number | Pick<QueryKey<Options<SearchCoursesData>>[0], 'body' | 'headers' | 'path' | 'query'>
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<SearchCoursesData>>[0],
          'body' | 'headers' | 'path' | 'query'
        > =
          typeof pageParam === 'object'
            ? pageParam
            : {
                query: {
                  'pageable.page': pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await searchCourses({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: searchCoursesInfiniteQueryKey(options),
    }
  );
};

export const getPublishedCoursesQueryKey = (options: Options<GetPublishedCoursesData>) =>
  createQueryKey('getPublishedCourses', options);

/**
 * Get published courses
 * Retrieves all published courses available for enrollment.
 */
export const getPublishedCoursesOptions = (options: Options<GetPublishedCoursesData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getPublishedCourses({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getPublishedCoursesQueryKey(options),
  });
};

export const getPublishedCoursesInfiniteQueryKey = (
  options: Options<GetPublishedCoursesData>
): QueryKey<Options<GetPublishedCoursesData>> =>
  createQueryKey('getPublishedCourses', options, true);

/**
 * Get published courses
 * Retrieves all published courses available for enrollment.
 */
export const getPublishedCoursesInfiniteOptions = (options: Options<GetPublishedCoursesData>) => {
  return infiniteQueryOptions<
    GetPublishedCoursesResponse,
    GetPublishedCoursesError,
    InfiniteData<GetPublishedCoursesResponse>,
    QueryKey<Options<GetPublishedCoursesData>>,
    | number
    | Pick<QueryKey<Options<GetPublishedCoursesData>>[0], 'body' | 'headers' | 'path' | 'query'>
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<GetPublishedCoursesData>>[0],
          'body' | 'headers' | 'path' | 'query'
        > =
          typeof pageParam === 'object'
            ? pageParam
            : {
                query: {
                  'pageable.page': pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getPublishedCourses({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: getPublishedCoursesInfiniteQueryKey(options),
    }
  );
};

export const getCourseMediaQueryKey = (options: Options<GetCourseMediaData>) =>
  createQueryKey('getCourseMedia', options);

/**
 * Get course media by file name
 * Retrieves course media files (thumbnails, banners, intro videos) by their file name.
 * This endpoint serves the actual media files with appropriate content types and caching headers.
 *
 * **File Types Served:**
 * - Course thumbnails from course_thumbnails folder
 * - Course banners from course_banners folder
 * - Course intro videos from course_intro_videos folder
 *
 * **Response Features:**
 * - Automatic content type detection
 * - Optimized caching headers for performance
 * - Support for range requests (for videos)
 * - Proper file serving with inline disposition
 *
 * **Usage:**
 * - File names are typically returned from upload endpoints
 * - URLs are automatically generated and stored in course records
 * - Direct access via this endpoint for custom implementations
 *
 */
export const getCourseMediaOptions = (options: Options<GetCourseMediaData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getCourseMedia({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getCourseMediaQueryKey(options),
  });
};

export const getCoursesByInstructorQueryKey = (options: Options<GetCoursesByInstructorData>) =>
  createQueryKey('getCoursesByInstructor', options);

/**
 * Get courses by instructor
 * Retrieves all courses created by a specific instructor.
 */
export const getCoursesByInstructorOptions = (options: Options<GetCoursesByInstructorData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getCoursesByInstructor({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getCoursesByInstructorQueryKey(options),
  });
};

export const getCoursesByInstructorInfiniteQueryKey = (
  options: Options<GetCoursesByInstructorData>
): QueryKey<Options<GetCoursesByInstructorData>> =>
  createQueryKey('getCoursesByInstructor', options, true);

/**
 * Get courses by instructor
 * Retrieves all courses created by a specific instructor.
 */
export const getCoursesByInstructorInfiniteOptions = (
  options: Options<GetCoursesByInstructorData>
) => {
  return infiniteQueryOptions<
    GetCoursesByInstructorResponse,
    GetCoursesByInstructorError,
    InfiniteData<GetCoursesByInstructorResponse>,
    QueryKey<Options<GetCoursesByInstructorData>>,
    | number
    | Pick<QueryKey<Options<GetCoursesByInstructorData>>[0], 'body' | 'headers' | 'path' | 'query'>
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<GetCoursesByInstructorData>>[0],
          'body' | 'headers' | 'path' | 'query'
        > =
          typeof pageParam === 'object'
            ? pageParam
            : {
                query: {
                  'pageable.page': pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getCoursesByInstructor({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: getCoursesByInstructorInfiniteQueryKey(options),
    }
  );
};

export const getCoursesByCategoryQueryKey = (options: Options<GetCoursesByCategoryData>) =>
  createQueryKey('getCoursesByCategory', options);

/**
 * Get courses by category
 * Retrieves all courses in a specific category.
 *
 * **Enhanced Category Search:**
 * This endpoint now supports the many-to-many relationship, returning courses that have
 * the specified category assigned to them, regardless of what other categories they may also have.
 *
 */
export const getCoursesByCategoryOptions = (options: Options<GetCoursesByCategoryData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getCoursesByCategory({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getCoursesByCategoryQueryKey(options),
  });
};

export const getCoursesByCategoryInfiniteQueryKey = (
  options: Options<GetCoursesByCategoryData>
): QueryKey<Options<GetCoursesByCategoryData>> =>
  createQueryKey('getCoursesByCategory', options, true);

/**
 * Get courses by category
 * Retrieves all courses in a specific category.
 *
 * **Enhanced Category Search:**
 * This endpoint now supports the many-to-many relationship, returning courses that have
 * the specified category assigned to them, regardless of what other categories they may also have.
 *
 */
export const getCoursesByCategoryInfiniteOptions = (options: Options<GetCoursesByCategoryData>) => {
  return infiniteQueryOptions<
    GetCoursesByCategoryResponse,
    GetCoursesByCategoryError,
    InfiniteData<GetCoursesByCategoryResponse>,
    QueryKey<Options<GetCoursesByCategoryData>>,
    | number
    | Pick<QueryKey<Options<GetCoursesByCategoryData>>[0], 'body' | 'headers' | 'path' | 'query'>
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<GetCoursesByCategoryData>>[0],
          'body' | 'headers' | 'path' | 'query'
        > =
          typeof pageParam === 'object'
            ? pageParam
            : {
                query: {
                  'pageable.page': pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getCoursesByCategory({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: getCoursesByCategoryInfiniteQueryKey(options),
    }
  );
};

export const getActiveCoursesQueryKey = (options: Options<GetActiveCoursesData>) =>
  createQueryKey('getActiveCourses', options);

/**
 * Get active courses
 * Retrieves all currently active and published courses.
 */
export const getActiveCoursesOptions = (options: Options<GetActiveCoursesData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getActiveCourses({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getActiveCoursesQueryKey(options),
  });
};

export const getActiveCoursesInfiniteQueryKey = (
  options: Options<GetActiveCoursesData>
): QueryKey<Options<GetActiveCoursesData>> => createQueryKey('getActiveCourses', options, true);

/**
 * Get active courses
 * Retrieves all currently active and published courses.
 */
export const getActiveCoursesInfiniteOptions = (options: Options<GetActiveCoursesData>) => {
  return infiniteQueryOptions<
    GetActiveCoursesResponse,
    GetActiveCoursesError,
    InfiniteData<GetActiveCoursesResponse>,
    QueryKey<Options<GetActiveCoursesData>>,
    number | Pick<QueryKey<Options<GetActiveCoursesData>>[0], 'body' | 'headers' | 'path' | 'query'>
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<GetActiveCoursesData>>[0],
          'body' | 'headers' | 'path' | 'query'
        > =
          typeof pageParam === 'object'
            ? pageParam
            : {
                query: {
                  'pageable.page': pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getActiveCourses({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: getActiveCoursesInfiniteQueryKey(options),
    }
  );
};

export const isCourseCreatorVerifiedQueryKey = (options: Options<IsCourseCreatorVerifiedData>) =>
  createQueryKey('isCourseCreatorVerified', options);

/**
 * Check if course creator is verified
 * Returns the verification status of a course creator.
 */
export const isCourseCreatorVerifiedOptions = (options: Options<IsCourseCreatorVerifiedData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await isCourseCreatorVerified({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: isCourseCreatorVerifiedQueryKey(options),
  });
};

export const getVerifiedCourseCreatorsQueryKey = (
  options: Options<GetVerifiedCourseCreatorsData>
) => createQueryKey('getVerifiedCourseCreators', options);

/**
 * Get verified course creators
 * Fetches a paginated list of all verified course creators.
 */
export const getVerifiedCourseCreatorsOptions = (
  options: Options<GetVerifiedCourseCreatorsData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getVerifiedCourseCreators({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getVerifiedCourseCreatorsQueryKey(options),
  });
};

export const getVerifiedCourseCreatorsInfiniteQueryKey = (
  options: Options<GetVerifiedCourseCreatorsData>
): QueryKey<Options<GetVerifiedCourseCreatorsData>> =>
  createQueryKey('getVerifiedCourseCreators', options, true);

/**
 * Get verified course creators
 * Fetches a paginated list of all verified course creators.
 */
export const getVerifiedCourseCreatorsInfiniteOptions = (
  options: Options<GetVerifiedCourseCreatorsData>
) => {
  return infiniteQueryOptions<
    GetVerifiedCourseCreatorsResponse,
    GetVerifiedCourseCreatorsError,
    InfiniteData<GetVerifiedCourseCreatorsResponse>,
    QueryKey<Options<GetVerifiedCourseCreatorsData>>,
    | number
    | Pick<
        QueryKey<Options<GetVerifiedCourseCreatorsData>>[0],
        'body' | 'headers' | 'path' | 'query'
      >
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<GetVerifiedCourseCreatorsData>>[0],
          'body' | 'headers' | 'path' | 'query'
        > =
          typeof pageParam === 'object'
            ? pageParam
            : {
                query: {
                  'pageable.page': pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getVerifiedCourseCreators({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: getVerifiedCourseCreatorsInfiniteQueryKey(options),
    }
  );
};

export const getUnverifiedCourseCreatorsQueryKey = (
  options: Options<GetUnverifiedCourseCreatorsData>
) => createQueryKey('getUnverifiedCourseCreators', options);

/**
 * Get unverified course creators
 * Fetches a paginated list of all unverified course creators pending admin review.
 */
export const getUnverifiedCourseCreatorsOptions = (
  options: Options<GetUnverifiedCourseCreatorsData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getUnverifiedCourseCreators({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getUnverifiedCourseCreatorsQueryKey(options),
  });
};

export const getUnverifiedCourseCreatorsInfiniteQueryKey = (
  options: Options<GetUnverifiedCourseCreatorsData>
): QueryKey<Options<GetUnverifiedCourseCreatorsData>> =>
  createQueryKey('getUnverifiedCourseCreators', options, true);

/**
 * Get unverified course creators
 * Fetches a paginated list of all unverified course creators pending admin review.
 */
export const getUnverifiedCourseCreatorsInfiniteOptions = (
  options: Options<GetUnverifiedCourseCreatorsData>
) => {
  return infiniteQueryOptions<
    GetUnverifiedCourseCreatorsResponse,
    GetUnverifiedCourseCreatorsError,
    InfiniteData<GetUnverifiedCourseCreatorsResponse>,
    QueryKey<Options<GetUnverifiedCourseCreatorsData>>,
    | number
    | Pick<
        QueryKey<Options<GetUnverifiedCourseCreatorsData>>[0],
        'body' | 'headers' | 'path' | 'query'
      >
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<GetUnverifiedCourseCreatorsData>>[0],
          'body' | 'headers' | 'path' | 'query'
        > =
          typeof pageParam === 'object'
            ? pageParam
            : {
                query: {
                  'pageable.page': pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getUnverifiedCourseCreators({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: getUnverifiedCourseCreatorsInfiniteQueryKey(options),
    }
  );
};

export const searchCourseCreatorSkillsQueryKey = (
  options: Options<SearchCourseCreatorSkillsData>
) => createQueryKey('searchCourseCreatorSkills', options);

/**
 * Search course creator skills
 * Advanced search endpoint for course creator skills using query parameters.
 */
export const searchCourseCreatorSkillsOptions = (
  options: Options<SearchCourseCreatorSkillsData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await searchCourseCreatorSkills({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: searchCourseCreatorSkillsQueryKey(options),
  });
};

export const searchCourseCreatorSkillsInfiniteQueryKey = (
  options: Options<SearchCourseCreatorSkillsData>
): QueryKey<Options<SearchCourseCreatorSkillsData>> =>
  createQueryKey('searchCourseCreatorSkills', options, true);

/**
 * Search course creator skills
 * Advanced search endpoint for course creator skills using query parameters.
 */
export const searchCourseCreatorSkillsInfiniteOptions = (
  options: Options<SearchCourseCreatorSkillsData>
) => {
  return infiniteQueryOptions<
    SearchCourseCreatorSkillsResponse,
    SearchCourseCreatorSkillsError,
    InfiniteData<SearchCourseCreatorSkillsResponse>,
    QueryKey<Options<SearchCourseCreatorSkillsData>>,
    | number
    | Pick<
        QueryKey<Options<SearchCourseCreatorSkillsData>>[0],
        'body' | 'headers' | 'path' | 'query'
      >
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<SearchCourseCreatorSkillsData>>[0],
          'body' | 'headers' | 'path' | 'query'
        > =
          typeof pageParam === 'object'
            ? pageParam
            : {
                query: {
                  'pageable.page': pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await searchCourseCreatorSkills({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: searchCourseCreatorSkillsInfiniteQueryKey(options),
    }
  );
};

export const searchCourseCreatorsQueryKey = (options: Options<SearchCourseCreatorsData>) =>
  createQueryKey('searchCourseCreators', options);

/**
 * Search course creators
 *  Search for course creators using flexible criteria with advanced operators.
 *
 * **Basic Search:**
 * - `field=value` - Exact match (default operation)
 * - `fullName=John` - Find course creators with fullName exactly "John"
 *
 * **Comparison Operators:**
 * - `field_gt=value` - Greater than
 * - `field_lt=value` - Less than
 * - `field_gte=value` - Greater than or equal
 * - `field_lte=value` - Less than or equal
 * - `createdDate_gte=2024-01-01T00:00:00` - Created after Jan 1, 2024
 *
 * **String Operations:**
 * - `field_like=value` - Contains (case-insensitive)
 * - `field_startswith=value` - Starts with (case-insensitive)
 * - `field_endswith=value` - Ends with (case-insensitive)
 * - `fullName_like=alice` - Full name contains "alice"
 *
 * **Boolean Operations:**
 * - `adminVerified=true` - Only verified course creators
 * - `adminVerified=false` - Only unverified course creators
 *
 * **List Operations:**
 * - `field_in=val1,val2,val3` - Field is in list
 * - `field_notin=val1,val2` - Field is not in list
 *
 * **Negation:**
 * - `field_noteq=value` - Not equal to value
 *
 * **Examples:**
 * - `/search?fullName_like=john&adminVerified=true`
 * - `/search?createdDate_gte=2024-01-01T00:00:00`
 * - `/search?professionalHeadline_like=content`
 *
 */
export const searchCourseCreatorsOptions = (options: Options<SearchCourseCreatorsData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await searchCourseCreators({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: searchCourseCreatorsQueryKey(options),
  });
};

export const searchCourseCreatorsInfiniteQueryKey = (
  options: Options<SearchCourseCreatorsData>
): QueryKey<Options<SearchCourseCreatorsData>> =>
  createQueryKey('searchCourseCreators', options, true);

/**
 * Search course creators
 *  Search for course creators using flexible criteria with advanced operators.
 *
 * **Basic Search:**
 * - `field=value` - Exact match (default operation)
 * - `fullName=John` - Find course creators with fullName exactly "John"
 *
 * **Comparison Operators:**
 * - `field_gt=value` - Greater than
 * - `field_lt=value` - Less than
 * - `field_gte=value` - Greater than or equal
 * - `field_lte=value` - Less than or equal
 * - `createdDate_gte=2024-01-01T00:00:00` - Created after Jan 1, 2024
 *
 * **String Operations:**
 * - `field_like=value` - Contains (case-insensitive)
 * - `field_startswith=value` - Starts with (case-insensitive)
 * - `field_endswith=value` - Ends with (case-insensitive)
 * - `fullName_like=alice` - Full name contains "alice"
 *
 * **Boolean Operations:**
 * - `adminVerified=true` - Only verified course creators
 * - `adminVerified=false` - Only unverified course creators
 *
 * **List Operations:**
 * - `field_in=val1,val2,val3` - Field is in list
 * - `field_notin=val1,val2` - Field is not in list
 *
 * **Negation:**
 * - `field_noteq=value` - Not equal to value
 *
 * **Examples:**
 * - `/search?fullName_like=john&adminVerified=true`
 * - `/search?createdDate_gte=2024-01-01T00:00:00`
 * - `/search?professionalHeadline_like=content`
 *
 */
export const searchCourseCreatorsInfiniteOptions = (options: Options<SearchCourseCreatorsData>) => {
  return infiniteQueryOptions<
    SearchCourseCreatorsResponse,
    SearchCourseCreatorsError,
    InfiniteData<SearchCourseCreatorsResponse>,
    QueryKey<Options<SearchCourseCreatorsData>>,
    | number
    | Pick<QueryKey<Options<SearchCourseCreatorsData>>[0], 'body' | 'headers' | 'path' | 'query'>
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<SearchCourseCreatorsData>>[0],
          'body' | 'headers' | 'path' | 'query'
        > =
          typeof pageParam === 'object'
            ? pageParam
            : {
                query: {
                  'pageable.page': pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await searchCourseCreators({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: searchCourseCreatorsInfiniteQueryKey(options),
    }
  );
};

export const searchCourseCreatorMembershipsQueryKey = (
  options: Options<SearchCourseCreatorMembershipsData>
) => createQueryKey('searchCourseCreatorMemberships', options);

/**
 * Search course creator memberships
 * Advanced search endpoint for course creator memberships.
 */
export const searchCourseCreatorMembershipsOptions = (
  options: Options<SearchCourseCreatorMembershipsData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await searchCourseCreatorMemberships({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: searchCourseCreatorMembershipsQueryKey(options),
  });
};

export const searchCourseCreatorMembershipsInfiniteQueryKey = (
  options: Options<SearchCourseCreatorMembershipsData>
): QueryKey<Options<SearchCourseCreatorMembershipsData>> =>
  createQueryKey('searchCourseCreatorMemberships', options, true);

/**
 * Search course creator memberships
 * Advanced search endpoint for course creator memberships.
 */
export const searchCourseCreatorMembershipsInfiniteOptions = (
  options: Options<SearchCourseCreatorMembershipsData>
) => {
  return infiniteQueryOptions<
    SearchCourseCreatorMembershipsResponse,
    SearchCourseCreatorMembershipsError,
    InfiniteData<SearchCourseCreatorMembershipsResponse>,
    QueryKey<Options<SearchCourseCreatorMembershipsData>>,
    | number
    | Pick<
        QueryKey<Options<SearchCourseCreatorMembershipsData>>[0],
        'body' | 'headers' | 'path' | 'query'
      >
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<SearchCourseCreatorMembershipsData>>[0],
          'body' | 'headers' | 'path' | 'query'
        > =
          typeof pageParam === 'object'
            ? pageParam
            : {
                query: {
                  'pageable.page': pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await searchCourseCreatorMemberships({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: searchCourseCreatorMembershipsInfiniteQueryKey(options),
    }
  );
};

export const searchCourseCreatorExperienceQueryKey = (
  options: Options<SearchCourseCreatorExperienceData>
) => createQueryKey('searchCourseCreatorExperience', options);

/**
 * Search course creator experience
 * Advanced search endpoint for course creator experience history.
 */
export const searchCourseCreatorExperienceOptions = (
  options: Options<SearchCourseCreatorExperienceData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await searchCourseCreatorExperience({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: searchCourseCreatorExperienceQueryKey(options),
  });
};

export const searchCourseCreatorExperienceInfiniteQueryKey = (
  options: Options<SearchCourseCreatorExperienceData>
): QueryKey<Options<SearchCourseCreatorExperienceData>> =>
  createQueryKey('searchCourseCreatorExperience', options, true);

/**
 * Search course creator experience
 * Advanced search endpoint for course creator experience history.
 */
export const searchCourseCreatorExperienceInfiniteOptions = (
  options: Options<SearchCourseCreatorExperienceData>
) => {
  return infiniteQueryOptions<
    SearchCourseCreatorExperienceResponse,
    SearchCourseCreatorExperienceError,
    InfiniteData<SearchCourseCreatorExperienceResponse>,
    QueryKey<Options<SearchCourseCreatorExperienceData>>,
    | number
    | Pick<
        QueryKey<Options<SearchCourseCreatorExperienceData>>[0],
        'body' | 'headers' | 'path' | 'query'
      >
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<SearchCourseCreatorExperienceData>>[0],
          'body' | 'headers' | 'path' | 'query'
        > =
          typeof pageParam === 'object'
            ? pageParam
            : {
                query: {
                  'pageable.page': pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await searchCourseCreatorExperience({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: searchCourseCreatorExperienceInfiniteQueryKey(options),
    }
  );
};

export const searchCourseCreatorEducationQueryKey = (
  options: Options<SearchCourseCreatorEducationData>
) => createQueryKey('searchCourseCreatorEducation', options);

/**
 * Search course creator education
 * Advanced search endpoint for course creator education history.
 */
export const searchCourseCreatorEducationOptions = (
  options: Options<SearchCourseCreatorEducationData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await searchCourseCreatorEducation({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: searchCourseCreatorEducationQueryKey(options),
  });
};

export const searchCourseCreatorEducationInfiniteQueryKey = (
  options: Options<SearchCourseCreatorEducationData>
): QueryKey<Options<SearchCourseCreatorEducationData>> =>
  createQueryKey('searchCourseCreatorEducation', options, true);

/**
 * Search course creator education
 * Advanced search endpoint for course creator education history.
 */
export const searchCourseCreatorEducationInfiniteOptions = (
  options: Options<SearchCourseCreatorEducationData>
) => {
  return infiniteQueryOptions<
    SearchCourseCreatorEducationResponse,
    SearchCourseCreatorEducationError,
    InfiniteData<SearchCourseCreatorEducationResponse>,
    QueryKey<Options<SearchCourseCreatorEducationData>>,
    | number
    | Pick<
        QueryKey<Options<SearchCourseCreatorEducationData>>[0],
        'body' | 'headers' | 'path' | 'query'
      >
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<SearchCourseCreatorEducationData>>[0],
          'body' | 'headers' | 'path' | 'query'
        > =
          typeof pageParam === 'object'
            ? pageParam
            : {
                query: {
                  'pageable.page': pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await searchCourseCreatorEducation({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: searchCourseCreatorEducationInfiniteQueryKey(options),
    }
  );
};

export const countCourseCreatorsByVerificationStatusQueryKey = (
  options: Options<CountCourseCreatorsByVerificationStatusData>
) => createQueryKey('countCourseCreatorsByVerificationStatus', options);

/**
 * Get course creator count by verification status
 * Returns the total count of course creators filtered by verification status.
 */
export const countCourseCreatorsByVerificationStatusOptions = (
  options: Options<CountCourseCreatorsByVerificationStatusData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await countCourseCreatorsByVerificationStatus({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: countCourseCreatorsByVerificationStatusQueryKey(options),
  });
};

export const searchCourseCreatorCertificationsQueryKey = (
  options: Options<SearchCourseCreatorCertificationsData>
) => createQueryKey('searchCourseCreatorCertifications', options);

/**
 * Search course creator certifications
 * Advanced search endpoint for course creator certifications.
 */
export const searchCourseCreatorCertificationsOptions = (
  options: Options<SearchCourseCreatorCertificationsData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await searchCourseCreatorCertifications({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: searchCourseCreatorCertificationsQueryKey(options),
  });
};

export const searchCourseCreatorCertificationsInfiniteQueryKey = (
  options: Options<SearchCourseCreatorCertificationsData>
): QueryKey<Options<SearchCourseCreatorCertificationsData>> =>
  createQueryKey('searchCourseCreatorCertifications', options, true);

/**
 * Search course creator certifications
 * Advanced search endpoint for course creator certifications.
 */
export const searchCourseCreatorCertificationsInfiniteOptions = (
  options: Options<SearchCourseCreatorCertificationsData>
) => {
  return infiniteQueryOptions<
    SearchCourseCreatorCertificationsResponse,
    SearchCourseCreatorCertificationsError,
    InfiniteData<SearchCourseCreatorCertificationsResponse>,
    QueryKey<Options<SearchCourseCreatorCertificationsData>>,
    | number
    | Pick<
        QueryKey<Options<SearchCourseCreatorCertificationsData>>[0],
        'body' | 'headers' | 'path' | 'query'
      >
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<SearchCourseCreatorCertificationsData>>[0],
          'body' | 'headers' | 'path' | 'query'
        > =
          typeof pageParam === 'object'
            ? pageParam
            : {
                query: {
                  'pageable.page': pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await searchCourseCreatorCertifications({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: searchCourseCreatorCertificationsInfiniteQueryKey(options),
    }
  );
};

export const searchContentTypesQueryKey = (options: Options<SearchContentTypesData>) =>
  createQueryKey('searchContentTypes', options);

/**
 * Search content types
 * Search content types with filtering options.
 *
 * **Common Content Type Search Examples:**
 * - `name_like=video` - Content types with "video" in name
 * - `mimeTypes_like=image/` - Image content types
 * - `maxFileSizeMb_gte=100` - Large file content types
 *
 */
export const searchContentTypesOptions = (options: Options<SearchContentTypesData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await searchContentTypes({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: searchContentTypesQueryKey(options),
  });
};

export const searchContentTypesInfiniteQueryKey = (
  options: Options<SearchContentTypesData>
): QueryKey<Options<SearchContentTypesData>> => createQueryKey('searchContentTypes', options, true);

/**
 * Search content types
 * Search content types with filtering options.
 *
 * **Common Content Type Search Examples:**
 * - `name_like=video` - Content types with "video" in name
 * - `mimeTypes_like=image/` - Image content types
 * - `maxFileSizeMb_gte=100` - Large file content types
 *
 */
export const searchContentTypesInfiniteOptions = (options: Options<SearchContentTypesData>) => {
  return infiniteQueryOptions<
    SearchContentTypesResponse,
    SearchContentTypesError,
    InfiniteData<SearchContentTypesResponse>,
    QueryKey<Options<SearchContentTypesData>>,
    | number
    | Pick<QueryKey<Options<SearchContentTypesData>>[0], 'body' | 'headers' | 'path' | 'query'>
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<SearchContentTypesData>>[0],
          'body' | 'headers' | 'path' | 'query'
        > =
          typeof pageParam === 'object'
            ? pageParam
            : {
                query: {
                  'pageable.page': pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await searchContentTypes({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: searchContentTypesInfiniteQueryKey(options),
    }
  );
};

export const checkMimeTypeSupportQueryKey = (options: Options<CheckMimeTypeSupportData>) =>
  createQueryKey('checkMimeTypeSupport', options);

/**
 * Check MIME type support
 * Checks if a specific MIME type is supported by the system.
 */
export const checkMimeTypeSupportOptions = (options: Options<CheckMimeTypeSupportData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await checkMimeTypeSupport({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: checkMimeTypeSupportQueryKey(options),
  });
};

export const getMediaContentTypesQueryKey = (options?: Options<GetMediaContentTypesData>) =>
  createQueryKey('getMediaContentTypes', options);

/**
 * Get media content types
 * Retrieves content types for media files (video, audio, images).
 */
export const getMediaContentTypesOptions = (options?: Options<GetMediaContentTypesData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getMediaContentTypes({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getMediaContentTypesQueryKey(options),
  });
};

export const getSubCategoriesQueryKey = (options: Options<GetSubCategoriesData>) =>
  createQueryKey('getSubCategories', options);

/**
 * Get subcategories
 * Retrieves all subcategories for a specific parent category.
 */
export const getSubCategoriesOptions = (options: Options<GetSubCategoriesData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getSubCategories({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getSubCategoriesQueryKey(options),
  });
};

export const searchCategoriesQueryKey = (options: Options<SearchCategoriesData>) =>
  createQueryKey('searchCategories', options);

/**
 * Search categories
 * Search categories with filtering options.
 *
 * **Common Category Search Examples:**
 * - `name_like=technology` - Categories with "technology" in name
 * - `parentUuid=null` - Root categories only
 * - `parentUuid=uuid` - Subcategories of specific parent
 * - `isActive=true` - Only active categories
 *
 */
export const searchCategoriesOptions = (options: Options<SearchCategoriesData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await searchCategories({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: searchCategoriesQueryKey(options),
  });
};

export const searchCategoriesInfiniteQueryKey = (
  options: Options<SearchCategoriesData>
): QueryKey<Options<SearchCategoriesData>> => createQueryKey('searchCategories', options, true);

/**
 * Search categories
 * Search categories with filtering options.
 *
 * **Common Category Search Examples:**
 * - `name_like=technology` - Categories with "technology" in name
 * - `parentUuid=null` - Root categories only
 * - `parentUuid=uuid` - Subcategories of specific parent
 * - `isActive=true` - Only active categories
 *
 */
export const searchCategoriesInfiniteOptions = (options: Options<SearchCategoriesData>) => {
  return infiniteQueryOptions<
    SearchCategoriesResponse,
    SearchCategoriesError,
    InfiniteData<SearchCategoriesResponse>,
    QueryKey<Options<SearchCategoriesData>>,
    number | Pick<QueryKey<Options<SearchCategoriesData>>[0], 'body' | 'headers' | 'path' | 'query'>
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<SearchCategoriesData>>[0],
          'body' | 'headers' | 'path' | 'query'
        > =
          typeof pageParam === 'object'
            ? pageParam
            : {
                query: {
                  'pageable.page': pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await searchCategories({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: searchCategoriesInfiniteQueryKey(options),
    }
  );
};

export const getRootCategoriesQueryKey = (options?: Options<GetRootCategoriesData>) =>
  createQueryKey('getRootCategories', options);

/**
 * Get root categories
 * Retrieves all top-level categories (no parent).
 */
export const getRootCategoriesOptions = (options?: Options<GetRootCategoriesData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getRootCategories({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getRootCategoriesQueryKey(options),
  });
};

export const getOrderQueryKey = (options: Options<GetOrderData>) =>
  createQueryKey('getOrder', options);

/**
 * Get order details
 * Retrieves an order to support order tracking
 */
export const getOrderOptions = (options: Options<GetOrderData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getOrder({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getOrderQueryKey(options),
  });
};

export const searchCatalogueQueryKey = (options: Options<SearchCatalogueData>) =>
  createQueryKey('searchCatalogue', options);

/**
 * Search catalogue with flexible filters
 * Provides the standard search interface used by other modules.
 *
 * **Examples:**
 * - `publiclyVisible=true&active=true`  public, active catalogue entries
 * - `courseUuid=<uuid>`  catalogue entries for a course
 * - `classDefinitionUuid=<uuid>&active=true`  active class-level entries
 * - `variantCode_like=starter`  variant codes containing `starter`
 *
 * Supports all comparison operators accepted by the platform-wide search builder.
 *
 */
export const searchCatalogueOptions = (options: Options<SearchCatalogueData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await searchCatalogue({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: searchCatalogueQueryKey(options),
  });
};

export const searchCatalogueInfiniteQueryKey = (
  options: Options<SearchCatalogueData>
): QueryKey<Options<SearchCatalogueData>> => createQueryKey('searchCatalogue', options, true);

/**
 * Search catalogue with flexible filters
 * Provides the standard search interface used by other modules.
 *
 * **Examples:**
 * - `publiclyVisible=true&active=true`  public, active catalogue entries
 * - `courseUuid=<uuid>`  catalogue entries for a course
 * - `classDefinitionUuid=<uuid>&active=true`  active class-level entries
 * - `variantCode_like=starter`  variant codes containing `starter`
 *
 * Supports all comparison operators accepted by the platform-wide search builder.
 *
 */
export const searchCatalogueInfiniteOptions = (options: Options<SearchCatalogueData>) => {
  return infiniteQueryOptions<
    SearchCatalogueResponse,
    SearchCatalogueError,
    InfiniteData<SearchCatalogueResponse>,
    QueryKey<Options<SearchCatalogueData>>,
    number | Pick<QueryKey<Options<SearchCatalogueData>>[0], 'body' | 'headers' | 'path' | 'query'>
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<SearchCatalogueData>>[0],
          'body' | 'headers' | 'path' | 'query'
        > =
          typeof pageParam === 'object'
            ? pageParam
            : {
                query: {
                  'pageable.page': pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await searchCatalogue({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: searchCatalogueInfiniteQueryKey(options),
    }
  );
};

export const resolveByCourseOrClassQueryKey = (options?: Options<ResolveByCourseOrClassData>) =>
  createQueryKey('resolveByCourseOrClass', options);

/**
 * Resolve catalogue mappings by course or class
 * Returns all catalogue entries for the provided course or class
 */
export const resolveByCourseOrClassOptions = (options?: Options<ResolveByCourseOrClassData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await resolveByCourseOrClass({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: resolveByCourseOrClassQueryKey(options),
  });
};

export const getEnrollmentsForClassQueryKey = (options: Options<GetEnrollmentsForClassData>) =>
  createQueryKey('getEnrollmentsForClass', options);

/**
 * List enrollments for a class definition across all scheduled instances
 */
export const getEnrollmentsForClassOptions = (options: Options<GetEnrollmentsForClassData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getEnrollmentsForClass({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getEnrollmentsForClassQueryKey(options),
  });
};

export const getClassDefinitionsForOrganisationQueryKey = (
  options: Options<GetClassDefinitionsForOrganisationData>
) => createQueryKey('getClassDefinitionsForOrganisation', options);

/**
 * Get class definitions for an organisation
 */
export const getClassDefinitionsForOrganisationOptions = (
  options: Options<GetClassDefinitionsForOrganisationData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getClassDefinitionsForOrganisation({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getClassDefinitionsForOrganisationQueryKey(options),
  });
};

export const getClassDefinitionsForInstructorQueryKey = (
  options: Options<GetClassDefinitionsForInstructorData>
) => createQueryKey('getClassDefinitionsForInstructor', options);

/**
 * Get class definitions for an instructor
 */
export const getClassDefinitionsForInstructorOptions = (
  options: Options<GetClassDefinitionsForInstructorData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getClassDefinitionsForInstructor({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getClassDefinitionsForInstructorQueryKey(options),
  });
};

export const getClassDefinitionsForCourseQueryKey = (
  options: Options<GetClassDefinitionsForCourseData>
) => createQueryKey('getClassDefinitionsForCourse', options);

/**
 * Get class definitions for a course
 */
export const getClassDefinitionsForCourseOptions = (
  options: Options<GetClassDefinitionsForCourseData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getClassDefinitionsForCourse({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getClassDefinitionsForCourseQueryKey(options),
  });
};

export const getAllActiveClassDefinitionsQueryKey = (
  options?: Options<GetAllActiveClassDefinitionsData>
) => createQueryKey('getAllActiveClassDefinitions', options);

/**
 * Get all active class definitions
 */
export const getAllActiveClassDefinitionsOptions = (
  options?: Options<GetAllActiveClassDefinitionsData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getAllActiveClassDefinitions({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getAllActiveClassDefinitionsQueryKey(options),
  });
};

export const verifyCertificateQueryKey = (options: Options<VerifyCertificateData>) =>
  createQueryKey('verifyCertificate', options);

/**
 * Verify certificate
 * Verifies the authenticity of a certificate using its certificate number.
 */
export const verifyCertificateOptions = (options: Options<VerifyCertificateData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await verifyCertificate({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: verifyCertificateQueryKey(options),
  });
};

export const searchCertificateTemplatesQueryKey = (
  options: Options<SearchCertificateTemplatesData>
) => createQueryKey('searchCertificateTemplates', options);

/**
 * Search certificate templates
 * Search certificate templates with filtering.
 *
 * **Common Template Search Examples:**
 * - `templateType=COURSE` - Course certificate templates
 * - `templateType=PROGRAM` - Program certificate templates
 * - `status=PUBLISHED` - Published templates
 * - `active=true` - Active templates
 * - `name_like=modern` - Templates with "modern" in name
 *
 */
export const searchCertificateTemplatesOptions = (
  options: Options<SearchCertificateTemplatesData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await searchCertificateTemplates({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: searchCertificateTemplatesQueryKey(options),
  });
};

export const searchCertificateTemplatesInfiniteQueryKey = (
  options: Options<SearchCertificateTemplatesData>
): QueryKey<Options<SearchCertificateTemplatesData>> =>
  createQueryKey('searchCertificateTemplates', options, true);

/**
 * Search certificate templates
 * Search certificate templates with filtering.
 *
 * **Common Template Search Examples:**
 * - `templateType=COURSE` - Course certificate templates
 * - `templateType=PROGRAM` - Program certificate templates
 * - `status=PUBLISHED` - Published templates
 * - `active=true` - Active templates
 * - `name_like=modern` - Templates with "modern" in name
 *
 */
export const searchCertificateTemplatesInfiniteOptions = (
  options: Options<SearchCertificateTemplatesData>
) => {
  return infiniteQueryOptions<
    SearchCertificateTemplatesResponse,
    SearchCertificateTemplatesError,
    InfiniteData<SearchCertificateTemplatesResponse>,
    QueryKey<Options<SearchCertificateTemplatesData>>,
    | number
    | Pick<
        QueryKey<Options<SearchCertificateTemplatesData>>[0],
        'body' | 'headers' | 'path' | 'query'
      >
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<SearchCertificateTemplatesData>>[0],
          'body' | 'headers' | 'path' | 'query'
        > =
          typeof pageParam === 'object'
            ? pageParam
            : {
                query: {
                  'pageable.page': pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await searchCertificateTemplates({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: searchCertificateTemplatesInfiniteQueryKey(options),
    }
  );
};

export const getStudentCertificatesQueryKey = (options: Options<GetStudentCertificatesData>) =>
  createQueryKey('getStudentCertificates', options);

/**
 * Get student certificates
 * Retrieves all certificates earned by a specific student.
 */
export const getStudentCertificatesOptions = (options: Options<GetStudentCertificatesData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getStudentCertificates({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getStudentCertificatesQueryKey(options),
  });
};

export const getDownloadableCertificatesQueryKey = (
  options: Options<GetDownloadableCertificatesData>
) => createQueryKey('getDownloadableCertificates', options);

/**
 * Get downloadable certificates
 * Retrieves all valid certificates available for download by a student.
 */
export const getDownloadableCertificatesOptions = (
  options: Options<GetDownloadableCertificatesData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getDownloadableCertificates({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getDownloadableCertificatesQueryKey(options),
  });
};

export const searchCertificatesQueryKey = (options: Options<SearchCertificatesData>) =>
  createQueryKey('searchCertificates', options);

/**
 * Search certificates
 * Advanced certificate search with flexible criteria and operators.
 *
 * **Common Certificate Search Examples:**
 * - `studentUuid=uuid` - All certificates for specific student
 * - `courseUuid=uuid` - All certificates for specific course
 * - `programUuid=uuid` - All certificates for specific program
 * - `isValid=true` - Only valid certificates
 * - `isValid=false` - Only revoked certificates
 * - `finalGrade_gte=85` - Certificates with grade 85%+
 * - `issuedDate_gte=2024-01-01T00:00:00` - Certificates issued from 2024
 * - `certificateNumber_like=CERT-2024` - Certificates from 2024
 *
 * **Certificate Analytics Queries:**
 * - `courseUuid_noteq=null&isValid=true` - Valid course certificates
 * - `programUuid_noteq=null&isValid=true` - Valid program certificates
 * - `finalGrade_between=80,100&isValid=true` - High-grade valid certificates
 *
 */
export const searchCertificatesOptions = (options: Options<SearchCertificatesData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await searchCertificates({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: searchCertificatesQueryKey(options),
  });
};

export const searchCertificatesInfiniteQueryKey = (
  options: Options<SearchCertificatesData>
): QueryKey<Options<SearchCertificatesData>> => createQueryKey('searchCertificates', options, true);

/**
 * Search certificates
 * Advanced certificate search with flexible criteria and operators.
 *
 * **Common Certificate Search Examples:**
 * - `studentUuid=uuid` - All certificates for specific student
 * - `courseUuid=uuid` - All certificates for specific course
 * - `programUuid=uuid` - All certificates for specific program
 * - `isValid=true` - Only valid certificates
 * - `isValid=false` - Only revoked certificates
 * - `finalGrade_gte=85` - Certificates with grade 85%+
 * - `issuedDate_gte=2024-01-01T00:00:00` - Certificates issued from 2024
 * - `certificateNumber_like=CERT-2024` - Certificates from 2024
 *
 * **Certificate Analytics Queries:**
 * - `courseUuid_noteq=null&isValid=true` - Valid course certificates
 * - `programUuid_noteq=null&isValid=true` - Valid program certificates
 * - `finalGrade_between=80,100&isValid=true` - High-grade valid certificates
 *
 */
export const searchCertificatesInfiniteOptions = (options: Options<SearchCertificatesData>) => {
  return infiniteQueryOptions<
    SearchCertificatesResponse,
    SearchCertificatesError,
    InfiniteData<SearchCertificatesResponse>,
    QueryKey<Options<SearchCertificatesData>>,
    | number
    | Pick<QueryKey<Options<SearchCertificatesData>>[0], 'body' | 'headers' | 'path' | 'query'>
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<SearchCertificatesData>>[0],
          'body' | 'headers' | 'path' | 'query'
        > =
          typeof pageParam === 'object'
            ? pageParam
            : {
                query: {
                  'pageable.page': pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await searchCertificates({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: searchCertificatesInfiniteQueryKey(options),
    }
  );
};

export const getRevokedCertificatesQueryKey = (options?: Options<GetRevokedCertificatesData>) =>
  createQueryKey('getRevokedCertificates', options);

/**
 * Get revoked certificates
 * Retrieves all revoked certificates for administrative review.
 */
export const getRevokedCertificatesOptions = (options?: Options<GetRevokedCertificatesData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getRevokedCertificates({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getRevokedCertificatesQueryKey(options),
  });
};

export const getProgramCertificates1QueryKey = (options?: Options<GetProgramCertificates1Data>) =>
  createQueryKey('getProgramCertificates1', options);

/**
 * Get program certificates
 * Retrieves all certificates issued for program completions.
 */
export const getProgramCertificates1Options = (options?: Options<GetProgramCertificates1Data>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getProgramCertificates1({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getProgramCertificates1QueryKey(options),
  });
};

export const getCertificateByNumberQueryKey = (options: Options<GetCertificateByNumberData>) =>
  createQueryKey('getCertificateByNumber', options);

/**
 * Get certificate by number
 * Retrieves certificate details using certificate number for public verification.
 */
export const getCertificateByNumberOptions = (options: Options<GetCertificateByNumberData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getCertificateByNumber({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getCertificateByNumberQueryKey(options),
  });
};

export const getCourseCertificatesQueryKey = (options?: Options<GetCourseCertificatesData>) =>
  createQueryKey('getCourseCertificates', options);

/**
 * Get course certificates
 * Retrieves all certificates issued for course completions.
 */
export const getCourseCertificatesOptions = (options?: Options<GetCourseCertificatesData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getCourseCertificates({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getCourseCertificatesQueryKey(options),
  });
};

export const getBookingQueryKey = (options: Options<GetBookingData>) =>
  createQueryKey('getBooking', options);

/**
 * Get booking details
 */
export const getBookingOptions = (options: Options<GetBookingData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getBooking({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getBookingQueryKey(options),
  });
};

export const getAssignmentSubmissionsQueryKey = (options: Options<GetAssignmentSubmissionsData>) =>
  createQueryKey('getAssignmentSubmissions', options);

/**
 * Get assignment submissions
 * Retrieves all submissions for a specific assignment.
 */
export const getAssignmentSubmissionsOptions = (options: Options<GetAssignmentSubmissionsData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getAssignmentSubmissions({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getAssignmentSubmissionsQueryKey(options),
  });
};

export const getHighPerformanceSubmissionsQueryKey = (
  options: Options<GetHighPerformanceSubmissionsData>
) => createQueryKey('getHighPerformanceSubmissions', options);

/**
 * Get high performance submissions
 * Returns submissions with scores above 85%.
 */
export const getHighPerformanceSubmissionsOptions = (
  options: Options<GetHighPerformanceSubmissionsData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getHighPerformanceSubmissions({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getHighPerformanceSubmissionsQueryKey(options),
  });
};

export const getAverageScoreQueryKey = (options: Options<GetAverageScoreData>) =>
  createQueryKey('getAverageScore', options);

/**
 * Get average submission score
 * Returns the average score for all graded submissions of an assignment.
 */
export const getAverageScoreOptions = (options: Options<GetAverageScoreData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getAverageScore({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getAverageScoreQueryKey(options),
  });
};

export const getSubmissionAnalyticsQueryKey = (options: Options<GetSubmissionAnalyticsData>) =>
  createQueryKey('getSubmissionAnalytics', options);

/**
 * Get submission analytics
 * Returns analytics data for assignment submissions including category distribution.
 */
export const getSubmissionAnalyticsOptions = (options: Options<GetSubmissionAnalyticsData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getSubmissionAnalytics({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getSubmissionAnalyticsQueryKey(options),
  });
};

export const searchSubmissionsQueryKey = (options: Options<SearchSubmissionsData>) =>
  createQueryKey('searchSubmissions', options);

/**
 * Search assignment submissions
 * Search submissions across all assignments.
 *
 * **Common Submission Search Examples:**
 * - `assignmentUuid=uuid` - All submissions for specific assignment
 * - `enrollmentUuid=uuid` - All submissions by specific student
 * - `status=GRADED` - Only graded submissions
 * - `percentage_gte=90` - Submissions with 90%+ score
 * - `submittedAt_gte=2024-01-01T00:00:00` - Submissions from 2024
 * - `gradedByUuid=uuid` - Submissions graded by specific instructor
 *
 */
export const searchSubmissionsOptions = (options: Options<SearchSubmissionsData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await searchSubmissions({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: searchSubmissionsQueryKey(options),
  });
};

export const searchSubmissionsInfiniteQueryKey = (
  options: Options<SearchSubmissionsData>
): QueryKey<Options<SearchSubmissionsData>> => createQueryKey('searchSubmissions', options, true);

/**
 * Search assignment submissions
 * Search submissions across all assignments.
 *
 * **Common Submission Search Examples:**
 * - `assignmentUuid=uuid` - All submissions for specific assignment
 * - `enrollmentUuid=uuid` - All submissions by specific student
 * - `status=GRADED` - Only graded submissions
 * - `percentage_gte=90` - Submissions with 90%+ score
 * - `submittedAt_gte=2024-01-01T00:00:00` - Submissions from 2024
 * - `gradedByUuid=uuid` - Submissions graded by specific instructor
 *
 */
export const searchSubmissionsInfiniteOptions = (options: Options<SearchSubmissionsData>) => {
  return infiniteQueryOptions<
    SearchSubmissionsResponse,
    SearchSubmissionsError,
    InfiniteData<SearchSubmissionsResponse>,
    QueryKey<Options<SearchSubmissionsData>>,
    | number
    | Pick<QueryKey<Options<SearchSubmissionsData>>[0], 'body' | 'headers' | 'path' | 'query'>
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<SearchSubmissionsData>>[0],
          'body' | 'headers' | 'path' | 'query'
        > =
          typeof pageParam === 'object'
            ? pageParam
            : {
                query: {
                  'pageable.page': pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await searchSubmissions({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: searchSubmissionsInfiniteQueryKey(options),
    }
  );
};

export const searchAssignmentsQueryKey = (options: Options<SearchAssignmentsData>) =>
  createQueryKey('searchAssignments', options);

/**
 * Search assignments
 * Advanced assignment search with flexible criteria and operators.
 *
 * **Common Assignment Search Examples:**
 * - `title_like=essay` - Assignments with "essay" in title
 * - `lessonUuid=uuid` - Assignments for specific lesson
 * - `status=PUBLISHED` - Only published assignments
 * - `active=true` - Only active assignments
 * - `dueDate_gte=2024-12-01T00:00:00` - Assignments due from Dec 1, 2024
 * - `maxPoints_gte=50` - Assignments worth 50+ points
 *
 */
export const searchAssignmentsOptions = (options: Options<SearchAssignmentsData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await searchAssignments({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: searchAssignmentsQueryKey(options),
  });
};

export const searchAssignmentsInfiniteQueryKey = (
  options: Options<SearchAssignmentsData>
): QueryKey<Options<SearchAssignmentsData>> => createQueryKey('searchAssignments', options, true);

/**
 * Search assignments
 * Advanced assignment search with flexible criteria and operators.
 *
 * **Common Assignment Search Examples:**
 * - `title_like=essay` - Assignments with "essay" in title
 * - `lessonUuid=uuid` - Assignments for specific lesson
 * - `status=PUBLISHED` - Only published assignments
 * - `active=true` - Only active assignments
 * - `dueDate_gte=2024-12-01T00:00:00` - Assignments due from Dec 1, 2024
 * - `maxPoints_gte=50` - Assignments worth 50+ points
 *
 */
export const searchAssignmentsInfiniteOptions = (options: Options<SearchAssignmentsData>) => {
  return infiniteQueryOptions<
    SearchAssignmentsResponse,
    SearchAssignmentsError,
    InfiniteData<SearchAssignmentsResponse>,
    QueryKey<Options<SearchAssignmentsData>>,
    | number
    | Pick<QueryKey<Options<SearchAssignmentsData>>[0], 'body' | 'headers' | 'path' | 'query'>
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<SearchAssignmentsData>>[0],
          'body' | 'headers' | 'path' | 'query'
        > =
          typeof pageParam === 'object'
            ? pageParam
            : {
                query: {
                  'pageable.page': pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await searchAssignments({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: searchAssignmentsInfiniteQueryKey(options),
    }
  );
};

export const getPendingGradingQueryKey = (options: Options<GetPendingGradingData>) =>
  createQueryKey('getPendingGrading', options);

/**
 * Get pending grading
 * Retrieves all submissions pending grading for a specific instructor.
 */
export const getPendingGradingOptions = (options: Options<GetPendingGradingData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getPendingGrading({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getPendingGradingQueryKey(options),
  });
};

export const isUserSystemAdminQueryKey = (options: Options<IsUserSystemAdminData>) =>
  createQueryKey('isUserSystemAdmin', options);

/**
 * Check if user is system admin
 * Checks whether a specific user has system administrator privileges. System admins have platform-wide administrative access.
 */
export const isUserSystemAdminOptions = (options: Options<IsUserSystemAdminData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await isUserSystemAdmin({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: isUserSystemAdminQueryKey(options),
  });
};

export const isUserAdminQueryKey = (options: Options<IsUserAdminData>) =>
  createQueryKey('isUserAdmin', options);

/**
 * Check if user is admin
 * Checks whether a specific user has any type of administrative privileges. Returns true if the user has either system admin or organization admin roles.
 */
export const isUserAdminOptions = (options: Options<IsUserAdminData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await isUserAdmin({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: isUserAdminQueryKey(options),
  });
};

export const getSystemAdminUsersQueryKey = (options: Options<GetSystemAdminUsersData>) =>
  createQueryKey('getSystemAdminUsers', options);

/**
 * Get system admin users
 * Retrieves a paginated list of users with global system administrator privileges. These users have platform-wide administrative access.
 */
export const getSystemAdminUsersOptions = (options: Options<GetSystemAdminUsersData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getSystemAdminUsers({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getSystemAdminUsersQueryKey(options),
  });
};

export const getSystemAdminUsersInfiniteQueryKey = (
  options: Options<GetSystemAdminUsersData>
): QueryKey<Options<GetSystemAdminUsersData>> =>
  createQueryKey('getSystemAdminUsers', options, true);

/**
 * Get system admin users
 * Retrieves a paginated list of users with global system administrator privileges. These users have platform-wide administrative access.
 */
export const getSystemAdminUsersInfiniteOptions = (options: Options<GetSystemAdminUsersData>) => {
  return infiniteQueryOptions<
    GetSystemAdminUsersResponse,
    GetSystemAdminUsersError,
    InfiniteData<GetSystemAdminUsersResponse>,
    QueryKey<Options<GetSystemAdminUsersData>>,
    | number
    | Pick<QueryKey<Options<GetSystemAdminUsersData>>[0], 'body' | 'headers' | 'path' | 'query'>
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<GetSystemAdminUsersData>>[0],
          'body' | 'headers' | 'path' | 'query'
        > =
          typeof pageParam === 'object'
            ? pageParam
            : {
                query: {
                  'pageable.page': pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getSystemAdminUsers({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: getSystemAdminUsersInfiniteQueryKey(options),
    }
  );
};

export const getOrganizationAdminUsersQueryKey = (
  options: Options<GetOrganizationAdminUsersData>
) => createQueryKey('getOrganizationAdminUsers', options);

/**
 * Get organization admin users
 * Retrieves a paginated list of users with organization administrator privileges. These users have administrative access within specific organizational contexts.
 */
export const getOrganizationAdminUsersOptions = (
  options: Options<GetOrganizationAdminUsersData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getOrganizationAdminUsers({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getOrganizationAdminUsersQueryKey(options),
  });
};

export const getOrganizationAdminUsersInfiniteQueryKey = (
  options: Options<GetOrganizationAdminUsersData>
): QueryKey<Options<GetOrganizationAdminUsersData>> =>
  createQueryKey('getOrganizationAdminUsers', options, true);

/**
 * Get organization admin users
 * Retrieves a paginated list of users with organization administrator privileges. These users have administrative access within specific organizational contexts.
 */
export const getOrganizationAdminUsersInfiniteOptions = (
  options: Options<GetOrganizationAdminUsersData>
) => {
  return infiniteQueryOptions<
    GetOrganizationAdminUsersResponse,
    GetOrganizationAdminUsersError,
    InfiniteData<GetOrganizationAdminUsersResponse>,
    QueryKey<Options<GetOrganizationAdminUsersData>>,
    | number
    | Pick<
        QueryKey<Options<GetOrganizationAdminUsersData>>[0],
        'body' | 'headers' | 'path' | 'query'
      >
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<GetOrganizationAdminUsersData>>[0],
          'body' | 'headers' | 'path' | 'query'
        > =
          typeof pageParam === 'object'
            ? pageParam
            : {
                query: {
                  'pageable.page': pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getOrganizationAdminUsers({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: getOrganizationAdminUsersInfiniteQueryKey(options),
    }
  );
};

export const getAdminEligibleUsersQueryKey = (options: Options<GetAdminEligibleUsersData>) =>
  createQueryKey('getAdminEligibleUsers', options);

/**
 * Get users eligible for admin promotion
 * Retrieves a paginated list of users who can be promoted to administrator roles. Excludes users who already have administrative privileges. Supports search by name or email.
 */
export const getAdminEligibleUsersOptions = (options: Options<GetAdminEligibleUsersData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getAdminEligibleUsers({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getAdminEligibleUsersQueryKey(options),
  });
};

export const getAdminEligibleUsersInfiniteQueryKey = (
  options: Options<GetAdminEligibleUsersData>
): QueryKey<Options<GetAdminEligibleUsersData>> =>
  createQueryKey('getAdminEligibleUsers', options, true);

/**
 * Get users eligible for admin promotion
 * Retrieves a paginated list of users who can be promoted to administrator roles. Excludes users who already have administrative privileges. Supports search by name or email.
 */
export const getAdminEligibleUsersInfiniteOptions = (
  options: Options<GetAdminEligibleUsersData>
) => {
  return infiniteQueryOptions<
    GetAdminEligibleUsersResponse,
    GetAdminEligibleUsersError,
    InfiniteData<GetAdminEligibleUsersResponse>,
    QueryKey<Options<GetAdminEligibleUsersData>>,
    | number
    | Pick<QueryKey<Options<GetAdminEligibleUsersData>>[0], 'body' | 'headers' | 'path' | 'query'>
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<GetAdminEligibleUsersData>>[0],
          'body' | 'headers' | 'path' | 'query'
        > =
          typeof pageParam === 'object'
            ? pageParam
            : {
                query: {
                  'pageable.page': pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getAdminEligibleUsers({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: getAdminEligibleUsersInfiniteQueryKey(options),
    }
  );
};

export const isOrganisationVerifiedQueryKey = (options: Options<IsOrganisationVerifiedData>) =>
  createQueryKey('isOrganisationVerified', options);

/**
 * Check if organization is verified
 * Checks whether a specific organization has been verified by an admin. Returns true if the organization has admin verification status.
 */
export const isOrganisationVerifiedOptions = (options: Options<IsOrganisationVerifiedData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await isOrganisationVerified({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: isOrganisationVerifiedQueryKey(options),
  });
};

export const getPendingOrganisationsQueryKey = (options: Options<GetPendingOrganisationsData>) =>
  createQueryKey('getPendingOrganisations', options);

/**
 * Get pending organization approvals
 * Retrieves a paginated list of organizations that are awaiting admin verification. Results include organisations where the admin_verified flag is false or not yet set.
 */
export const getPendingOrganisationsOptions = (options: Options<GetPendingOrganisationsData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getPendingOrganisations({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getPendingOrganisationsQueryKey(options),
  });
};

export const getPendingOrganisationsInfiniteQueryKey = (
  options: Options<GetPendingOrganisationsData>
): QueryKey<Options<GetPendingOrganisationsData>> =>
  createQueryKey('getPendingOrganisations', options, true);

/**
 * Get pending organization approvals
 * Retrieves a paginated list of organizations that are awaiting admin verification. Results include organisations where the admin_verified flag is false or not yet set.
 */
export const getPendingOrganisationsInfiniteOptions = (
  options: Options<GetPendingOrganisationsData>
) => {
  return infiniteQueryOptions<
    GetPendingOrganisationsResponse,
    GetPendingOrganisationsError,
    InfiniteData<GetPendingOrganisationsResponse>,
    QueryKey<Options<GetPendingOrganisationsData>>,
    | number
    | Pick<QueryKey<Options<GetPendingOrganisationsData>>[0], 'body' | 'headers' | 'path' | 'query'>
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<GetPendingOrganisationsData>>[0],
          'body' | 'headers' | 'path' | 'query'
        > =
          typeof pageParam === 'object'
            ? pageParam
            : {
                query: {
                  'pageable.page': pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getPendingOrganisations({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: getPendingOrganisationsInfiniteQueryKey(options),
    }
  );
};

export const isInstructorVerifiedQueryKey = (options: Options<IsInstructorVerifiedData>) =>
  createQueryKey('isInstructorVerified', options);

/**
 * Check if instructor is verified
 * Checks whether a specific instructor has been verified by an admin. Returns true if the instructor has admin verification status.
 */
export const isInstructorVerifiedOptions = (options: Options<IsInstructorVerifiedData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await isInstructorVerified({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: isInstructorVerifiedQueryKey(options),
  });
};

export const getOrganisationSupportedDomainsQueryKey = (
  options?: Options<GetOrganisationSupportedDomainsData>
) => createQueryKey('getOrganisationSupportedDomains', options);

/**
 * List organisation-supported user domains
 * Returns the list of user domains allowed for organisation assignments.
 */
export const getOrganisationSupportedDomainsOptions = (
  options?: Options<GetOrganisationSupportedDomainsData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getOrganisationSupportedDomains({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getOrganisationSupportedDomainsQueryKey(options),
  });
};

export const getDashboardStatisticsQueryKey = (options?: Options<GetDashboardStatisticsData>) =>
  createQueryKey('getDashboardStatistics', options);

/**
 * Get admin dashboard statistics
 * Retrieves comprehensive statistics for the admin dashboard including user metrics, organization metrics, content metrics, system performance, and admin-specific data.
 */
export const getDashboardStatisticsOptions = (options?: Options<GetDashboardStatisticsData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getDashboardStatistics({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getDashboardStatisticsQueryKey(options),
  });
};

export const getDashboardActivityQueryKey = (options: Options<GetDashboardActivityData>) =>
  createQueryKey('getDashboardActivity', options);

/**
 * Get admin dashboard activity feed
 * Retrieves a paginated list of recent administrative actions captured by the request audit trail.
 */
export const getDashboardActivityOptions = (options: Options<GetDashboardActivityData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getDashboardActivity({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getDashboardActivityQueryKey(options),
  });
};

export const getDashboardActivityInfiniteQueryKey = (
  options: Options<GetDashboardActivityData>
): QueryKey<Options<GetDashboardActivityData>> =>
  createQueryKey('getDashboardActivity', options, true);

/**
 * Get admin dashboard activity feed
 * Retrieves a paginated list of recent administrative actions captured by the request audit trail.
 */
export const getDashboardActivityInfiniteOptions = (options: Options<GetDashboardActivityData>) => {
  return infiniteQueryOptions<
    GetDashboardActivityResponse,
    GetDashboardActivityError,
    InfiniteData<GetDashboardActivityResponse>,
    QueryKey<Options<GetDashboardActivityData>>,
    | number
    | Pick<QueryKey<Options<GetDashboardActivityData>>[0], 'body' | 'headers' | 'path' | 'query'>
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<GetDashboardActivityData>>[0],
          'body' | 'headers' | 'path' | 'query'
        > =
          typeof pageParam === 'object'
            ? pageParam
            : {
                query: {
                  'pageable.page': pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getDashboardActivity({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: getDashboardActivityInfiniteQueryKey(options),
    }
  );
};

/**
 * Clear all availability for an instructor
 * Removes all availability slots and patterns for an instructor. Use with caution.
 */
export const clearInstructorAvailabilityMutation = (
  options?: Partial<Options<ClearInstructorAvailabilityData>>
): UseMutationOptions<
  ClearInstructorAvailabilityResponse,
  ClearInstructorAvailabilityError,
  Options<ClearInstructorAvailabilityData>
> => {
  const mutationOptions: UseMutationOptions<
    ClearInstructorAvailabilityResponse,
    ClearInstructorAvailabilityError,
    Options<ClearInstructorAvailabilityData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await clearInstructorAvailability({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Revoke guardian access
 */
export const revokeLinkMutation = (
  options?: Partial<Options<RevokeLinkData>>
): UseMutationOptions<RevokeLinkResponse, RevokeLinkError, Options<RevokeLinkData>> => {
  const mutationOptions: UseMutationOptions<
    RevokeLinkResponse,
    RevokeLinkError,
    Options<RevokeLinkData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await revokeLink({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Remove rubric association
 * Removes the association between a rubric and a course.
 */
export const dissociateRubricMutation = (
  options?: Partial<Options<DissociateRubricData>>
): UseMutationOptions<
  DissociateRubricResponse,
  DissociateRubricError,
  Options<DissociateRubricData>
> => {
  const mutationOptions: UseMutationOptions<
    DissociateRubricResponse,
    DissociateRubricError,
    Options<DissociateRubricData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await dissociateRubric({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Remove rubric association by context
 * Removes a specific rubric association based on usage context.
 */
export const dissociateRubricByContextMutation = (
  options?: Partial<Options<DissociateRubricByContextData>>
): UseMutationOptions<
  DissociateRubricByContextResponse,
  DissociateRubricByContextError,
  Options<DissociateRubricByContextData>
> => {
  const mutationOptions: UseMutationOptions<
    DissociateRubricByContextResponse,
    DissociateRubricByContextError,
    Options<DissociateRubricByContextData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await dissociateRubricByContext({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Remove category from course
 * Removes a specific category from a course without affecting other categories.
 */
export const removeCategoryFromCourseMutation = (
  options?: Partial<Options<RemoveCategoryFromCourseData>>
): UseMutationOptions<
  RemoveCategoryFromCourseResponse,
  RemoveCategoryFromCourseError,
  Options<RemoveCategoryFromCourseData>
> => {
  const mutationOptions: UseMutationOptions<
    RemoveCategoryFromCourseResponse,
    RemoveCategoryFromCourseError,
    Options<RemoveCategoryFromCourseData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await removeCategoryFromCourse({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Remove admin domain from user
 * Removes admin domain privileges from a user. This revokes the user's administrative access for the specified domain type. Only system administrators can perform this operation.
 */
export const removeAdminDomainMutation = (
  options?: Partial<Options<RemoveAdminDomainData>>
): UseMutationOptions<
  RemoveAdminDomainResponse,
  RemoveAdminDomainError,
  Options<RemoveAdminDomainData>
> => {
  const mutationOptions: UseMutationOptions<
    RemoveAdminDomainResponse,
    RemoveAdminDomainError,
    Options<RemoveAdminDomainData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await removeAdminDomain({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};
