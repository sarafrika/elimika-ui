// This file is auto-generated by @hey-api/openapi-ts

import {
  type Options,
  deleteUser,
  getUserByUuid,
  updateUser,
  deleteTrainingBranch,
  getTrainingBranchByUuid,
  updateTrainingBranch,
  deleteStudent,
  getStudentById,
  updateStudent,
  deleteQuiz,
  getQuizByUuid,
  updateQuiz,
  deleteQuizQuestion,
  updateQuizQuestion,
  deleteQuestionOption,
  updateQuestionOption,
  deleteTrainingProgram,
  getTrainingProgramByUuid,
  updateTrainingProgram,
  deleteProgramRequirement,
  updateProgramRequirement,
  removeProgramCourse,
  updateProgramCourse,
  deleteOrganisation,
  getOrganisationByUuid,
  updateOrganisation,
  deleteTrainingBranch1,
  getTrainingBranchByUuid1,
  updateTrainingBranch1,
  updatePointOfContact,
  deleteInstructor,
  getInstructorByUuid,
  updateInstructor,
  deleteInstructorSkill,
  updateInstructorSkill,
  deleteInstructorMembership,
  updateInstructorMembership,
  deleteInstructorExperience,
  updateInstructorExperience,
  deleteInstructorEducation,
  updateInstructorEducation,
  deleteInstructorDocument,
  updateInstructorDocument,
  deleteCourse,
  getCourseByUuid,
  updateCourse,
  deleteCourseRequirement,
  updateCourseRequirement,
  deleteCourseLesson,
  getCourseLesson,
  updateCourseLesson,
  deleteLessonContent,
  updateLessonContent,
  deleteCourseAssessment,
  updateCourseAssessment,
  deleteGradingLevel,
  updateGradingLevel,
  deleteDifficultyLevel,
  updateDifficultyLevel,
  deleteContentType,
  updateContentType,
  deleteCategory,
  getCategoryByUuid,
  updateCategory,
  deleteCertificate,
  getCertificateByUuid,
  updateCertificate,
  deleteCertificateTemplate,
  updateCertificateTemplate,
  deleteAssignment,
  getAssignmentByUuid,
  updateAssignment,
  declineInvitation,
  acceptInvitation,
  uploadProfileImage,
  getAllTrainingBranches,
  createTrainingBranch,
  getAllStudents,
  createStudent,
  getAllQuizzes,
  createQuiz,
  getQuizQuestions,
  addQuizQuestion,
  getQuestionOptions,
  addQuestionOption,
  reorderQuizQuestions,
  getAllTrainingPrograms,
  createTrainingProgram,
  publishProgram,
  getProgramRequirements,
  addProgramRequirement,
  getProgramCourses,
  addProgramCourse,
  getAllOrganisations,
  createOrganisation,
  getTrainingBranchesByOrganisation,
  createTrainingBranch1,
  removeUserFromBranch,
  assignUserToBranch,
  getBranchInvitations,
  createBranchInvitation,
  getOrganizationInvitations,
  createOrganizationInvitation,
  resendInvitation,
  sendExpiryReminders,
  markExpiredInvitations,
  getAllInstructors,
  createInstructor,
  getInstructorSkills,
  addInstructorSkill,
  getInstructorMemberships,
  addInstructorMembership,
  getInstructorExperience,
  addInstructorExperience,
  getInstructorEducation,
  addInstructorEducation,
  getInstructorDocuments,
  addInstructorDocument,
  verifyDocument,
  getAllCourses,
  createCourse,
  unpublishCourse,
  uploadCourseThumbnail,
  publishCourse,
  uploadCourseIntroVideo,
  uploadCourseBanner,
  archiveCourse,
  getCourseRequirements,
  addCourseRequirement,
  getCourseLessons,
  addCourseLesson,
  getLessonContent,
  addLessonContent,
  reorderLessonContent,
  getCourseAssessments,
  addCourseAssessment,
  getAllGradingLevels,
  createGradingLevel,
  getAllDifficultyLevels,
  createDifficultyLevel,
  reorderDifficultyLevels,
  getAllContentTypes,
  createContentType,
  getAllCategories,
  createCategory,
  getAllCertificates,
  createCertificate,
  revokeCertificate,
  generateCertificateUrl,
  getCertificateTemplates,
  createCertificateTemplate,
  generateProgramCertificate,
  generateCourseCertificate,
  getAllAssignments,
  createAssignment,
  submitAssignment,
  returnSubmission,
  gradeSubmission,
  getAllUsers,
  getInvitationsSentByUser,
  getPendingInvitationsForUser,
  search,
  getProfileImage,
  search1,
  getTrainingBranchesByOrganisation1,
  searchStudents,
  getQuizTotalPoints,
  getQuestionDistribution,
  getQuizAttempts,
  searchQuizzes,
  searchQuestions,
  searchAttempts,
  getProgramEnrollments,
  getRequiredCourses,
  getOptionalCourses,
  getProgramCompletionRate,
  getProgramCertificates,
  searchTrainingPrograms,
  searchProgramRequirements,
  getPublishedPrograms,
  getProgramsByInstructor,
  getFreePrograms,
  searchProgramEnrollments,
  searchProgramCourses,
  getProgramsByCategory,
  getActivePrograms,
  getUsersByOrganisation,
  getUsersByOrganisationAndDomain,
  getBranchUsers,
  getBranchUsersByDomain,
  search2,
  validateInvitation,
  getInvitationByToken,
  getPendingInvitationsForEmail,
  searchSkills,
  searchInstructors,
  searchMemberships,
  searchExperience,
  searchEducation,
  searchDocuments,
  getStatusTransitions,
  getCourseEnrollments,
  getCourseCompletionRate,
  removeAllCategoriesFromCourse,
  getCourseCategories,
  searchCourses,
  searchRequirements,
  getPublishedCourses,
  getCourseMedia,
  searchLessons,
  getCoursesByInstructor,
  searchEnrollments,
  searchLessonContent,
  getCoursesByCategory,
  searchCategoryMappings,
  searchAssessments,
  getActiveCourses,
  searchContentTypes,
  checkMimeTypeSupport,
  getMediaContentTypes,
  getSubCategories,
  searchCategories,
  getRootCategories,
  verifyCertificate,
  searchCertificateTemplates,
  getStudentCertificates,
  getDownloadableCertificates,
  searchCertificates,
  getRevokedCertificates,
  getProgramCertificates1,
  getCertificateByNumber,
  getCourseCertificates,
  getAssignmentSubmissions,
  getHighPerformanceSubmissions,
  getAverageScore,
  getSubmissionAnalytics,
  searchSubmissions,
  searchAssignments,
  getPendingGrading,
  cancelInvitation,
  cleanupOldInvitations,
  removeCategoryFromCourse,
} from '../sdk.gen';
import {
  type UseMutationOptions,
  queryOptions,
  infiniteQueryOptions,
  type InfiniteData,
} from '@tanstack/react-query';
import type {
  DeleteUserData,
  DeleteUserError,
  DeleteUserResponse,
  GetUserByUuidData,
  UpdateUserData,
  UpdateUserError,
  UpdateUserResponse,
  DeleteTrainingBranchData,
  DeleteTrainingBranchError,
  DeleteTrainingBranchResponse,
  GetTrainingBranchByUuidData,
  UpdateTrainingBranchData,
  UpdateTrainingBranchError,
  UpdateTrainingBranchResponse,
  DeleteStudentData,
  DeleteStudentError,
  DeleteStudentResponse,
  GetStudentByIdData,
  UpdateStudentData,
  UpdateStudentError,
  UpdateStudentResponse,
  DeleteQuizData,
  DeleteQuizError,
  DeleteQuizResponse,
  GetQuizByUuidData,
  UpdateQuizData,
  UpdateQuizError,
  UpdateQuizResponse,
  DeleteQuizQuestionData,
  DeleteQuizQuestionError,
  UpdateQuizQuestionData,
  UpdateQuizQuestionError,
  UpdateQuizQuestionResponse,
  DeleteQuestionOptionData,
  DeleteQuestionOptionError,
  UpdateQuestionOptionData,
  UpdateQuestionOptionError,
  UpdateQuestionOptionResponse,
  DeleteTrainingProgramData,
  DeleteTrainingProgramError,
  DeleteTrainingProgramResponse,
  GetTrainingProgramByUuidData,
  UpdateTrainingProgramData,
  UpdateTrainingProgramError,
  DeleteProgramRequirementData,
  DeleteProgramRequirementError,
  UpdateProgramRequirementData,
  UpdateProgramRequirementError,
  UpdateProgramRequirementResponse,
  RemoveProgramCourseData,
  RemoveProgramCourseError,
  UpdateProgramCourseData,
  UpdateProgramCourseError,
  UpdateProgramCourseResponse,
  DeleteOrganisationData,
  DeleteOrganisationError,
  DeleteOrganisationResponse,
  GetOrganisationByUuidData,
  UpdateOrganisationData,
  UpdateOrganisationError,
  UpdateOrganisationResponse,
  DeleteTrainingBranch1Data,
  DeleteTrainingBranch1Error,
  DeleteTrainingBranch1Response,
  GetTrainingBranchByUuid1Data,
  UpdateTrainingBranch1Data,
  UpdateTrainingBranch1Error,
  UpdateTrainingBranch1Response,
  UpdatePointOfContactData,
  UpdatePointOfContactError,
  UpdatePointOfContactResponse,
  DeleteInstructorData,
  DeleteInstructorError,
  DeleteInstructorResponse,
  GetInstructorByUuidData,
  UpdateInstructorData,
  UpdateInstructorError,
  UpdateInstructorResponse,
  DeleteInstructorSkillData,
  DeleteInstructorSkillError,
  UpdateInstructorSkillData,
  UpdateInstructorSkillError,
  UpdateInstructorSkillResponse,
  DeleteInstructorMembershipData,
  DeleteInstructorMembershipError,
  UpdateInstructorMembershipData,
  UpdateInstructorMembershipError,
  UpdateInstructorMembershipResponse,
  DeleteInstructorExperienceData,
  DeleteInstructorExperienceError,
  UpdateInstructorExperienceData,
  UpdateInstructorExperienceError,
  UpdateInstructorExperienceResponse,
  DeleteInstructorEducationData,
  DeleteInstructorEducationError,
  UpdateInstructorEducationData,
  UpdateInstructorEducationError,
  UpdateInstructorEducationResponse,
  DeleteInstructorDocumentData,
  DeleteInstructorDocumentError,
  UpdateInstructorDocumentData,
  UpdateInstructorDocumentError,
  UpdateInstructorDocumentResponse,
  DeleteCourseData,
  DeleteCourseError,
  DeleteCourseResponse,
  GetCourseByUuidData,
  UpdateCourseData,
  UpdateCourseError,
  UpdateCourseResponse,
  DeleteCourseRequirementData,
  DeleteCourseRequirementError,
  UpdateCourseRequirementData,
  UpdateCourseRequirementError,
  UpdateCourseRequirementResponse,
  DeleteCourseLessonData,
  DeleteCourseLessonError,
  GetCourseLessonData,
  UpdateCourseLessonData,
  UpdateCourseLessonError,
  UpdateCourseLessonResponse,
  DeleteLessonContentData,
  DeleteLessonContentError,
  UpdateLessonContentData,
  UpdateLessonContentError,
  UpdateLessonContentResponse,
  DeleteCourseAssessmentData,
  DeleteCourseAssessmentError,
  UpdateCourseAssessmentData,
  UpdateCourseAssessmentError,
  UpdateCourseAssessmentResponse,
  DeleteGradingLevelData,
  DeleteGradingLevelError,
  UpdateGradingLevelData,
  UpdateGradingLevelError,
  UpdateGradingLevelResponse,
  DeleteDifficultyLevelData,
  DeleteDifficultyLevelError,
  DeleteDifficultyLevelResponse,
  UpdateDifficultyLevelData,
  UpdateDifficultyLevelError,
  UpdateDifficultyLevelResponse,
  DeleteContentTypeData,
  DeleteContentTypeError,
  DeleteContentTypeResponse,
  UpdateContentTypeData,
  UpdateContentTypeError,
  UpdateContentTypeResponse,
  DeleteCategoryData,
  DeleteCategoryError,
  DeleteCategoryResponse,
  GetCategoryByUuidData,
  UpdateCategoryData,
  UpdateCategoryError,
  UpdateCategoryResponse,
  DeleteCertificateData,
  DeleteCertificateError,
  DeleteCertificateResponse,
  GetCertificateByUuidData,
  UpdateCertificateData,
  UpdateCertificateError,
  UpdateCertificateResponse,
  DeleteCertificateTemplateData,
  DeleteCertificateTemplateError,
  UpdateCertificateTemplateData,
  UpdateCertificateTemplateError,
  UpdateCertificateTemplateResponse,
  DeleteAssignmentData,
  DeleteAssignmentError,
  DeleteAssignmentResponse,
  GetAssignmentByUuidData,
  UpdateAssignmentData,
  UpdateAssignmentError,
  UpdateAssignmentResponse,
  DeclineInvitationData,
  DeclineInvitationError,
  DeclineInvitationResponse,
  AcceptInvitationData,
  AcceptInvitationError,
  AcceptInvitationResponse,
  UploadProfileImageData,
  UploadProfileImageError,
  UploadProfileImageResponse,
  GetAllTrainingBranchesData,
  GetAllTrainingBranchesError,
  GetAllTrainingBranchesResponse,
  CreateTrainingBranchData,
  CreateTrainingBranchError,
  CreateTrainingBranchResponse,
  GetAllStudentsData,
  GetAllStudentsError,
  GetAllStudentsResponse,
  CreateStudentData,
  CreateStudentError,
  CreateStudentResponse,
  GetAllQuizzesData,
  GetAllQuizzesError,
  GetAllQuizzesResponse,
  CreateQuizData,
  CreateQuizError,
  CreateQuizResponse,
  GetQuizQuestionsData,
  AddQuizQuestionData,
  AddQuizQuestionError,
  AddQuizQuestionResponse,
  GetQuestionOptionsData,
  GetQuestionOptionsError,
  GetQuestionOptionsResponse,
  AddQuestionOptionData,
  AddQuestionOptionError,
  AddQuestionOptionResponse,
  ReorderQuizQuestionsData,
  ReorderQuizQuestionsError,
  ReorderQuizQuestionsResponse,
  GetAllTrainingProgramsData,
  GetAllTrainingProgramsError,
  CreateTrainingProgramData,
  CreateTrainingProgramError,
  CreateTrainingProgramResponse,
  PublishProgramData,
  PublishProgramError,
  GetProgramRequirementsData,
  GetProgramRequirementsError,
  GetProgramRequirementsResponse,
  AddProgramRequirementData,
  AddProgramRequirementError,
  AddProgramRequirementResponse,
  GetProgramCoursesData,
  AddProgramCourseData,
  AddProgramCourseError,
  AddProgramCourseResponse,
  GetAllOrganisationsData,
  GetAllOrganisationsError,
  GetAllOrganisationsResponse,
  CreateOrganisationData,
  CreateOrganisationError,
  CreateOrganisationResponse,
  GetTrainingBranchesByOrganisationData,
  GetTrainingBranchesByOrganisationError,
  GetTrainingBranchesByOrganisationResponse,
  CreateTrainingBranch1Data,
  CreateTrainingBranch1Error,
  CreateTrainingBranch1Response,
  RemoveUserFromBranchData,
  RemoveUserFromBranchError,
  RemoveUserFromBranchResponse,
  AssignUserToBranchData,
  AssignUserToBranchError,
  AssignUserToBranchResponse,
  GetBranchInvitationsData,
  CreateBranchInvitationData,
  CreateBranchInvitationError,
  CreateBranchInvitationResponse,
  GetOrganizationInvitationsData,
  CreateOrganizationInvitationData,
  CreateOrganizationInvitationError,
  CreateOrganizationInvitationResponse,
  ResendInvitationData,
  ResendInvitationError,
  ResendInvitationResponse,
  SendExpiryRemindersData,
  SendExpiryRemindersError,
  SendExpiryRemindersResponse,
  MarkExpiredInvitationsData,
  MarkExpiredInvitationsError,
  MarkExpiredInvitationsResponse,
  GetAllInstructorsData,
  GetAllInstructorsError,
  GetAllInstructorsResponse,
  CreateInstructorData,
  CreateInstructorError,
  CreateInstructorResponse,
  GetInstructorSkillsData,
  GetInstructorSkillsError,
  GetInstructorSkillsResponse,
  AddInstructorSkillData,
  AddInstructorSkillError,
  AddInstructorSkillResponse,
  GetInstructorMembershipsData,
  GetInstructorMembershipsError,
  GetInstructorMembershipsResponse,
  AddInstructorMembershipData,
  AddInstructorMembershipError,
  AddInstructorMembershipResponse,
  GetInstructorExperienceData,
  GetInstructorExperienceError,
  GetInstructorExperienceResponse,
  AddInstructorExperienceData,
  AddInstructorExperienceError,
  AddInstructorExperienceResponse,
  GetInstructorEducationData,
  AddInstructorEducationData,
  AddInstructorEducationError,
  AddInstructorEducationResponse,
  GetInstructorDocumentsData,
  AddInstructorDocumentData,
  AddInstructorDocumentError,
  AddInstructorDocumentResponse,
  VerifyDocumentData,
  VerifyDocumentError,
  VerifyDocumentResponse,
  GetAllCoursesData,
  GetAllCoursesError,
  GetAllCoursesResponse,
  CreateCourseData,
  CreateCourseError,
  CreateCourseResponse,
  UnpublishCourseData,
  UnpublishCourseError,
  UnpublishCourseResponse,
  UploadCourseThumbnailData,
  UploadCourseThumbnailError,
  UploadCourseThumbnailResponse,
  PublishCourseData,
  PublishCourseError,
  PublishCourseResponse,
  UploadCourseIntroVideoData,
  UploadCourseIntroVideoError,
  UploadCourseIntroVideoResponse,
  UploadCourseBannerData,
  UploadCourseBannerError,
  UploadCourseBannerResponse,
  ArchiveCourseData,
  ArchiveCourseError,
  ArchiveCourseResponse,
  GetCourseRequirementsData,
  GetCourseRequirementsError,
  GetCourseRequirementsResponse,
  AddCourseRequirementData,
  AddCourseRequirementError,
  AddCourseRequirementResponse,
  GetCourseLessonsData,
  GetCourseLessonsError,
  GetCourseLessonsResponse,
  AddCourseLessonData,
  AddCourseLessonError,
  AddCourseLessonResponse,
  GetLessonContentData,
  AddLessonContentData,
  AddLessonContentError,
  AddLessonContentResponse,
  ReorderLessonContentData,
  ReorderLessonContentError,
  ReorderLessonContentResponse,
  GetCourseAssessmentsData,
  GetCourseAssessmentsError,
  GetCourseAssessmentsResponse,
  AddCourseAssessmentData,
  AddCourseAssessmentError,
  AddCourseAssessmentResponse,
  GetAllGradingLevelsData,
  GetAllGradingLevelsError,
  GetAllGradingLevelsResponse,
  CreateGradingLevelData,
  CreateGradingLevelError,
  CreateGradingLevelResponse,
  GetAllDifficultyLevelsData,
  CreateDifficultyLevelData,
  CreateDifficultyLevelError,
  CreateDifficultyLevelResponse,
  ReorderDifficultyLevelsData,
  ReorderDifficultyLevelsError,
  ReorderDifficultyLevelsResponse,
  GetAllContentTypesData,
  GetAllContentTypesError,
  GetAllContentTypesResponse,
  CreateContentTypeData,
  CreateContentTypeError,
  CreateContentTypeResponse,
  GetAllCategoriesData,
  GetAllCategoriesError,
  GetAllCategoriesResponse,
  CreateCategoryData,
  CreateCategoryError,
  CreateCategoryResponse,
  GetAllCertificatesData,
  GetAllCertificatesError,
  GetAllCertificatesResponse,
  CreateCertificateData,
  CreateCertificateError,
  CreateCertificateResponse,
  RevokeCertificateData,
  RevokeCertificateError,
  RevokeCertificateResponse,
  GenerateCertificateUrlData,
  GenerateCertificateUrlError,
  GenerateCertificateUrlResponse,
  GetCertificateTemplatesData,
  GetCertificateTemplatesError,
  GetCertificateTemplatesResponse,
  CreateCertificateTemplateData,
  CreateCertificateTemplateError,
  CreateCertificateTemplateResponse,
  GenerateProgramCertificateData,
  GenerateProgramCertificateError,
  GenerateProgramCertificateResponse,
  GenerateCourseCertificateData,
  GenerateCourseCertificateError,
  GenerateCourseCertificateResponse,
  GetAllAssignmentsData,
  GetAllAssignmentsError,
  GetAllAssignmentsResponse,
  CreateAssignmentData,
  CreateAssignmentError,
  CreateAssignmentResponse,
  SubmitAssignmentData,
  SubmitAssignmentError,
  SubmitAssignmentResponse,
  ReturnSubmissionData,
  ReturnSubmissionError,
  ReturnSubmissionResponse,
  GradeSubmissionData,
  GradeSubmissionError,
  GradeSubmissionResponse,
  GetAllUsersData,
  GetAllUsersError,
  GetAllUsersResponse,
  GetInvitationsSentByUserData,
  GetPendingInvitationsForUserData,
  SearchData,
  SearchError,
  SearchResponse,
  GetProfileImageData,
  Search1Data,
  Search1Error,
  Search1Response,
  GetTrainingBranchesByOrganisation1Data,
  GetTrainingBranchesByOrganisation1Error,
  GetTrainingBranchesByOrganisation1Response,
  SearchStudentsData,
  SearchStudentsError,
  SearchStudentsResponse,
  GetQuizTotalPointsData,
  GetQuestionDistributionData,
  GetQuizAttemptsData,
  GetQuizAttemptsError,
  GetQuizAttemptsResponse,
  SearchQuizzesData,
  SearchQuizzesError,
  SearchQuizzesResponse,
  SearchQuestionsData,
  SearchQuestionsError,
  SearchQuestionsResponse,
  SearchAttemptsData,
  SearchAttemptsError,
  SearchAttemptsResponse,
  GetProgramEnrollmentsData,
  GetProgramEnrollmentsError,
  GetProgramEnrollmentsResponse,
  GetRequiredCoursesData,
  GetOptionalCoursesData,
  GetProgramCompletionRateData,
  GetProgramCertificatesData,
  GetProgramCertificatesError,
  GetProgramCertificatesResponse,
  SearchTrainingProgramsData,
  SearchTrainingProgramsError,
  SearchProgramRequirementsData,
  SearchProgramRequirementsError,
  SearchProgramRequirementsResponse,
  GetPublishedProgramsData,
  GetPublishedProgramsError,
  GetProgramsByInstructorData,
  GetProgramsByInstructorError,
  GetFreeProgramsData,
  GetFreeProgramsError,
  SearchProgramEnrollmentsData,
  SearchProgramEnrollmentsError,
  SearchProgramEnrollmentsResponse,
  SearchProgramCoursesData,
  SearchProgramCoursesError,
  SearchProgramCoursesResponse,
  GetProgramsByCategoryData,
  GetProgramsByCategoryError,
  GetActiveProgramsData,
  GetActiveProgramsError,
  GetUsersByOrganisationData,
  GetUsersByOrganisationError,
  GetUsersByOrganisationResponse,
  GetUsersByOrganisationAndDomainData,
  GetBranchUsersData,
  GetBranchUsersByDomainData,
  Search2Data,
  Search2Error,
  Search2Response,
  ValidateInvitationData,
  GetInvitationByTokenData,
  GetPendingInvitationsForEmailData,
  SearchSkillsData,
  SearchSkillsError,
  SearchSkillsResponse,
  SearchInstructorsData,
  SearchInstructorsError,
  SearchInstructorsResponse,
  SearchMembershipsData,
  SearchMembershipsError,
  SearchMembershipsResponse,
  SearchExperienceData,
  SearchExperienceError,
  SearchExperienceResponse,
  SearchEducationData,
  SearchEducationError,
  SearchEducationResponse,
  SearchDocumentsData,
  SearchDocumentsError,
  SearchDocumentsResponse,
  GetStatusTransitionsData,
  GetCourseEnrollmentsData,
  GetCourseEnrollmentsError,
  GetCourseEnrollmentsResponse,
  GetCourseCompletionRateData,
  RemoveAllCategoriesFromCourseData,
  RemoveAllCategoriesFromCourseError,
  RemoveAllCategoriesFromCourseResponse,
  GetCourseCategoriesData,
  SearchCoursesData,
  SearchCoursesError,
  SearchCoursesResponse,
  SearchRequirementsData,
  SearchRequirementsError,
  SearchRequirementsResponse,
  GetPublishedCoursesData,
  GetPublishedCoursesError,
  GetPublishedCoursesResponse,
  GetCourseMediaData,
  SearchLessonsData,
  SearchLessonsError,
  SearchLessonsResponse,
  GetCoursesByInstructorData,
  GetCoursesByInstructorError,
  GetCoursesByInstructorResponse,
  SearchEnrollmentsData,
  SearchEnrollmentsError,
  SearchEnrollmentsResponse,
  SearchLessonContentData,
  SearchLessonContentError,
  SearchLessonContentResponse,
  GetCoursesByCategoryData,
  GetCoursesByCategoryError,
  GetCoursesByCategoryResponse,
  SearchCategoryMappingsData,
  SearchCategoryMappingsError,
  SearchCategoryMappingsResponse,
  SearchAssessmentsData,
  SearchAssessmentsError,
  SearchAssessmentsResponse,
  GetActiveCoursesData,
  GetActiveCoursesError,
  GetActiveCoursesResponse,
  SearchContentTypesData,
  SearchContentTypesError,
  SearchContentTypesResponse,
  CheckMimeTypeSupportData,
  GetMediaContentTypesData,
  GetSubCategoriesData,
  SearchCategoriesData,
  SearchCategoriesError,
  SearchCategoriesResponse,
  GetRootCategoriesData,
  VerifyCertificateData,
  SearchCertificateTemplatesData,
  SearchCertificateTemplatesError,
  SearchCertificateTemplatesResponse,
  GetStudentCertificatesData,
  GetDownloadableCertificatesData,
  SearchCertificatesData,
  SearchCertificatesError,
  SearchCertificatesResponse,
  GetRevokedCertificatesData,
  GetProgramCertificates1Data,
  GetCertificateByNumberData,
  GetCourseCertificatesData,
  GetAssignmentSubmissionsData,
  GetHighPerformanceSubmissionsData,
  GetAverageScoreData,
  GetSubmissionAnalyticsData,
  SearchSubmissionsData,
  SearchSubmissionsError,
  SearchSubmissionsResponse,
  SearchAssignmentsData,
  SearchAssignmentsError,
  SearchAssignmentsResponse,
  GetPendingGradingData,
  CancelInvitationData,
  CancelInvitationError,
  CancelInvitationResponse,
  CleanupOldInvitationsData,
  CleanupOldInvitationsError,
  CleanupOldInvitationsResponse,
  RemoveCategoryFromCourseData,
  RemoveCategoryFromCourseError,
  RemoveCategoryFromCourseResponse,
} from '../types.gen';
import { client as _heyApiClient } from '../client.gen';

/**
 * Delete a user by UUID
 */
export const deleteUserMutation = (
  options?: Partial<Options<DeleteUserData>>
): UseMutationOptions<DeleteUserResponse, DeleteUserError, Options<DeleteUserData>> => {
  const mutationOptions: UseMutationOptions<
    DeleteUserResponse,
    DeleteUserError,
    Options<DeleteUserData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await deleteUser({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export type QueryKey<TOptions extends Options> = [
  Pick<TOptions, 'baseUrl' | 'body' | 'headers' | 'path' | 'query'> & {
    _id: string;
    _infinite?: boolean;
  },
];

const createQueryKey = <TOptions extends Options>(
  id: string,
  options?: TOptions,
  infinite?: boolean
): [QueryKey<TOptions>[0]] => {
  const params: QueryKey<TOptions>[0] = {
    _id: id,
    baseUrl: options?.baseUrl || (options?.client ?? _heyApiClient).getConfig().baseUrl,
  } as QueryKey<TOptions>[0];
  if (infinite) {
    params._infinite = infinite;
  }
  if (options?.body) {
    params.body = options.body;
  }
  if (options?.headers) {
    params.headers = options.headers;
  }
  if (options?.path) {
    params.path = options.path;
  }
  if (options?.query) {
    params.query = options.query;
  }
  return [params];
};

export const getUserByUuidQueryKey = (options: Options<GetUserByUuidData>) =>
  createQueryKey('getUserByUuid', options);

/**
 * Get a user by UUID
 */
export const getUserByUuidOptions = (options: Options<GetUserByUuidData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getUserByUuid({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getUserByUuidQueryKey(options),
  });
};

/**
 * Update a user by UUID
 */
export const updateUserMutation = (
  options?: Partial<Options<UpdateUserData>>
): UseMutationOptions<UpdateUserResponse, UpdateUserError, Options<UpdateUserData>> => {
  const mutationOptions: UseMutationOptions<
    UpdateUserResponse,
    UpdateUserError,
    Options<UpdateUserData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await updateUser({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Delete a training branch by UUID
 */
export const deleteTrainingBranchMutation = (
  options?: Partial<Options<DeleteTrainingBranchData>>
): UseMutationOptions<
  DeleteTrainingBranchResponse,
  DeleteTrainingBranchError,
  Options<DeleteTrainingBranchData>
> => {
  const mutationOptions: UseMutationOptions<
    DeleteTrainingBranchResponse,
    DeleteTrainingBranchError,
    Options<DeleteTrainingBranchData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await deleteTrainingBranch({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getTrainingBranchByUuidQueryKey = (options: Options<GetTrainingBranchByUuidData>) =>
  createQueryKey('getTrainingBranchByUuid', options);

/**
 * Get a training branch by UUID
 */
export const getTrainingBranchByUuidOptions = (options: Options<GetTrainingBranchByUuidData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getTrainingBranchByUuid({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getTrainingBranchByUuidQueryKey(options),
  });
};

/**
 * Update a training branch by UUID
 */
export const updateTrainingBranchMutation = (
  options?: Partial<Options<UpdateTrainingBranchData>>
): UseMutationOptions<
  UpdateTrainingBranchResponse,
  UpdateTrainingBranchError,
  Options<UpdateTrainingBranchData>
> => {
  const mutationOptions: UseMutationOptions<
    UpdateTrainingBranchResponse,
    UpdateTrainingBranchError,
    Options<UpdateTrainingBranchData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await updateTrainingBranch({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Delete a student
 * Removes a student record from the system.
 */
export const deleteStudentMutation = (
  options?: Partial<Options<DeleteStudentData>>
): UseMutationOptions<DeleteStudentResponse, DeleteStudentError, Options<DeleteStudentData>> => {
  const mutationOptions: UseMutationOptions<
    DeleteStudentResponse,
    DeleteStudentError,
    Options<DeleteStudentData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await deleteStudent({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getStudentByIdQueryKey = (options: Options<GetStudentByIdData>) =>
  createQueryKey('getStudentById', options);

/**
 * Get student by ID
 * Fetches a student by their UUID.
 */
export const getStudentByIdOptions = (options: Options<GetStudentByIdData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getStudentById({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getStudentByIdQueryKey(options),
  });
};

/**
 * Update a student
 * Updates an existing student record.
 */
export const updateStudentMutation = (
  options?: Partial<Options<UpdateStudentData>>
): UseMutationOptions<UpdateStudentResponse, UpdateStudentError, Options<UpdateStudentData>> => {
  const mutationOptions: UseMutationOptions<
    UpdateStudentResponse,
    UpdateStudentError,
    Options<UpdateStudentData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await updateStudent({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Delete quiz
 * Permanently removes a quiz and all associated data.
 */
export const deleteQuizMutation = (
  options?: Partial<Options<DeleteQuizData>>
): UseMutationOptions<DeleteQuizResponse, DeleteQuizError, Options<DeleteQuizData>> => {
  const mutationOptions: UseMutationOptions<
    DeleteQuizResponse,
    DeleteQuizError,
    Options<DeleteQuizData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await deleteQuiz({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getQuizByUuidQueryKey = (options: Options<GetQuizByUuidData>) =>
  createQueryKey('getQuizByUuid', options);

/**
 * Get quiz by UUID
 * Retrieves a complete quiz including questions and computed properties.
 */
export const getQuizByUuidOptions = (options: Options<GetQuizByUuidData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getQuizByUuid({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getQuizByUuidQueryKey(options),
  });
};

/**
 * Update quiz
 * Updates an existing quiz with selective field updates.
 */
export const updateQuizMutation = (
  options?: Partial<Options<UpdateQuizData>>
): UseMutationOptions<UpdateQuizResponse, UpdateQuizError, Options<UpdateQuizData>> => {
  const mutationOptions: UseMutationOptions<
    UpdateQuizResponse,
    UpdateQuizError,
    Options<UpdateQuizData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await updateQuiz({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Delete quiz question
 * Removes a question from a quiz including all options and responses.
 */
export const deleteQuizQuestionMutation = (
  options?: Partial<Options<DeleteQuizQuestionData>>
): UseMutationOptions<unknown, DeleteQuizQuestionError, Options<DeleteQuizQuestionData>> => {
  const mutationOptions: UseMutationOptions<
    unknown,
    DeleteQuizQuestionError,
    Options<DeleteQuizQuestionData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await deleteQuizQuestion({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Update quiz question
 * Updates a specific question within a quiz.
 */
export const updateQuizQuestionMutation = (
  options?: Partial<Options<UpdateQuizQuestionData>>
): UseMutationOptions<
  UpdateQuizQuestionResponse,
  UpdateQuizQuestionError,
  Options<UpdateQuizQuestionData>
> => {
  const mutationOptions: UseMutationOptions<
    UpdateQuizQuestionResponse,
    UpdateQuizQuestionError,
    Options<UpdateQuizQuestionData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await updateQuizQuestion({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Delete question option
 * Removes an option from a question.
 */
export const deleteQuestionOptionMutation = (
  options?: Partial<Options<DeleteQuestionOptionData>>
): UseMutationOptions<unknown, DeleteQuestionOptionError, Options<DeleteQuestionOptionData>> => {
  const mutationOptions: UseMutationOptions<
    unknown,
    DeleteQuestionOptionError,
    Options<DeleteQuestionOptionData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await deleteQuestionOption({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Update question option
 * Updates a specific option for a question.
 */
export const updateQuestionOptionMutation = (
  options?: Partial<Options<UpdateQuestionOptionData>>
): UseMutationOptions<
  UpdateQuestionOptionResponse,
  UpdateQuestionOptionError,
  Options<UpdateQuestionOptionData>
> => {
  const mutationOptions: UseMutationOptions<
    UpdateQuestionOptionResponse,
    UpdateQuestionOptionError,
    Options<UpdateQuestionOptionData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await updateQuestionOption({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Delete training program
 * Permanently removes a training program and its associated data.
 */
export const deleteTrainingProgramMutation = (
  options?: Partial<Options<DeleteTrainingProgramData>>
): UseMutationOptions<
  DeleteTrainingProgramResponse,
  DeleteTrainingProgramError,
  Options<DeleteTrainingProgramData>
> => {
  const mutationOptions: UseMutationOptions<
    DeleteTrainingProgramResponse,
    DeleteTrainingProgramError,
    Options<DeleteTrainingProgramData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await deleteTrainingProgram({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getTrainingProgramByUuidQueryKey = (options: Options<GetTrainingProgramByUuidData>) =>
  createQueryKey('getTrainingProgramByUuid', options);

/**
 * Get program by UUID
 * Retrieves a complete program profile including computed properties and analytics.
 */
export const getTrainingProgramByUuidOptions = (options: Options<GetTrainingProgramByUuidData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getTrainingProgramByUuid({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getTrainingProgramByUuidQueryKey(options),
  });
};

/**
 * Update training program
 * Updates an existing training program with selective field updates.
 */
export const updateTrainingProgramMutation = (
  options?: Partial<Options<UpdateTrainingProgramData>>
): UseMutationOptions<unknown, UpdateTrainingProgramError, Options<UpdateTrainingProgramData>> => {
  const mutationOptions: UseMutationOptions<
    unknown,
    UpdateTrainingProgramError,
    Options<UpdateTrainingProgramData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await updateTrainingProgram({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Delete program requirement
 * Removes a requirement from a program.
 */
export const deleteProgramRequirementMutation = (
  options?: Partial<Options<DeleteProgramRequirementData>>
): UseMutationOptions<
  unknown,
  DeleteProgramRequirementError,
  Options<DeleteProgramRequirementData>
> => {
  const mutationOptions: UseMutationOptions<
    unknown,
    DeleteProgramRequirementError,
    Options<DeleteProgramRequirementData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await deleteProgramRequirement({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Update program requirement
 * Updates a specific requirement for a program.
 */
export const updateProgramRequirementMutation = (
  options?: Partial<Options<UpdateProgramRequirementData>>
): UseMutationOptions<
  UpdateProgramRequirementResponse,
  UpdateProgramRequirementError,
  Options<UpdateProgramRequirementData>
> => {
  const mutationOptions: UseMutationOptions<
    UpdateProgramRequirementResponse,
    UpdateProgramRequirementError,
    Options<UpdateProgramRequirementData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await updateProgramRequirement({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Remove course from program
 * Removes the association between a course and program.
 */
export const removeProgramCourseMutation = (
  options?: Partial<Options<RemoveProgramCourseData>>
): UseMutationOptions<unknown, RemoveProgramCourseError, Options<RemoveProgramCourseData>> => {
  const mutationOptions: UseMutationOptions<
    unknown,
    RemoveProgramCourseError,
    Options<RemoveProgramCourseData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await removeProgramCourse({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Update program course
 * Updates course association settings within a program.
 */
export const updateProgramCourseMutation = (
  options?: Partial<Options<UpdateProgramCourseData>>
): UseMutationOptions<
  UpdateProgramCourseResponse,
  UpdateProgramCourseError,
  Options<UpdateProgramCourseData>
> => {
  const mutationOptions: UseMutationOptions<
    UpdateProgramCourseResponse,
    UpdateProgramCourseError,
    Options<UpdateProgramCourseData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await updateProgramCourse({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Delete an organisation by UUID
 */
export const deleteOrganisationMutation = (
  options?: Partial<Options<DeleteOrganisationData>>
): UseMutationOptions<
  DeleteOrganisationResponse,
  DeleteOrganisationError,
  Options<DeleteOrganisationData>
> => {
  const mutationOptions: UseMutationOptions<
    DeleteOrganisationResponse,
    DeleteOrganisationError,
    Options<DeleteOrganisationData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await deleteOrganisation({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getOrganisationByUuidQueryKey = (options: Options<GetOrganisationByUuidData>) =>
  createQueryKey('getOrganisationByUuid', options);

/**
 * Get an organisation by UUID
 */
export const getOrganisationByUuidOptions = (options: Options<GetOrganisationByUuidData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getOrganisationByUuid({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getOrganisationByUuidQueryKey(options),
  });
};

/**
 * Update an organisation by UUID
 */
export const updateOrganisationMutation = (
  options?: Partial<Options<UpdateOrganisationData>>
): UseMutationOptions<
  UpdateOrganisationResponse,
  UpdateOrganisationError,
  Options<UpdateOrganisationData>
> => {
  const mutationOptions: UseMutationOptions<
    UpdateOrganisationResponse,
    UpdateOrganisationError,
    Options<UpdateOrganisationData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await updateOrganisation({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Delete a training branch by UUID within organization
 */
export const deleteTrainingBranch1Mutation = (
  options?: Partial<Options<DeleteTrainingBranch1Data>>
): UseMutationOptions<
  DeleteTrainingBranch1Response,
  DeleteTrainingBranch1Error,
  Options<DeleteTrainingBranch1Data>
> => {
  const mutationOptions: UseMutationOptions<
    DeleteTrainingBranch1Response,
    DeleteTrainingBranch1Error,
    Options<DeleteTrainingBranch1Data>
  > = {
    mutationFn: async localOptions => {
      const { data } = await deleteTrainingBranch1({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getTrainingBranchByUuid1QueryKey = (options: Options<GetTrainingBranchByUuid1Data>) =>
  createQueryKey('getTrainingBranchByUuid1', options);

/**
 * Get a training branch by UUID within organization
 */
export const getTrainingBranchByUuid1Options = (options: Options<GetTrainingBranchByUuid1Data>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getTrainingBranchByUuid1({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getTrainingBranchByUuid1QueryKey(options),
  });
};

/**
 * Update a training branch by UUID within organization
 */
export const updateTrainingBranch1Mutation = (
  options?: Partial<Options<UpdateTrainingBranch1Data>>
): UseMutationOptions<
  UpdateTrainingBranch1Response,
  UpdateTrainingBranch1Error,
  Options<UpdateTrainingBranch1Data>
> => {
  const mutationOptions: UseMutationOptions<
    UpdateTrainingBranch1Response,
    UpdateTrainingBranch1Error,
    Options<UpdateTrainingBranch1Data>
  > = {
    mutationFn: async localOptions => {
      const { data } = await updateTrainingBranch1({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Update point of contact for training branch
 * Updates the point of contact user for a training branch. The POC must be either assigned to the branch or be a member of the parent organization.
 */
export const updatePointOfContactMutation = (
  options?: Partial<Options<UpdatePointOfContactData>>
): UseMutationOptions<
  UpdatePointOfContactResponse,
  UpdatePointOfContactError,
  Options<UpdatePointOfContactData>
> => {
  const mutationOptions: UseMutationOptions<
    UpdatePointOfContactResponse,
    UpdatePointOfContactError,
    Options<UpdatePointOfContactData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await updatePointOfContact({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Delete an instructor
 * Removes an instructor record from the system.
 */
export const deleteInstructorMutation = (
  options?: Partial<Options<DeleteInstructorData>>
): UseMutationOptions<
  DeleteInstructorResponse,
  DeleteInstructorError,
  Options<DeleteInstructorData>
> => {
  const mutationOptions: UseMutationOptions<
    DeleteInstructorResponse,
    DeleteInstructorError,
    Options<DeleteInstructorData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await deleteInstructor({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getInstructorByUuidQueryKey = (options: Options<GetInstructorByUuidData>) =>
  createQueryKey('getInstructorByUuid', options);

/**
 * Get instructor by UUID
 * Fetches an instructor by their UUID.
 */
export const getInstructorByUuidOptions = (options: Options<GetInstructorByUuidData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getInstructorByUuid({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getInstructorByUuidQueryKey(options),
  });
};

/**
 * Update an instructor
 * Updates an existing instructor record.
 */
export const updateInstructorMutation = (
  options?: Partial<Options<UpdateInstructorData>>
): UseMutationOptions<
  UpdateInstructorResponse,
  UpdateInstructorError,
  Options<UpdateInstructorData>
> => {
  const mutationOptions: UseMutationOptions<
    UpdateInstructorResponse,
    UpdateInstructorError,
    Options<UpdateInstructorData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await updateInstructor({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Delete instructor skill
 * Removes a skill from an instructor
 */
export const deleteInstructorSkillMutation = (
  options?: Partial<Options<DeleteInstructorSkillData>>
): UseMutationOptions<unknown, DeleteInstructorSkillError, Options<DeleteInstructorSkillData>> => {
  const mutationOptions: UseMutationOptions<
    unknown,
    DeleteInstructorSkillError,
    Options<DeleteInstructorSkillData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await deleteInstructorSkill({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Update instructor skill
 * Updates a specific skill record
 */
export const updateInstructorSkillMutation = (
  options?: Partial<Options<UpdateInstructorSkillData>>
): UseMutationOptions<
  UpdateInstructorSkillResponse,
  UpdateInstructorSkillError,
  Options<UpdateInstructorSkillData>
> => {
  const mutationOptions: UseMutationOptions<
    UpdateInstructorSkillResponse,
    UpdateInstructorSkillError,
    Options<UpdateInstructorSkillData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await updateInstructorSkill({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Delete instructor membership
 * Removes a membership record from an instructor
 */
export const deleteInstructorMembershipMutation = (
  options?: Partial<Options<DeleteInstructorMembershipData>>
): UseMutationOptions<
  unknown,
  DeleteInstructorMembershipError,
  Options<DeleteInstructorMembershipData>
> => {
  const mutationOptions: UseMutationOptions<
    unknown,
    DeleteInstructorMembershipError,
    Options<DeleteInstructorMembershipData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await deleteInstructorMembership({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Update instructor membership
 * Updates a specific membership record
 */
export const updateInstructorMembershipMutation = (
  options?: Partial<Options<UpdateInstructorMembershipData>>
): UseMutationOptions<
  UpdateInstructorMembershipResponse,
  UpdateInstructorMembershipError,
  Options<UpdateInstructorMembershipData>
> => {
  const mutationOptions: UseMutationOptions<
    UpdateInstructorMembershipResponse,
    UpdateInstructorMembershipError,
    Options<UpdateInstructorMembershipData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await updateInstructorMembership({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Delete instructor experience
 * Removes an experience record from an instructor
 */
export const deleteInstructorExperienceMutation = (
  options?: Partial<Options<DeleteInstructorExperienceData>>
): UseMutationOptions<
  unknown,
  DeleteInstructorExperienceError,
  Options<DeleteInstructorExperienceData>
> => {
  const mutationOptions: UseMutationOptions<
    unknown,
    DeleteInstructorExperienceError,
    Options<DeleteInstructorExperienceData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await deleteInstructorExperience({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Update instructor experience
 * Updates a specific experience record
 */
export const updateInstructorExperienceMutation = (
  options?: Partial<Options<UpdateInstructorExperienceData>>
): UseMutationOptions<
  UpdateInstructorExperienceResponse,
  UpdateInstructorExperienceError,
  Options<UpdateInstructorExperienceData>
> => {
  const mutationOptions: UseMutationOptions<
    UpdateInstructorExperienceResponse,
    UpdateInstructorExperienceError,
    Options<UpdateInstructorExperienceData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await updateInstructorExperience({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Delete instructor education
 * Removes an education record from an instructor
 */
export const deleteInstructorEducationMutation = (
  options?: Partial<Options<DeleteInstructorEducationData>>
): UseMutationOptions<
  unknown,
  DeleteInstructorEducationError,
  Options<DeleteInstructorEducationData>
> => {
  const mutationOptions: UseMutationOptions<
    unknown,
    DeleteInstructorEducationError,
    Options<DeleteInstructorEducationData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await deleteInstructorEducation({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Update instructor education
 * Updates a specific education record
 */
export const updateInstructorEducationMutation = (
  options?: Partial<Options<UpdateInstructorEducationData>>
): UseMutationOptions<
  UpdateInstructorEducationResponse,
  UpdateInstructorEducationError,
  Options<UpdateInstructorEducationData>
> => {
  const mutationOptions: UseMutationOptions<
    UpdateInstructorEducationResponse,
    UpdateInstructorEducationError,
    Options<UpdateInstructorEducationData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await updateInstructorEducation({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Delete instructor document
 * Removes a document from an instructor
 */
export const deleteInstructorDocumentMutation = (
  options?: Partial<Options<DeleteInstructorDocumentData>>
): UseMutationOptions<
  unknown,
  DeleteInstructorDocumentError,
  Options<DeleteInstructorDocumentData>
> => {
  const mutationOptions: UseMutationOptions<
    unknown,
    DeleteInstructorDocumentError,
    Options<DeleteInstructorDocumentData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await deleteInstructorDocument({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Update instructor document
 * Updates a specific document
 */
export const updateInstructorDocumentMutation = (
  options?: Partial<Options<UpdateInstructorDocumentData>>
): UseMutationOptions<
  UpdateInstructorDocumentResponse,
  UpdateInstructorDocumentError,
  Options<UpdateInstructorDocumentData>
> => {
  const mutationOptions: UseMutationOptions<
    UpdateInstructorDocumentResponse,
    UpdateInstructorDocumentError,
    Options<UpdateInstructorDocumentData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await updateInstructorDocument({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Delete course
 * Permanently removes a course, its category associations, and all associated data.
 */
export const deleteCourseMutation = (
  options?: Partial<Options<DeleteCourseData>>
): UseMutationOptions<DeleteCourseResponse, DeleteCourseError, Options<DeleteCourseData>> => {
  const mutationOptions: UseMutationOptions<
    DeleteCourseResponse,
    DeleteCourseError,
    Options<DeleteCourseData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await deleteCourse({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getCourseByUuidQueryKey = (options: Options<GetCourseByUuidData>) =>
  createQueryKey('getCourseByUuid', options);

/**
 * Get course by UUID
 * Retrieves a complete course profile including computed properties and category information.
 *
 * **Response includes:**
 * - All course details and metadata
 * - `category_uuids`: List of category UUIDs the course belongs to
 * - `category_names`: List of category names for display (read-only)
 * - `category_count`: Number of categories assigned to the course
 * - `has_multiple_categories`: Boolean indicating if course has multiple categories
 *
 */
export const getCourseByUuidOptions = (options: Options<GetCourseByUuidData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getCourseByUuid({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getCourseByUuidQueryKey(options),
  });
};

/**
 * Update course
 * Updates an existing course with selective field updates including category management.
 *
 * **Category Updates:**
 * - Provide `category_uuids` to completely replace existing categories
 * - To add categories, include existing + new category UUIDs
 * - To remove all categories, provide an empty array
 * - Changes to categories are applied atomically
 *
 */
export const updateCourseMutation = (
  options?: Partial<Options<UpdateCourseData>>
): UseMutationOptions<UpdateCourseResponse, UpdateCourseError, Options<UpdateCourseData>> => {
  const mutationOptions: UseMutationOptions<
    UpdateCourseResponse,
    UpdateCourseError,
    Options<UpdateCourseData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await updateCourse({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Delete course requirement
 * Removes a requirement from a course.
 */
export const deleteCourseRequirementMutation = (
  options?: Partial<Options<DeleteCourseRequirementData>>
): UseMutationOptions<
  unknown,
  DeleteCourseRequirementError,
  Options<DeleteCourseRequirementData>
> => {
  const mutationOptions: UseMutationOptions<
    unknown,
    DeleteCourseRequirementError,
    Options<DeleteCourseRequirementData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await deleteCourseRequirement({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Update course requirement
 * Updates a specific requirement for a course.
 */
export const updateCourseRequirementMutation = (
  options?: Partial<Options<UpdateCourseRequirementData>>
): UseMutationOptions<
  UpdateCourseRequirementResponse,
  UpdateCourseRequirementError,
  Options<UpdateCourseRequirementData>
> => {
  const mutationOptions: UseMutationOptions<
    UpdateCourseRequirementResponse,
    UpdateCourseRequirementError,
    Options<UpdateCourseRequirementData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await updateCourseRequirement({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Delete course lesson
 * Removes a lesson from a course including all associated content.
 */
export const deleteCourseLessonMutation = (
  options?: Partial<Options<DeleteCourseLessonData>>
): UseMutationOptions<unknown, DeleteCourseLessonError, Options<DeleteCourseLessonData>> => {
  const mutationOptions: UseMutationOptions<
    unknown,
    DeleteCourseLessonError,
    Options<DeleteCourseLessonData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await deleteCourseLesson({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getCourseLessonQueryKey = (options: Options<GetCourseLessonData>) =>
  createQueryKey('getCourseLesson', options);

/**
 * Get lesson by UUID
 * Retrieves a specific lesson by its UUID within a course context.
 *
 * **Lesson Retrieval Details:**
 * - Returns complete lesson profile including computed properties
 * - Validates that the lesson belongs to the specified course
 * - Includes lesson content count and duration calculations
 * - Provides lesson status and completion tracking information
 *
 * **Response includes:**
 * - Basic lesson information (title, description, objectives)
 * - Lesson metadata (duration, sequence number, status)
 * - Associated course UUID validation
 * - Content summary statistics
 * - Computed properties (isCompleted, progressPercentage for authenticated users)
 *
 * **Use Cases:**
 * - Direct lesson navigation from course content
 * - Lesson detail page rendering
 * - Progress tracking and analytics
 * - Content validation and prerequisites checking
 *
 * **Security Considerations:**
 * - Validates lesson belongs to specified course
 * - Respects course enrollment status for detailed information
 * - May return limited data for unenrolled users depending on course visibility settings
 *
 */
export const getCourseLessonOptions = (options: Options<GetCourseLessonData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getCourseLesson({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getCourseLessonQueryKey(options),
  });
};

/**
 * Update course lesson
 * Updates a specific lesson within a course.
 */
export const updateCourseLessonMutation = (
  options?: Partial<Options<UpdateCourseLessonData>>
): UseMutationOptions<
  UpdateCourseLessonResponse,
  UpdateCourseLessonError,
  Options<UpdateCourseLessonData>
> => {
  const mutationOptions: UseMutationOptions<
    UpdateCourseLessonResponse,
    UpdateCourseLessonError,
    Options<UpdateCourseLessonData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await updateCourseLesson({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Delete lesson content
 * Removes content from a lesson.
 */
export const deleteLessonContentMutation = (
  options?: Partial<Options<DeleteLessonContentData>>
): UseMutationOptions<unknown, DeleteLessonContentError, Options<DeleteLessonContentData>> => {
  const mutationOptions: UseMutationOptions<
    unknown,
    DeleteLessonContentError,
    Options<DeleteLessonContentData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await deleteLessonContent({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Update lesson content
 * Updates a specific content item within a lesson.
 */
export const updateLessonContentMutation = (
  options?: Partial<Options<UpdateLessonContentData>>
): UseMutationOptions<
  UpdateLessonContentResponse,
  UpdateLessonContentError,
  Options<UpdateLessonContentData>
> => {
  const mutationOptions: UseMutationOptions<
    UpdateLessonContentResponse,
    UpdateLessonContentError,
    Options<UpdateLessonContentData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await updateLessonContent({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Delete course assessment
 * Removes an assessment from a course.
 */
export const deleteCourseAssessmentMutation = (
  options?: Partial<Options<DeleteCourseAssessmentData>>
): UseMutationOptions<
  unknown,
  DeleteCourseAssessmentError,
  Options<DeleteCourseAssessmentData>
> => {
  const mutationOptions: UseMutationOptions<
    unknown,
    DeleteCourseAssessmentError,
    Options<DeleteCourseAssessmentData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await deleteCourseAssessment({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Update course assessment
 * Updates a specific assessment within a course.
 */
export const updateCourseAssessmentMutation = (
  options?: Partial<Options<UpdateCourseAssessmentData>>
): UseMutationOptions<
  UpdateCourseAssessmentResponse,
  UpdateCourseAssessmentError,
  Options<UpdateCourseAssessmentData>
> => {
  const mutationOptions: UseMutationOptions<
    UpdateCourseAssessmentResponse,
    UpdateCourseAssessmentError,
    Options<UpdateCourseAssessmentData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await updateCourseAssessment({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Delete grading level
 * Removes a grading level.
 */
export const deleteGradingLevelMutation = (
  options?: Partial<Options<DeleteGradingLevelData>>
): UseMutationOptions<unknown, DeleteGradingLevelError, Options<DeleteGradingLevelData>> => {
  const mutationOptions: UseMutationOptions<
    unknown,
    DeleteGradingLevelError,
    Options<DeleteGradingLevelData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await deleteGradingLevel({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Update grading level
 * Updates an existing grading level.
 */
export const updateGradingLevelMutation = (
  options?: Partial<Options<UpdateGradingLevelData>>
): UseMutationOptions<
  UpdateGradingLevelResponse,
  UpdateGradingLevelError,
  Options<UpdateGradingLevelData>
> => {
  const mutationOptions: UseMutationOptions<
    UpdateGradingLevelResponse,
    UpdateGradingLevelError,
    Options<UpdateGradingLevelData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await updateGradingLevel({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Delete difficulty level
 * Removes a difficulty level if no courses are using it.
 */
export const deleteDifficultyLevelMutation = (
  options?: Partial<Options<DeleteDifficultyLevelData>>
): UseMutationOptions<
  DeleteDifficultyLevelResponse,
  DeleteDifficultyLevelError,
  Options<DeleteDifficultyLevelData>
> => {
  const mutationOptions: UseMutationOptions<
    DeleteDifficultyLevelResponse,
    DeleteDifficultyLevelError,
    Options<DeleteDifficultyLevelData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await deleteDifficultyLevel({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Update difficulty level
 * Updates an existing difficulty level.
 */
export const updateDifficultyLevelMutation = (
  options?: Partial<Options<UpdateDifficultyLevelData>>
): UseMutationOptions<
  UpdateDifficultyLevelResponse,
  UpdateDifficultyLevelError,
  Options<UpdateDifficultyLevelData>
> => {
  const mutationOptions: UseMutationOptions<
    UpdateDifficultyLevelResponse,
    UpdateDifficultyLevelError,
    Options<UpdateDifficultyLevelData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await updateDifficultyLevel({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Delete content type
 * Removes a content type if no lesson content is using it.
 */
export const deleteContentTypeMutation = (
  options?: Partial<Options<DeleteContentTypeData>>
): UseMutationOptions<
  DeleteContentTypeResponse,
  DeleteContentTypeError,
  Options<DeleteContentTypeData>
> => {
  const mutationOptions: UseMutationOptions<
    DeleteContentTypeResponse,
    DeleteContentTypeError,
    Options<DeleteContentTypeData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await deleteContentType({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Update content type
 * Updates an existing content type.
 */
export const updateContentTypeMutation = (
  options?: Partial<Options<UpdateContentTypeData>>
): UseMutationOptions<
  UpdateContentTypeResponse,
  UpdateContentTypeError,
  Options<UpdateContentTypeData>
> => {
  const mutationOptions: UseMutationOptions<
    UpdateContentTypeResponse,
    UpdateContentTypeError,
    Options<UpdateContentTypeData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await updateContentType({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Delete category
 * Removes a category if it has no subcategories or associated courses.
 */
export const deleteCategoryMutation = (
  options?: Partial<Options<DeleteCategoryData>>
): UseMutationOptions<DeleteCategoryResponse, DeleteCategoryError, Options<DeleteCategoryData>> => {
  const mutationOptions: UseMutationOptions<
    DeleteCategoryResponse,
    DeleteCategoryError,
    Options<DeleteCategoryData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await deleteCategory({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getCategoryByUuidQueryKey = (options: Options<GetCategoryByUuidData>) =>
  createQueryKey('getCategoryByUuid', options);

/**
 * Get category by UUID
 * Retrieves a specific category by its UUID.
 */
export const getCategoryByUuidOptions = (options: Options<GetCategoryByUuidData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getCategoryByUuid({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getCategoryByUuidQueryKey(options),
  });
};

/**
 * Update category
 * Updates an existing category.
 */
export const updateCategoryMutation = (
  options?: Partial<Options<UpdateCategoryData>>
): UseMutationOptions<UpdateCategoryResponse, UpdateCategoryError, Options<UpdateCategoryData>> => {
  const mutationOptions: UseMutationOptions<
    UpdateCategoryResponse,
    UpdateCategoryError,
    Options<UpdateCategoryData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await updateCategory({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Delete certificate
 * Permanently removes a certificate record.
 */
export const deleteCertificateMutation = (
  options?: Partial<Options<DeleteCertificateData>>
): UseMutationOptions<
  DeleteCertificateResponse,
  DeleteCertificateError,
  Options<DeleteCertificateData>
> => {
  const mutationOptions: UseMutationOptions<
    DeleteCertificateResponse,
    DeleteCertificateError,
    Options<DeleteCertificateData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await deleteCertificate({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getCertificateByUuidQueryKey = (options: Options<GetCertificateByUuidData>) =>
  createQueryKey('getCertificateByUuid', options);

/**
 * Get certificate by UUID
 * Retrieves a complete certificate including computed properties and verification status.
 */
export const getCertificateByUuidOptions = (options: Options<GetCertificateByUuidData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getCertificateByUuid({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getCertificateByUuidQueryKey(options),
  });
};

/**
 * Update certificate
 * Updates an existing certificate with selective field updates.
 */
export const updateCertificateMutation = (
  options?: Partial<Options<UpdateCertificateData>>
): UseMutationOptions<
  UpdateCertificateResponse,
  UpdateCertificateError,
  Options<UpdateCertificateData>
> => {
  const mutationOptions: UseMutationOptions<
    UpdateCertificateResponse,
    UpdateCertificateError,
    Options<UpdateCertificateData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await updateCertificate({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Delete certificate template
 * Removes a certificate template.
 */
export const deleteCertificateTemplateMutation = (
  options?: Partial<Options<DeleteCertificateTemplateData>>
): UseMutationOptions<
  unknown,
  DeleteCertificateTemplateError,
  Options<DeleteCertificateTemplateData>
> => {
  const mutationOptions: UseMutationOptions<
    unknown,
    DeleteCertificateTemplateError,
    Options<DeleteCertificateTemplateData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await deleteCertificateTemplate({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Update certificate template
 * Updates an existing certificate template.
 */
export const updateCertificateTemplateMutation = (
  options?: Partial<Options<UpdateCertificateTemplateData>>
): UseMutationOptions<
  UpdateCertificateTemplateResponse,
  UpdateCertificateTemplateError,
  Options<UpdateCertificateTemplateData>
> => {
  const mutationOptions: UseMutationOptions<
    UpdateCertificateTemplateResponse,
    UpdateCertificateTemplateError,
    Options<UpdateCertificateTemplateData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await updateCertificateTemplate({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Delete assignment
 * Permanently removes an assignment and all associated submissions.
 */
export const deleteAssignmentMutation = (
  options?: Partial<Options<DeleteAssignmentData>>
): UseMutationOptions<
  DeleteAssignmentResponse,
  DeleteAssignmentError,
  Options<DeleteAssignmentData>
> => {
  const mutationOptions: UseMutationOptions<
    DeleteAssignmentResponse,
    DeleteAssignmentError,
    Options<DeleteAssignmentData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await deleteAssignment({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getAssignmentByUuidQueryKey = (options: Options<GetAssignmentByUuidData>) =>
  createQueryKey('getAssignmentByUuid', options);

/**
 * Get assignment by UUID
 * Retrieves a complete assignment including submission statistics.
 */
export const getAssignmentByUuidOptions = (options: Options<GetAssignmentByUuidData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getAssignmentByUuid({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getAssignmentByUuidQueryKey(options),
  });
};

/**
 * Update assignment
 * Updates an existing assignment with selective field updates.
 */
export const updateAssignmentMutation = (
  options?: Partial<Options<UpdateAssignmentData>>
): UseMutationOptions<
  UpdateAssignmentResponse,
  UpdateAssignmentError,
  Options<UpdateAssignmentData>
> => {
  const mutationOptions: UseMutationOptions<
    UpdateAssignmentResponse,
    UpdateAssignmentError,
    Options<UpdateAssignmentData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await updateAssignment({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const declineInvitationQueryKey = (options: Options<DeclineInvitationData>) =>
  createQueryKey('declineInvitation', options);

/**
 * Decline invitation by token
 * Declines a pending invitation for the specified user using the unique token from the invitation email. This marks the invitation as declined and sends notification emails to the inviter. The invitation must be valid (not expired, not already accepted/declined) and the user email must match the invitation recipient.
 */
export const declineInvitationOptions = (options: Options<DeclineInvitationData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await declineInvitation({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: declineInvitationQueryKey(options),
  });
};

/**
 * Decline invitation by token
 * Declines a pending invitation for the specified user using the unique token from the invitation email. This marks the invitation as declined and sends notification emails to the inviter. The invitation must be valid (not expired, not already accepted/declined) and the user email must match the invitation recipient.
 */
export const declineInvitationMutation = (
  options?: Partial<Options<DeclineInvitationData>>
): UseMutationOptions<
  DeclineInvitationResponse,
  DeclineInvitationError,
  Options<DeclineInvitationData>
> => {
  const mutationOptions: UseMutationOptions<
    DeclineInvitationResponse,
    DeclineInvitationError,
    Options<DeclineInvitationData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await declineInvitation({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const acceptInvitationQueryKey = (options: Options<AcceptInvitationData>) =>
  createQueryKey('acceptInvitation', options);

/**
 * Accept invitation by token
 * Accepts a pending invitation for the specified user using the unique token from the invitation email. This creates the user-organization relationship with the specified role and sends confirmation emails. The invitation must be valid (not expired, not already accepted/declined) and the user email must match the invitation recipient.
 */
export const acceptInvitationOptions = (options: Options<AcceptInvitationData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await acceptInvitation({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: acceptInvitationQueryKey(options),
  });
};

/**
 * Accept invitation by token
 * Accepts a pending invitation for the specified user using the unique token from the invitation email. This creates the user-organization relationship with the specified role and sends confirmation emails. The invitation must be valid (not expired, not already accepted/declined) and the user email must match the invitation recipient.
 */
export const acceptInvitationMutation = (
  options?: Partial<Options<AcceptInvitationData>>
): UseMutationOptions<
  AcceptInvitationResponse,
  AcceptInvitationError,
  Options<AcceptInvitationData>
> => {
  const mutationOptions: UseMutationOptions<
    AcceptInvitationResponse,
    AcceptInvitationError,
    Options<AcceptInvitationData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await acceptInvitation({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const uploadProfileImageQueryKey = (options: Options<UploadProfileImageData>) =>
  createQueryKey('uploadProfileImage', options);

/**
 * Upload User's Profile Image
 */
export const uploadProfileImageOptions = (options: Options<UploadProfileImageData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await uploadProfileImage({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: uploadProfileImageQueryKey(options),
  });
};

/**
 * Upload User's Profile Image
 */
export const uploadProfileImageMutation = (
  options?: Partial<Options<UploadProfileImageData>>
): UseMutationOptions<
  UploadProfileImageResponse,
  UploadProfileImageError,
  Options<UploadProfileImageData>
> => {
  const mutationOptions: UseMutationOptions<
    UploadProfileImageResponse,
    UploadProfileImageError,
    Options<UploadProfileImageData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await uploadProfileImage({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getAllTrainingBranchesQueryKey = (options?: Options<GetAllTrainingBranchesData>) =>
  createQueryKey('getAllTrainingBranches', options);

/**
 * Get all training branches
 */
export const getAllTrainingBranchesOptions = (options?: Options<GetAllTrainingBranchesData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getAllTrainingBranches({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getAllTrainingBranchesQueryKey(options),
  });
};

const createInfiniteParams = <
  K extends Pick<QueryKey<Options>[0], 'body' | 'headers' | 'path' | 'query'>,
>(
  queryKey: QueryKey<Options>,
  page: K
) => {
  const params = {
    ...queryKey[0],
  };
  if (page.body) {
    params.body = {
      ...(queryKey[0].body as any),
      ...(page.body as any),
    };
  }
  if (page.headers) {
    params.headers = {
      ...queryKey[0].headers,
      ...page.headers,
    };
  }
  if (page.path) {
    params.path = {
      ...(queryKey[0].path as any),
      ...(page.path as any),
    };
  }
  if (page.query) {
    params.query = {
      ...(queryKey[0].query as any),
      ...(page.query as any),
    };
  }
  return params as unknown as typeof page;
};

export const getAllTrainingBranchesInfiniteQueryKey = (
  options?: Options<GetAllTrainingBranchesData>
): QueryKey<Options<GetAllTrainingBranchesData>> =>
  createQueryKey('getAllTrainingBranches', options, true);

/**
 * Get all training branches
 */
export const getAllTrainingBranchesInfiniteOptions = (
  options?: Options<GetAllTrainingBranchesData>
) => {
  return infiniteQueryOptions<
    GetAllTrainingBranchesResponse,
    GetAllTrainingBranchesError,
    InfiniteData<GetAllTrainingBranchesResponse>,
    QueryKey<Options<GetAllTrainingBranchesData>>,
    | number
    | Pick<QueryKey<Options<GetAllTrainingBranchesData>>[0], 'body' | 'headers' | 'path' | 'query'>
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<GetAllTrainingBranchesData>>[0],
          'body' | 'headers' | 'path' | 'query'
        > =
          typeof pageParam === 'object'
            ? pageParam
            : {
                query: {
                  page: pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getAllTrainingBranches({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: getAllTrainingBranchesInfiniteQueryKey(options),
    }
  );
};

export const createTrainingBranchQueryKey = (options: Options<CreateTrainingBranchData>) =>
  createQueryKey('createTrainingBranch', options);

/**
 * Create a new training branch
 */
export const createTrainingBranchOptions = (options: Options<CreateTrainingBranchData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await createTrainingBranch({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: createTrainingBranchQueryKey(options),
  });
};

/**
 * Create a new training branch
 */
export const createTrainingBranchMutation = (
  options?: Partial<Options<CreateTrainingBranchData>>
): UseMutationOptions<
  CreateTrainingBranchResponse,
  CreateTrainingBranchError,
  Options<CreateTrainingBranchData>
> => {
  const mutationOptions: UseMutationOptions<
    CreateTrainingBranchResponse,
    CreateTrainingBranchError,
    Options<CreateTrainingBranchData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await createTrainingBranch({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getAllStudentsQueryKey = (options?: Options<GetAllStudentsData>) =>
  createQueryKey('getAllStudents', options);

/**
 * Get all students
 * Fetches a paginated list of students.
 */
export const getAllStudentsOptions = (options?: Options<GetAllStudentsData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getAllStudents({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getAllStudentsQueryKey(options),
  });
};

export const getAllStudentsInfiniteQueryKey = (
  options?: Options<GetAllStudentsData>
): QueryKey<Options<GetAllStudentsData>> => createQueryKey('getAllStudents', options, true);

/**
 * Get all students
 * Fetches a paginated list of students.
 */
export const getAllStudentsInfiniteOptions = (options?: Options<GetAllStudentsData>) => {
  return infiniteQueryOptions<
    GetAllStudentsResponse,
    GetAllStudentsError,
    InfiniteData<GetAllStudentsResponse>,
    QueryKey<Options<GetAllStudentsData>>,
    number | Pick<QueryKey<Options<GetAllStudentsData>>[0], 'body' | 'headers' | 'path' | 'query'>
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<GetAllStudentsData>>[0],
          'body' | 'headers' | 'path' | 'query'
        > =
          typeof pageParam === 'object'
            ? pageParam
            : {
                query: {
                  page: pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getAllStudents({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: getAllStudentsInfiniteQueryKey(options),
    }
  );
};

export const createStudentQueryKey = (options: Options<CreateStudentData>) =>
  createQueryKey('createStudent', options);

/**
 * Create a new student
 * Saves a new student record in the system.
 */
export const createStudentOptions = (options: Options<CreateStudentData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await createStudent({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: createStudentQueryKey(options),
  });
};

/**
 * Create a new student
 * Saves a new student record in the system.
 */
export const createStudentMutation = (
  options?: Partial<Options<CreateStudentData>>
): UseMutationOptions<CreateStudentResponse, CreateStudentError, Options<CreateStudentData>> => {
  const mutationOptions: UseMutationOptions<
    CreateStudentResponse,
    CreateStudentError,
    Options<CreateStudentData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await createStudent({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getAllQuizzesQueryKey = (options?: Options<GetAllQuizzesData>) =>
  createQueryKey('getAllQuizzes', options);

/**
 * Get all quizzes
 * Retrieves paginated list of all quizzes with filtering support.
 */
export const getAllQuizzesOptions = (options?: Options<GetAllQuizzesData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getAllQuizzes({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getAllQuizzesQueryKey(options),
  });
};

export const getAllQuizzesInfiniteQueryKey = (
  options?: Options<GetAllQuizzesData>
): QueryKey<Options<GetAllQuizzesData>> => createQueryKey('getAllQuizzes', options, true);

/**
 * Get all quizzes
 * Retrieves paginated list of all quizzes with filtering support.
 */
export const getAllQuizzesInfiniteOptions = (options?: Options<GetAllQuizzesData>) => {
  return infiniteQueryOptions<
    GetAllQuizzesResponse,
    GetAllQuizzesError,
    InfiniteData<GetAllQuizzesResponse>,
    QueryKey<Options<GetAllQuizzesData>>,
    number | Pick<QueryKey<Options<GetAllQuizzesData>>[0], 'body' | 'headers' | 'path' | 'query'>
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<GetAllQuizzesData>>[0],
          'body' | 'headers' | 'path' | 'query'
        > =
          typeof pageParam === 'object'
            ? pageParam
            : {
                query: {
                  page: pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getAllQuizzes({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: getAllQuizzesInfiniteQueryKey(options),
    }
  );
};

export const createQuizQueryKey = (options: Options<CreateQuizData>) =>
  createQueryKey('createQuiz', options);

/**
 * Create a new quiz
 * Creates a new quiz with default DRAFT status and inactive state.
 */
export const createQuizOptions = (options: Options<CreateQuizData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await createQuiz({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: createQuizQueryKey(options),
  });
};

/**
 * Create a new quiz
 * Creates a new quiz with default DRAFT status and inactive state.
 */
export const createQuizMutation = (
  options?: Partial<Options<CreateQuizData>>
): UseMutationOptions<CreateQuizResponse, CreateQuizError, Options<CreateQuizData>> => {
  const mutationOptions: UseMutationOptions<
    CreateQuizResponse,
    CreateQuizError,
    Options<CreateQuizData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await createQuiz({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getQuizQuestionsQueryKey = (options: Options<GetQuizQuestionsData>) =>
  createQueryKey('getQuizQuestions', options);

/**
 * Get quiz questions
 * Retrieves all questions for a quiz in display order with computed properties.
 */
export const getQuizQuestionsOptions = (options: Options<GetQuizQuestionsData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getQuizQuestions({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getQuizQuestionsQueryKey(options),
  });
};

export const addQuizQuestionQueryKey = (options: Options<AddQuizQuestionData>) =>
  createQueryKey('addQuizQuestion', options);

/**
 * Add question to quiz
 * Creates a new question for the specified quiz with automatic ordering.
 */
export const addQuizQuestionOptions = (options: Options<AddQuizQuestionData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await addQuizQuestion({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: addQuizQuestionQueryKey(options),
  });
};

/**
 * Add question to quiz
 * Creates a new question for the specified quiz with automatic ordering.
 */
export const addQuizQuestionMutation = (
  options?: Partial<Options<AddQuizQuestionData>>
): UseMutationOptions<
  AddQuizQuestionResponse,
  AddQuizQuestionError,
  Options<AddQuizQuestionData>
> => {
  const mutationOptions: UseMutationOptions<
    AddQuizQuestionResponse,
    AddQuizQuestionError,
    Options<AddQuizQuestionData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await addQuizQuestion({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getQuestionOptionsQueryKey = (options: Options<GetQuestionOptionsData>) =>
  createQueryKey('getQuestionOptions', options);

/**
 * Get question options
 * Retrieves all options for a specific question.
 */
export const getQuestionOptionsOptions = (options: Options<GetQuestionOptionsData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getQuestionOptions({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getQuestionOptionsQueryKey(options),
  });
};

export const getQuestionOptionsInfiniteQueryKey = (
  options: Options<GetQuestionOptionsData>
): QueryKey<Options<GetQuestionOptionsData>> => createQueryKey('getQuestionOptions', options, true);

/**
 * Get question options
 * Retrieves all options for a specific question.
 */
export const getQuestionOptionsInfiniteOptions = (options: Options<GetQuestionOptionsData>) => {
  return infiniteQueryOptions<
    GetQuestionOptionsResponse,
    GetQuestionOptionsError,
    InfiniteData<GetQuestionOptionsResponse>,
    QueryKey<Options<GetQuestionOptionsData>>,
    | number
    | Pick<QueryKey<Options<GetQuestionOptionsData>>[0], 'body' | 'headers' | 'path' | 'query'>
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<GetQuestionOptionsData>>[0],
          'body' | 'headers' | 'path' | 'query'
        > =
          typeof pageParam === 'object'
            ? pageParam
            : {
                query: {
                  page: pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getQuestionOptions({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: getQuestionOptionsInfiniteQueryKey(options),
    }
  );
};

export const addQuestionOptionQueryKey = (options: Options<AddQuestionOptionData>) =>
  createQueryKey('addQuestionOption', options);

/**
 * Add option to question
 * Creates a new option for a multiple choice or true/false question.
 */
export const addQuestionOptionOptions = (options: Options<AddQuestionOptionData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await addQuestionOption({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: addQuestionOptionQueryKey(options),
  });
};

/**
 * Add option to question
 * Creates a new option for a multiple choice or true/false question.
 */
export const addQuestionOptionMutation = (
  options?: Partial<Options<AddQuestionOptionData>>
): UseMutationOptions<
  AddQuestionOptionResponse,
  AddQuestionOptionError,
  Options<AddQuestionOptionData>
> => {
  const mutationOptions: UseMutationOptions<
    AddQuestionOptionResponse,
    AddQuestionOptionError,
    Options<AddQuestionOptionData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await addQuestionOption({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const reorderQuizQuestionsQueryKey = (options: Options<ReorderQuizQuestionsData>) =>
  createQueryKey('reorderQuizQuestions', options);

/**
 * Reorder quiz questions
 * Updates the display order of questions within a quiz.
 */
export const reorderQuizQuestionsOptions = (options: Options<ReorderQuizQuestionsData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await reorderQuizQuestions({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: reorderQuizQuestionsQueryKey(options),
  });
};

/**
 * Reorder quiz questions
 * Updates the display order of questions within a quiz.
 */
export const reorderQuizQuestionsMutation = (
  options?: Partial<Options<ReorderQuizQuestionsData>>
): UseMutationOptions<
  ReorderQuizQuestionsResponse,
  ReorderQuizQuestionsError,
  Options<ReorderQuizQuestionsData>
> => {
  const mutationOptions: UseMutationOptions<
    ReorderQuizQuestionsResponse,
    ReorderQuizQuestionsError,
    Options<ReorderQuizQuestionsData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await reorderQuizQuestions({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getAllTrainingProgramsQueryKey = (options?: Options<GetAllTrainingProgramsData>) =>
  createQueryKey('getAllTrainingPrograms', options);

/**
 * Get all programs
 * Retrieves paginated list of all training programs with filtering support.
 */
export const getAllTrainingProgramsOptions = (options?: Options<GetAllTrainingProgramsData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getAllTrainingPrograms({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getAllTrainingProgramsQueryKey(options),
  });
};

export const getAllTrainingProgramsInfiniteQueryKey = (
  options?: Options<GetAllTrainingProgramsData>
): QueryKey<Options<GetAllTrainingProgramsData>> =>
  createQueryKey('getAllTrainingPrograms', options, true);

/**
 * Get all programs
 * Retrieves paginated list of all training programs with filtering support.
 */
export const getAllTrainingProgramsInfiniteOptions = (
  options?: Options<GetAllTrainingProgramsData>
) => {
  return infiniteQueryOptions<
    unknown,
    GetAllTrainingProgramsError,
    InfiniteData<unknown>,
    QueryKey<Options<GetAllTrainingProgramsData>>,
    | number
    | Pick<QueryKey<Options<GetAllTrainingProgramsData>>[0], 'body' | 'headers' | 'path' | 'query'>
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<GetAllTrainingProgramsData>>[0],
          'body' | 'headers' | 'path' | 'query'
        > =
          typeof pageParam === 'object'
            ? pageParam
            : {
                query: {
                  page: pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getAllTrainingPrograms({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: getAllTrainingProgramsInfiniteQueryKey(options),
    }
  );
};

export const createTrainingProgramQueryKey = (options: Options<CreateTrainingProgramData>) =>
  createQueryKey('createTrainingProgram', options);

/**
 * Create a new training program
 * Creates a new training program with default DRAFT status and inactive state.
 */
export const createTrainingProgramOptions = (options: Options<CreateTrainingProgramData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await createTrainingProgram({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: createTrainingProgramQueryKey(options),
  });
};

/**
 * Create a new training program
 * Creates a new training program with default DRAFT status and inactive state.
 */
export const createTrainingProgramMutation = (
  options?: Partial<Options<CreateTrainingProgramData>>
): UseMutationOptions<
  CreateTrainingProgramResponse,
  CreateTrainingProgramError,
  Options<CreateTrainingProgramData>
> => {
  const mutationOptions: UseMutationOptions<
    CreateTrainingProgramResponse,
    CreateTrainingProgramError,
    Options<CreateTrainingProgramData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await createTrainingProgram({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const publishProgramQueryKey = (options: Options<PublishProgramData>) =>
  createQueryKey('publishProgram', options);

/**
 * Publish training program
 * Publishes a program making it available for enrollment.
 */
export const publishProgramOptions = (options: Options<PublishProgramData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await publishProgram({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: publishProgramQueryKey(options),
  });
};

/**
 * Publish training program
 * Publishes a program making it available for enrollment.
 */
export const publishProgramMutation = (
  options?: Partial<Options<PublishProgramData>>
): UseMutationOptions<unknown, PublishProgramError, Options<PublishProgramData>> => {
  const mutationOptions: UseMutationOptions<
    unknown,
    PublishProgramError,
    Options<PublishProgramData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await publishProgram({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getProgramRequirementsQueryKey = (options: Options<GetProgramRequirementsData>) =>
  createQueryKey('getProgramRequirements', options);

/**
 * Get program requirements
 * Retrieves all requirements for a specific program.
 */
export const getProgramRequirementsOptions = (options: Options<GetProgramRequirementsData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getProgramRequirements({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getProgramRequirementsQueryKey(options),
  });
};

export const getProgramRequirementsInfiniteQueryKey = (
  options: Options<GetProgramRequirementsData>
): QueryKey<Options<GetProgramRequirementsData>> =>
  createQueryKey('getProgramRequirements', options, true);

/**
 * Get program requirements
 * Retrieves all requirements for a specific program.
 */
export const getProgramRequirementsInfiniteOptions = (
  options: Options<GetProgramRequirementsData>
) => {
  return infiniteQueryOptions<
    GetProgramRequirementsResponse,
    GetProgramRequirementsError,
    InfiniteData<GetProgramRequirementsResponse>,
    QueryKey<Options<GetProgramRequirementsData>>,
    | number
    | Pick<QueryKey<Options<GetProgramRequirementsData>>[0], 'body' | 'headers' | 'path' | 'query'>
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<GetProgramRequirementsData>>[0],
          'body' | 'headers' | 'path' | 'query'
        > =
          typeof pageParam === 'object'
            ? pageParam
            : {
                query: {
                  page: pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getProgramRequirements({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: getProgramRequirementsInfiniteQueryKey(options),
    }
  );
};

export const addProgramRequirementQueryKey = (options: Options<AddProgramRequirementData>) =>
  createQueryKey('addProgramRequirement', options);

/**
 * Add requirement to program
 * Adds a new requirement or prerequisite to a program.
 */
export const addProgramRequirementOptions = (options: Options<AddProgramRequirementData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await addProgramRequirement({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: addProgramRequirementQueryKey(options),
  });
};

/**
 * Add requirement to program
 * Adds a new requirement or prerequisite to a program.
 */
export const addProgramRequirementMutation = (
  options?: Partial<Options<AddProgramRequirementData>>
): UseMutationOptions<
  AddProgramRequirementResponse,
  AddProgramRequirementError,
  Options<AddProgramRequirementData>
> => {
  const mutationOptions: UseMutationOptions<
    AddProgramRequirementResponse,
    AddProgramRequirementError,
    Options<AddProgramRequirementData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await addProgramRequirement({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getProgramCoursesQueryKey = (options: Options<GetProgramCoursesData>) =>
  createQueryKey('getProgramCourses', options);

/**
 * Get program courses
 * Retrieves all courses in a program in sequence order with requirement status.
 */
export const getProgramCoursesOptions = (options: Options<GetProgramCoursesData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getProgramCourses({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getProgramCoursesQueryKey(options),
  });
};

export const addProgramCourseQueryKey = (options: Options<AddProgramCourseData>) =>
  createQueryKey('addProgramCourse', options);

/**
 * Add course to program
 * Associates a course with a program, setting sequence and requirement status.
 */
export const addProgramCourseOptions = (options: Options<AddProgramCourseData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await addProgramCourse({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: addProgramCourseQueryKey(options),
  });
};

/**
 * Add course to program
 * Associates a course with a program, setting sequence and requirement status.
 */
export const addProgramCourseMutation = (
  options?: Partial<Options<AddProgramCourseData>>
): UseMutationOptions<
  AddProgramCourseResponse,
  AddProgramCourseError,
  Options<AddProgramCourseData>
> => {
  const mutationOptions: UseMutationOptions<
    AddProgramCourseResponse,
    AddProgramCourseError,
    Options<AddProgramCourseData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await addProgramCourse({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getAllOrganisationsQueryKey = (options?: Options<GetAllOrganisationsData>) =>
  createQueryKey('getAllOrganisations', options);

/**
 * Get all organisations
 */
export const getAllOrganisationsOptions = (options?: Options<GetAllOrganisationsData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getAllOrganisations({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getAllOrganisationsQueryKey(options),
  });
};

export const getAllOrganisationsInfiniteQueryKey = (
  options?: Options<GetAllOrganisationsData>
): QueryKey<Options<GetAllOrganisationsData>> =>
  createQueryKey('getAllOrganisations', options, true);

/**
 * Get all organisations
 */
export const getAllOrganisationsInfiniteOptions = (options?: Options<GetAllOrganisationsData>) => {
  return infiniteQueryOptions<
    GetAllOrganisationsResponse,
    GetAllOrganisationsError,
    InfiniteData<GetAllOrganisationsResponse>,
    QueryKey<Options<GetAllOrganisationsData>>,
    | number
    | Pick<QueryKey<Options<GetAllOrganisationsData>>[0], 'body' | 'headers' | 'path' | 'query'>
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<GetAllOrganisationsData>>[0],
          'body' | 'headers' | 'path' | 'query'
        > =
          typeof pageParam === 'object'
            ? pageParam
            : {
                query: {
                  page: pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getAllOrganisations({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: getAllOrganisationsInfiniteQueryKey(options),
    }
  );
};

export const createOrganisationQueryKey = (options: Options<CreateOrganisationData>) =>
  createQueryKey('createOrganisation', options);

/**
 * Create a new organisation
 */
export const createOrganisationOptions = (options: Options<CreateOrganisationData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await createOrganisation({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: createOrganisationQueryKey(options),
  });
};

/**
 * Create a new organisation
 */
export const createOrganisationMutation = (
  options?: Partial<Options<CreateOrganisationData>>
): UseMutationOptions<
  CreateOrganisationResponse,
  CreateOrganisationError,
  Options<CreateOrganisationData>
> => {
  const mutationOptions: UseMutationOptions<
    CreateOrganisationResponse,
    CreateOrganisationError,
    Options<CreateOrganisationData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await createOrganisation({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getTrainingBranchesByOrganisationQueryKey = (
  options: Options<GetTrainingBranchesByOrganisationData>
) => createQueryKey('getTrainingBranchesByOrganisation', options);

/**
 * Get training branches by organisation UUID
 */
export const getTrainingBranchesByOrganisationOptions = (
  options: Options<GetTrainingBranchesByOrganisationData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getTrainingBranchesByOrganisation({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getTrainingBranchesByOrganisationQueryKey(options),
  });
};

export const getTrainingBranchesByOrganisationInfiniteQueryKey = (
  options: Options<GetTrainingBranchesByOrganisationData>
): QueryKey<Options<GetTrainingBranchesByOrganisationData>> =>
  createQueryKey('getTrainingBranchesByOrganisation', options, true);

/**
 * Get training branches by organisation UUID
 */
export const getTrainingBranchesByOrganisationInfiniteOptions = (
  options: Options<GetTrainingBranchesByOrganisationData>
) => {
  return infiniteQueryOptions<
    GetTrainingBranchesByOrganisationResponse,
    GetTrainingBranchesByOrganisationError,
    InfiniteData<GetTrainingBranchesByOrganisationResponse>,
    QueryKey<Options<GetTrainingBranchesByOrganisationData>>,
    | number
    | Pick<
        QueryKey<Options<GetTrainingBranchesByOrganisationData>>[0],
        'body' | 'headers' | 'path' | 'query'
      >
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<GetTrainingBranchesByOrganisationData>>[0],
          'body' | 'headers' | 'path' | 'query'
        > =
          typeof pageParam === 'object'
            ? pageParam
            : {
                query: {
                  page: pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getTrainingBranchesByOrganisation({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: getTrainingBranchesByOrganisationInfiniteQueryKey(options),
    }
  );
};

export const createTrainingBranch1QueryKey = (options: Options<CreateTrainingBranch1Data>) =>
  createQueryKey('createTrainingBranch1', options);

/**
 * Create a new training branch within organization
 */
export const createTrainingBranch1Options = (options: Options<CreateTrainingBranch1Data>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await createTrainingBranch1({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: createTrainingBranch1QueryKey(options),
  });
};

/**
 * Create a new training branch within organization
 */
export const createTrainingBranch1Mutation = (
  options?: Partial<Options<CreateTrainingBranch1Data>>
): UseMutationOptions<
  CreateTrainingBranch1Response,
  CreateTrainingBranch1Error,
  Options<CreateTrainingBranch1Data>
> => {
  const mutationOptions: UseMutationOptions<
    CreateTrainingBranch1Response,
    CreateTrainingBranch1Error,
    Options<CreateTrainingBranch1Data>
  > = {
    mutationFn: async localOptions => {
      const { data } = await createTrainingBranch1({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Remove user from training branch
 * Removes a user from a training branch. The user remains in the parent organization but loses branch-specific assignment.
 */
export const removeUserFromBranchMutation = (
  options?: Partial<Options<RemoveUserFromBranchData>>
): UseMutationOptions<
  RemoveUserFromBranchResponse,
  RemoveUserFromBranchError,
  Options<RemoveUserFromBranchData>
> => {
  const mutationOptions: UseMutationOptions<
    RemoveUserFromBranchResponse,
    RemoveUserFromBranchError,
    Options<RemoveUserFromBranchData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await removeUserFromBranch({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const assignUserToBranchQueryKey = (options: Options<AssignUserToBranchData>) =>
  createQueryKey('assignUserToBranch', options);

/**
 * Assign user to training branch
 * Assigns a user to a specific training branch with a defined role. If the user is not already in the parent organization, creates organization membership first. If the user is already in the organization, updates their branch assignment.
 */
export const assignUserToBranchOptions = (options: Options<AssignUserToBranchData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await assignUserToBranch({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: assignUserToBranchQueryKey(options),
  });
};

/**
 * Assign user to training branch
 * Assigns a user to a specific training branch with a defined role. If the user is not already in the parent organization, creates organization membership first. If the user is already in the organization, updates their branch assignment.
 */
export const assignUserToBranchMutation = (
  options?: Partial<Options<AssignUserToBranchData>>
): UseMutationOptions<
  AssignUserToBranchResponse,
  AssignUserToBranchError,
  Options<AssignUserToBranchData>
> => {
  const mutationOptions: UseMutationOptions<
    AssignUserToBranchResponse,
    AssignUserToBranchError,
    Options<AssignUserToBranchData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await assignUserToBranch({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getBranchInvitationsQueryKey = (options: Options<GetBranchInvitationsData>) =>
  createQueryKey('getBranchInvitations', options);

/**
 * Get all invitations for training branch
 * Retrieves all invitations (regardless of status) that have been sent specifically for this training branch. This only includes branch-specific invitations, not general organization invitations. Results are ordered by creation date (most recent first) and include all invitation statuses.
 */
export const getBranchInvitationsOptions = (options: Options<GetBranchInvitationsData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getBranchInvitations({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getBranchInvitationsQueryKey(options),
  });
};

export const createBranchInvitationQueryKey = (options: Options<CreateBranchInvitationData>) =>
  createQueryKey('createBranchInvitation', options);

/**
 * Create training branch invitation
 * Creates and sends an email invitation for a user to join a specific training branch with a defined role. This is a specialized invitation that automatically determines the parent organization from the branch. The invitation email will include branch-specific information and location details.
 */
export const createBranchInvitationOptions = (options: Options<CreateBranchInvitationData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await createBranchInvitation({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: createBranchInvitationQueryKey(options),
  });
};

/**
 * Create training branch invitation
 * Creates and sends an email invitation for a user to join a specific training branch with a defined role. This is a specialized invitation that automatically determines the parent organization from the branch. The invitation email will include branch-specific information and location details.
 */
export const createBranchInvitationMutation = (
  options?: Partial<Options<CreateBranchInvitationData>>
): UseMutationOptions<
  CreateBranchInvitationResponse,
  CreateBranchInvitationError,
  Options<CreateBranchInvitationData>
> => {
  const mutationOptions: UseMutationOptions<
    CreateBranchInvitationResponse,
    CreateBranchInvitationError,
    Options<CreateBranchInvitationData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await createBranchInvitation({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getOrganizationInvitationsQueryKey = (
  options: Options<GetOrganizationInvitationsData>
) => createQueryKey('getOrganizationInvitations', options);

/**
 * Get all invitations for organization
 * Retrieves all invitations (regardless of status) that have been sent for this specific organization. This includes organization-level invitations and branch-specific invitations within the organization. Results are ordered by creation date (most recent first) and include all invitation statuses.
 */
export const getOrganizationInvitationsOptions = (
  options: Options<GetOrganizationInvitationsData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getOrganizationInvitations({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getOrganizationInvitationsQueryKey(options),
  });
};

export const createOrganizationInvitationQueryKey = (
  options: Options<CreateOrganizationInvitationData>
) => createQueryKey('createOrganizationInvitation', options);

/**
 * Create organization invitation
 * Creates and sends an email invitation for a user to join this specific organization with a defined role. If a training branch UUID is provided, the invitation will be branch-specific within the organization. The invitation email will be sent to the recipient with acceptance and decline links containing the unique token.
 */
export const createOrganizationInvitationOptions = (
  options: Options<CreateOrganizationInvitationData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await createOrganizationInvitation({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: createOrganizationInvitationQueryKey(options),
  });
};

/**
 * Create organization invitation
 * Creates and sends an email invitation for a user to join this specific organization with a defined role. If a training branch UUID is provided, the invitation will be branch-specific within the organization. The invitation email will be sent to the recipient with acceptance and decline links containing the unique token.
 */
export const createOrganizationInvitationMutation = (
  options?: Partial<Options<CreateOrganizationInvitationData>>
): UseMutationOptions<
  CreateOrganizationInvitationResponse,
  CreateOrganizationInvitationError,
  Options<CreateOrganizationInvitationData>
> => {
  const mutationOptions: UseMutationOptions<
    CreateOrganizationInvitationResponse,
    CreateOrganizationInvitationError,
    Options<CreateOrganizationInvitationData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await createOrganizationInvitation({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const resendInvitationQueryKey = (options: Options<ResendInvitationData>) =>
  createQueryKey('resendInvitation', options);

/**
 * Resend invitation email
 * Resends the invitation email to the recipient with a fresh expiration date. Only pending invitations can be resent. The invitation expiry date will be extended from the current time. Only the original inviter or an organization administrator can resend invitations.
 */
export const resendInvitationOptions = (options: Options<ResendInvitationData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await resendInvitation({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: resendInvitationQueryKey(options),
  });
};

/**
 * Resend invitation email
 * Resends the invitation email to the recipient with a fresh expiration date. Only pending invitations can be resent. The invitation expiry date will be extended from the current time. Only the original inviter or an organization administrator can resend invitations.
 */
export const resendInvitationMutation = (
  options?: Partial<Options<ResendInvitationData>>
): UseMutationOptions<
  ResendInvitationResponse,
  ResendInvitationError,
  Options<ResendInvitationData>
> => {
  const mutationOptions: UseMutationOptions<
    ResendInvitationResponse,
    ResendInvitationError,
    Options<ResendInvitationData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await resendInvitation({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const sendExpiryRemindersQueryKey = (options?: Options<SendExpiryRemindersData>) =>
  createQueryKey('sendExpiryReminders', options);

/**
 * Send expiry reminders
 * System maintenance endpoint to send reminder emails for invitations expiring soon. This is typically called by scheduled jobs to notify recipients about expiring invitations.
 */
export const sendExpiryRemindersOptions = (options?: Options<SendExpiryRemindersData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await sendExpiryReminders({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: sendExpiryRemindersQueryKey(options),
  });
};

/**
 * Send expiry reminders
 * System maintenance endpoint to send reminder emails for invitations expiring soon. This is typically called by scheduled jobs to notify recipients about expiring invitations.
 */
export const sendExpiryRemindersMutation = (
  options?: Partial<Options<SendExpiryRemindersData>>
): UseMutationOptions<
  SendExpiryRemindersResponse,
  SendExpiryRemindersError,
  Options<SendExpiryRemindersData>
> => {
  const mutationOptions: UseMutationOptions<
    SendExpiryRemindersResponse,
    SendExpiryRemindersError,
    Options<SendExpiryRemindersData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await sendExpiryReminders({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const markExpiredInvitationsQueryKey = (options?: Options<MarkExpiredInvitationsData>) =>
  createQueryKey('markExpiredInvitations', options);

/**
 * Mark expired invitations
 * System maintenance endpoint to mark all expired pending invitations as expired. This is typically called by scheduled jobs to clean up expired invitations.
 */
export const markExpiredInvitationsOptions = (options?: Options<MarkExpiredInvitationsData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await markExpiredInvitations({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: markExpiredInvitationsQueryKey(options),
  });
};

/**
 * Mark expired invitations
 * System maintenance endpoint to mark all expired pending invitations as expired. This is typically called by scheduled jobs to clean up expired invitations.
 */
export const markExpiredInvitationsMutation = (
  options?: Partial<Options<MarkExpiredInvitationsData>>
): UseMutationOptions<
  MarkExpiredInvitationsResponse,
  MarkExpiredInvitationsError,
  Options<MarkExpiredInvitationsData>
> => {
  const mutationOptions: UseMutationOptions<
    MarkExpiredInvitationsResponse,
    MarkExpiredInvitationsError,
    Options<MarkExpiredInvitationsData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await markExpiredInvitations({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getAllInstructorsQueryKey = (options?: Options<GetAllInstructorsData>) =>
  createQueryKey('getAllInstructors', options);

/**
 * Get all instructors
 * Fetches a paginated list of instructors.
 */
export const getAllInstructorsOptions = (options?: Options<GetAllInstructorsData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getAllInstructors({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getAllInstructorsQueryKey(options),
  });
};

export const getAllInstructorsInfiniteQueryKey = (
  options?: Options<GetAllInstructorsData>
): QueryKey<Options<GetAllInstructorsData>> => createQueryKey('getAllInstructors', options, true);

/**
 * Get all instructors
 * Fetches a paginated list of instructors.
 */
export const getAllInstructorsInfiniteOptions = (options?: Options<GetAllInstructorsData>) => {
  return infiniteQueryOptions<
    GetAllInstructorsResponse,
    GetAllInstructorsError,
    InfiniteData<GetAllInstructorsResponse>,
    QueryKey<Options<GetAllInstructorsData>>,
    | number
    | Pick<QueryKey<Options<GetAllInstructorsData>>[0], 'body' | 'headers' | 'path' | 'query'>
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<GetAllInstructorsData>>[0],
          'body' | 'headers' | 'path' | 'query'
        > =
          typeof pageParam === 'object'
            ? pageParam
            : {
                query: {
                  page: pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getAllInstructors({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: getAllInstructorsInfiniteQueryKey(options),
    }
  );
};

export const createInstructorQueryKey = (options: Options<CreateInstructorData>) =>
  createQueryKey('createInstructor', options);

/**
 * Create a new instructor
 * Saves a new instructor record in the system.
 */
export const createInstructorOptions = (options: Options<CreateInstructorData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await createInstructor({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: createInstructorQueryKey(options),
  });
};

/**
 * Create a new instructor
 * Saves a new instructor record in the system.
 */
export const createInstructorMutation = (
  options?: Partial<Options<CreateInstructorData>>
): UseMutationOptions<
  CreateInstructorResponse,
  CreateInstructorError,
  Options<CreateInstructorData>
> => {
  const mutationOptions: UseMutationOptions<
    CreateInstructorResponse,
    CreateInstructorError,
    Options<CreateInstructorData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await createInstructor({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getInstructorSkillsQueryKey = (options: Options<GetInstructorSkillsData>) =>
  createQueryKey('getInstructorSkills', options);

/**
 * Get instructor skills
 * Retrieves all skills for a specific instructor
 */
export const getInstructorSkillsOptions = (options: Options<GetInstructorSkillsData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getInstructorSkills({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getInstructorSkillsQueryKey(options),
  });
};

export const getInstructorSkillsInfiniteQueryKey = (
  options: Options<GetInstructorSkillsData>
): QueryKey<Options<GetInstructorSkillsData>> =>
  createQueryKey('getInstructorSkills', options, true);

/**
 * Get instructor skills
 * Retrieves all skills for a specific instructor
 */
export const getInstructorSkillsInfiniteOptions = (options: Options<GetInstructorSkillsData>) => {
  return infiniteQueryOptions<
    GetInstructorSkillsResponse,
    GetInstructorSkillsError,
    InfiniteData<GetInstructorSkillsResponse>,
    QueryKey<Options<GetInstructorSkillsData>>,
    | number
    | Pick<QueryKey<Options<GetInstructorSkillsData>>[0], 'body' | 'headers' | 'path' | 'query'>
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<GetInstructorSkillsData>>[0],
          'body' | 'headers' | 'path' | 'query'
        > =
          typeof pageParam === 'object'
            ? pageParam
            : {
                query: {
                  page: pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getInstructorSkills({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: getInstructorSkillsInfiniteQueryKey(options),
    }
  );
};

export const addInstructorSkillQueryKey = (options: Options<AddInstructorSkillData>) =>
  createQueryKey('addInstructorSkill', options);

/**
 * Add skill to instructor
 * Adds a skill to an instructor
 */
export const addInstructorSkillOptions = (options: Options<AddInstructorSkillData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await addInstructorSkill({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: addInstructorSkillQueryKey(options),
  });
};

/**
 * Add skill to instructor
 * Adds a skill to an instructor
 */
export const addInstructorSkillMutation = (
  options?: Partial<Options<AddInstructorSkillData>>
): UseMutationOptions<
  AddInstructorSkillResponse,
  AddInstructorSkillError,
  Options<AddInstructorSkillData>
> => {
  const mutationOptions: UseMutationOptions<
    AddInstructorSkillResponse,
    AddInstructorSkillError,
    Options<AddInstructorSkillData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await addInstructorSkill({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getInstructorMembershipsQueryKey = (options: Options<GetInstructorMembershipsData>) =>
  createQueryKey('getInstructorMemberships', options);

/**
 * Get instructor memberships
 * Retrieves all membership records for a specific instructor
 */
export const getInstructorMembershipsOptions = (options: Options<GetInstructorMembershipsData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getInstructorMemberships({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getInstructorMembershipsQueryKey(options),
  });
};

export const getInstructorMembershipsInfiniteQueryKey = (
  options: Options<GetInstructorMembershipsData>
): QueryKey<Options<GetInstructorMembershipsData>> =>
  createQueryKey('getInstructorMemberships', options, true);

/**
 * Get instructor memberships
 * Retrieves all membership records for a specific instructor
 */
export const getInstructorMembershipsInfiniteOptions = (
  options: Options<GetInstructorMembershipsData>
) => {
  return infiniteQueryOptions<
    GetInstructorMembershipsResponse,
    GetInstructorMembershipsError,
    InfiniteData<GetInstructorMembershipsResponse>,
    QueryKey<Options<GetInstructorMembershipsData>>,
    | number
    | Pick<
        QueryKey<Options<GetInstructorMembershipsData>>[0],
        'body' | 'headers' | 'path' | 'query'
      >
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<GetInstructorMembershipsData>>[0],
          'body' | 'headers' | 'path' | 'query'
        > =
          typeof pageParam === 'object'
            ? pageParam
            : {
                query: {
                  page: pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getInstructorMemberships({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: getInstructorMembershipsInfiniteQueryKey(options),
    }
  );
};

export const addInstructorMembershipQueryKey = (options: Options<AddInstructorMembershipData>) =>
  createQueryKey('addInstructorMembership', options);

/**
 * Add membership to instructor
 * Adds professional membership to an instructor
 */
export const addInstructorMembershipOptions = (options: Options<AddInstructorMembershipData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await addInstructorMembership({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: addInstructorMembershipQueryKey(options),
  });
};

/**
 * Add membership to instructor
 * Adds professional membership to an instructor
 */
export const addInstructorMembershipMutation = (
  options?: Partial<Options<AddInstructorMembershipData>>
): UseMutationOptions<
  AddInstructorMembershipResponse,
  AddInstructorMembershipError,
  Options<AddInstructorMembershipData>
> => {
  const mutationOptions: UseMutationOptions<
    AddInstructorMembershipResponse,
    AddInstructorMembershipError,
    Options<AddInstructorMembershipData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await addInstructorMembership({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getInstructorExperienceQueryKey = (options: Options<GetInstructorExperienceData>) =>
  createQueryKey('getInstructorExperience', options);

/**
 * Get instructor experience
 * Retrieves all experience records for a specific instructor
 */
export const getInstructorExperienceOptions = (options: Options<GetInstructorExperienceData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getInstructorExperience({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getInstructorExperienceQueryKey(options),
  });
};

export const getInstructorExperienceInfiniteQueryKey = (
  options: Options<GetInstructorExperienceData>
): QueryKey<Options<GetInstructorExperienceData>> =>
  createQueryKey('getInstructorExperience', options, true);

/**
 * Get instructor experience
 * Retrieves all experience records for a specific instructor
 */
export const getInstructorExperienceInfiniteOptions = (
  options: Options<GetInstructorExperienceData>
) => {
  return infiniteQueryOptions<
    GetInstructorExperienceResponse,
    GetInstructorExperienceError,
    InfiniteData<GetInstructorExperienceResponse>,
    QueryKey<Options<GetInstructorExperienceData>>,
    | number
    | Pick<QueryKey<Options<GetInstructorExperienceData>>[0], 'body' | 'headers' | 'path' | 'query'>
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<GetInstructorExperienceData>>[0],
          'body' | 'headers' | 'path' | 'query'
        > =
          typeof pageParam === 'object'
            ? pageParam
            : {
                query: {
                  page: pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getInstructorExperience({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: getInstructorExperienceInfiniteQueryKey(options),
    }
  );
};

export const addInstructorExperienceQueryKey = (options: Options<AddInstructorExperienceData>) =>
  createQueryKey('addInstructorExperience', options);

/**
 * Add experience to instructor
 * Adds work experience to an instructor
 */
export const addInstructorExperienceOptions = (options: Options<AddInstructorExperienceData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await addInstructorExperience({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: addInstructorExperienceQueryKey(options),
  });
};

/**
 * Add experience to instructor
 * Adds work experience to an instructor
 */
export const addInstructorExperienceMutation = (
  options?: Partial<Options<AddInstructorExperienceData>>
): UseMutationOptions<
  AddInstructorExperienceResponse,
  AddInstructorExperienceError,
  Options<AddInstructorExperienceData>
> => {
  const mutationOptions: UseMutationOptions<
    AddInstructorExperienceResponse,
    AddInstructorExperienceError,
    Options<AddInstructorExperienceData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await addInstructorExperience({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getInstructorEducationQueryKey = (options: Options<GetInstructorEducationData>) =>
  createQueryKey('getInstructorEducation', options);

/**
 * Get instructor education
 * Retrieves all education records for a specific instructor
 */
export const getInstructorEducationOptions = (options: Options<GetInstructorEducationData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getInstructorEducation({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getInstructorEducationQueryKey(options),
  });
};

export const addInstructorEducationQueryKey = (options: Options<AddInstructorEducationData>) =>
  createQueryKey('addInstructorEducation', options);

/**
 * Add education to instructor
 * Adds educational qualification to an instructor
 */
export const addInstructorEducationOptions = (options: Options<AddInstructorEducationData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await addInstructorEducation({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: addInstructorEducationQueryKey(options),
  });
};

/**
 * Add education to instructor
 * Adds educational qualification to an instructor
 */
export const addInstructorEducationMutation = (
  options?: Partial<Options<AddInstructorEducationData>>
): UseMutationOptions<
  AddInstructorEducationResponse,
  AddInstructorEducationError,
  Options<AddInstructorEducationData>
> => {
  const mutationOptions: UseMutationOptions<
    AddInstructorEducationResponse,
    AddInstructorEducationError,
    Options<AddInstructorEducationData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await addInstructorEducation({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getInstructorDocumentsQueryKey = (options: Options<GetInstructorDocumentsData>) =>
  createQueryKey('getInstructorDocuments', options);

/**
 * Get instructor documents
 * Retrieves all documents for a specific instructor
 */
export const getInstructorDocumentsOptions = (options: Options<GetInstructorDocumentsData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getInstructorDocuments({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getInstructorDocumentsQueryKey(options),
  });
};

export const addInstructorDocumentQueryKey = (options: Options<AddInstructorDocumentData>) =>
  createQueryKey('addInstructorDocument', options);

/**
 * Add document to instructor
 * Uploads and associates a document with an instructor
 */
export const addInstructorDocumentOptions = (options: Options<AddInstructorDocumentData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await addInstructorDocument({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: addInstructorDocumentQueryKey(options),
  });
};

/**
 * Add document to instructor
 * Uploads and associates a document with an instructor
 */
export const addInstructorDocumentMutation = (
  options?: Partial<Options<AddInstructorDocumentData>>
): UseMutationOptions<
  AddInstructorDocumentResponse,
  AddInstructorDocumentError,
  Options<AddInstructorDocumentData>
> => {
  const mutationOptions: UseMutationOptions<
    AddInstructorDocumentResponse,
    AddInstructorDocumentError,
    Options<AddInstructorDocumentData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await addInstructorDocument({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const verifyDocumentQueryKey = (options: Options<VerifyDocumentData>) =>
  createQueryKey('verifyDocument', options);

/**
 * Verify instructor document
 * Marks a document as verified
 */
export const verifyDocumentOptions = (options: Options<VerifyDocumentData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await verifyDocument({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: verifyDocumentQueryKey(options),
  });
};

/**
 * Verify instructor document
 * Marks a document as verified
 */
export const verifyDocumentMutation = (
  options?: Partial<Options<VerifyDocumentData>>
): UseMutationOptions<VerifyDocumentResponse, VerifyDocumentError, Options<VerifyDocumentData>> => {
  const mutationOptions: UseMutationOptions<
    VerifyDocumentResponse,
    VerifyDocumentError,
    Options<VerifyDocumentData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await verifyDocument({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getAllCoursesQueryKey = (options?: Options<GetAllCoursesData>) =>
  createQueryKey('getAllCourses', options);

/**
 * Get all courses
 * Retrieves paginated list of all courses with category information and filtering support.
 */
export const getAllCoursesOptions = (options?: Options<GetAllCoursesData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getAllCourses({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getAllCoursesQueryKey(options),
  });
};

export const getAllCoursesInfiniteQueryKey = (
  options?: Options<GetAllCoursesData>
): QueryKey<Options<GetAllCoursesData>> => createQueryKey('getAllCourses', options, true);

/**
 * Get all courses
 * Retrieves paginated list of all courses with category information and filtering support.
 */
export const getAllCoursesInfiniteOptions = (options?: Options<GetAllCoursesData>) => {
  return infiniteQueryOptions<
    GetAllCoursesResponse,
    GetAllCoursesError,
    InfiniteData<GetAllCoursesResponse>,
    QueryKey<Options<GetAllCoursesData>>,
    number | Pick<QueryKey<Options<GetAllCoursesData>>[0], 'body' | 'headers' | 'path' | 'query'>
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<GetAllCoursesData>>[0],
          'body' | 'headers' | 'path' | 'query'
        > =
          typeof pageParam === 'object'
            ? pageParam
            : {
                query: {
                  page: pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getAllCourses({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: getAllCoursesInfiniteQueryKey(options),
    }
  );
};

export const createCourseQueryKey = (options: Options<CreateCourseData>) =>
  createQueryKey('createCourse', options);

/**
 * Create a new course
 * Creates a new course with default DRAFT status and inactive state. Supports multiple categories.
 *
 * **Category Assignment:**
 * - Use `category_uuids` field to assign multiple categories to the course
 * - Categories are validated to ensure they exist before assignment
 * - A course can belong to multiple categories for better organization and discoverability
 *
 * **Example Request Body:**
 * ```json
 * {
 * "name": "Advanced Java Programming",
 * "instructor_uuid": "instructor-uuid-here",
 * "category_uuids": ["java-uuid", "programming-uuid"],
 * "description": "Comprehensive Java course",
 * "duration_hours": 40,
 * "duration_minutes": 0
 * }
 * ```
 *
 */
export const createCourseOptions = (options: Options<CreateCourseData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await createCourse({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: createCourseQueryKey(options),
  });
};

/**
 * Create a new course
 * Creates a new course with default DRAFT status and inactive state. Supports multiple categories.
 *
 * **Category Assignment:**
 * - Use `category_uuids` field to assign multiple categories to the course
 * - Categories are validated to ensure they exist before assignment
 * - A course can belong to multiple categories for better organization and discoverability
 *
 * **Example Request Body:**
 * ```json
 * {
 * "name": "Advanced Java Programming",
 * "instructor_uuid": "instructor-uuid-here",
 * "category_uuids": ["java-uuid", "programming-uuid"],
 * "description": "Comprehensive Java course",
 * "duration_hours": 40,
 * "duration_minutes": 0
 * }
 * ```
 *
 */
export const createCourseMutation = (
  options?: Partial<Options<CreateCourseData>>
): UseMutationOptions<CreateCourseResponse, CreateCourseError, Options<CreateCourseData>> => {
  const mutationOptions: UseMutationOptions<
    CreateCourseResponse,
    CreateCourseError,
    Options<CreateCourseData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await createCourse({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const unpublishCourseQueryKey = (options: Options<UnpublishCourseData>) =>
  createQueryKey('unpublishCourse', options);

/**
 * Unpublish course
 * Unpublishes a course, changing it from PUBLISHED to DRAFT status.
 *
 * **Smart Active Status Logic:**
 * - If NO active enrollments: Course becomes DRAFT and ACTIVE (available for new enrollments)
 * - If HAS active enrollments: Course becomes DRAFT and INACTIVE (existing students continue, no new enrollments)
 *
 * **Business Rules:**
 * - Course status always changes from PUBLISHED to DRAFT
 * - Active status depends on current enrollment situation
 * - Existing enrollments are never affected
 * - Course can be published again later
 *
 * **Use Cases:**
 * - Temporarily remove course from catalog while keeping it available
 * - Stop new enrollments while allowing current students to continue
 * - Prepare course for updates before republishing
 *
 */
export const unpublishCourseOptions = (options: Options<UnpublishCourseData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await unpublishCourse({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: unpublishCourseQueryKey(options),
  });
};

/**
 * Unpublish course
 * Unpublishes a course, changing it from PUBLISHED to DRAFT status.
 *
 * **Smart Active Status Logic:**
 * - If NO active enrollments: Course becomes DRAFT and ACTIVE (available for new enrollments)
 * - If HAS active enrollments: Course becomes DRAFT and INACTIVE (existing students continue, no new enrollments)
 *
 * **Business Rules:**
 * - Course status always changes from PUBLISHED to DRAFT
 * - Active status depends on current enrollment situation
 * - Existing enrollments are never affected
 * - Course can be published again later
 *
 * **Use Cases:**
 * - Temporarily remove course from catalog while keeping it available
 * - Stop new enrollments while allowing current students to continue
 * - Prepare course for updates before republishing
 *
 */
export const unpublishCourseMutation = (
  options?: Partial<Options<UnpublishCourseData>>
): UseMutationOptions<
  UnpublishCourseResponse,
  UnpublishCourseError,
  Options<UnpublishCourseData>
> => {
  const mutationOptions: UseMutationOptions<
    UnpublishCourseResponse,
    UnpublishCourseError,
    Options<UnpublishCourseData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await unpublishCourse({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const uploadCourseThumbnailQueryKey = (options: Options<UploadCourseThumbnailData>) =>
  createQueryKey('uploadCourseThumbnail', options);

/**
 * Upload course thumbnail
 * Uploads a thumbnail image for the specified course. The thumbnail is typically used in course
 * listings, search results, and course cards throughout the application.
 *
 * **File Requirements:**
 * - Supported formats: JPG, PNG, GIF, WebP
 * - Maximum file size: 5MB
 * - Recommended dimensions: 400x300 pixels or 4:3 aspect ratio
 * - Files will be automatically optimized for web delivery
 *
 * **Usage Guidelines:**
 * - Thumbnails should clearly represent the course content
 * - Use high-quality, professional images
 * - Avoid images with too much text or small details
 * - Consider accessibility and contrast for text overlays
 *
 * **Storage Details:**
 * - Files are stored in the course_thumbnails folder
 * - Previous thumbnail will be replaced if a new one is uploaded
 * - Generated URL will be automatically set in the course record
 *
 */
export const uploadCourseThumbnailOptions = (options: Options<UploadCourseThumbnailData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await uploadCourseThumbnail({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: uploadCourseThumbnailQueryKey(options),
  });
};

/**
 * Upload course thumbnail
 * Uploads a thumbnail image for the specified course. The thumbnail is typically used in course
 * listings, search results, and course cards throughout the application.
 *
 * **File Requirements:**
 * - Supported formats: JPG, PNG, GIF, WebP
 * - Maximum file size: 5MB
 * - Recommended dimensions: 400x300 pixels or 4:3 aspect ratio
 * - Files will be automatically optimized for web delivery
 *
 * **Usage Guidelines:**
 * - Thumbnails should clearly represent the course content
 * - Use high-quality, professional images
 * - Avoid images with too much text or small details
 * - Consider accessibility and contrast for text overlays
 *
 * **Storage Details:**
 * - Files are stored in the course_thumbnails folder
 * - Previous thumbnail will be replaced if a new one is uploaded
 * - Generated URL will be automatically set in the course record
 *
 */
export const uploadCourseThumbnailMutation = (
  options?: Partial<Options<UploadCourseThumbnailData>>
): UseMutationOptions<
  UploadCourseThumbnailResponse,
  UploadCourseThumbnailError,
  Options<UploadCourseThumbnailData>
> => {
  const mutationOptions: UseMutationOptions<
    UploadCourseThumbnailResponse,
    UploadCourseThumbnailError,
    Options<UploadCourseThumbnailData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await uploadCourseThumbnail({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const publishCourseQueryKey = (options: Options<PublishCourseData>) =>
  createQueryKey('publishCourse', options);

/**
 * Publish course
 * Publishes a course making it available for enrollment.
 */
export const publishCourseOptions = (options: Options<PublishCourseData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await publishCourse({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: publishCourseQueryKey(options),
  });
};

/**
 * Publish course
 * Publishes a course making it available for enrollment.
 */
export const publishCourseMutation = (
  options?: Partial<Options<PublishCourseData>>
): UseMutationOptions<PublishCourseResponse, PublishCourseError, Options<PublishCourseData>> => {
  const mutationOptions: UseMutationOptions<
    PublishCourseResponse,
    PublishCourseError,
    Options<PublishCourseData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await publishCourse({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const uploadCourseIntroVideoQueryKey = (options: Options<UploadCourseIntroVideoData>) =>
  createQueryKey('uploadCourseIntroVideo', options);

/**
 * Upload course introduction video
 * Uploads an introduction video for the specified course. The intro video is used for course
 * previews, marketing, and helping students understand what they'll learn.
 *
 * **File Requirements:**
 * - Supported formats: MP4, WebM, MOV, AVI
 * - Maximum file size: 100MB
 * - Recommended duration: 1-3 minutes
 * - Recommended resolution: 720p or 1080p
 *
 * **Content Guidelines:**
 * - Keep intro videos concise and engaging
 * - Clearly explain what students will learn
 * - Include instructor introduction if appropriate
 * - Ensure good audio quality
 * - Consider adding captions for accessibility
 *
 * **Storage Details:**
 * - Files are stored in the course_intro_videos folder
 * - Previous intro video will be replaced if a new one is uploaded
 * - Generated URL will be automatically set in the course record
 * - Consider video compression for optimal streaming performance
 *
 */
export const uploadCourseIntroVideoOptions = (options: Options<UploadCourseIntroVideoData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await uploadCourseIntroVideo({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: uploadCourseIntroVideoQueryKey(options),
  });
};

/**
 * Upload course introduction video
 * Uploads an introduction video for the specified course. The intro video is used for course
 * previews, marketing, and helping students understand what they'll learn.
 *
 * **File Requirements:**
 * - Supported formats: MP4, WebM, MOV, AVI
 * - Maximum file size: 100MB
 * - Recommended duration: 1-3 minutes
 * - Recommended resolution: 720p or 1080p
 *
 * **Content Guidelines:**
 * - Keep intro videos concise and engaging
 * - Clearly explain what students will learn
 * - Include instructor introduction if appropriate
 * - Ensure good audio quality
 * - Consider adding captions for accessibility
 *
 * **Storage Details:**
 * - Files are stored in the course_intro_videos folder
 * - Previous intro video will be replaced if a new one is uploaded
 * - Generated URL will be automatically set in the course record
 * - Consider video compression for optimal streaming performance
 *
 */
export const uploadCourseIntroVideoMutation = (
  options?: Partial<Options<UploadCourseIntroVideoData>>
): UseMutationOptions<
  UploadCourseIntroVideoResponse,
  UploadCourseIntroVideoError,
  Options<UploadCourseIntroVideoData>
> => {
  const mutationOptions: UseMutationOptions<
    UploadCourseIntroVideoResponse,
    UploadCourseIntroVideoError,
    Options<UploadCourseIntroVideoData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await uploadCourseIntroVideo({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const uploadCourseBannerQueryKey = (options: Options<UploadCourseBannerData>) =>
  createQueryKey('uploadCourseBanner', options);

/**
 * Upload course banner
 * Uploads a banner image for the specified course. The banner is typically used on the course
 * detail page as a hero image and in promotional materials.
 *
 * **File Requirements:**
 * - Supported formats: JPG, PNG, GIF, WebP
 * - Maximum file size: 10MB
 * - Recommended dimensions: 1200x400 pixels or 3:1 aspect ratio
 * - Files will be automatically optimized for web delivery
 *
 * **Usage Guidelines:**
 * - Banners should be visually striking and professional
 * - Consider responsive design - banner should work on mobile and desktop
 * - Use images that complement your course branding
 * - Ensure good contrast if overlaying text
 *
 * **Storage Details:**
 * - Files are stored in the course_banners folder
 * - Previous banner will be replaced if a new one is uploaded
 * - Generated URL will be automatically set in the course record
 *
 */
export const uploadCourseBannerOptions = (options: Options<UploadCourseBannerData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await uploadCourseBanner({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: uploadCourseBannerQueryKey(options),
  });
};

/**
 * Upload course banner
 * Uploads a banner image for the specified course. The banner is typically used on the course
 * detail page as a hero image and in promotional materials.
 *
 * **File Requirements:**
 * - Supported formats: JPG, PNG, GIF, WebP
 * - Maximum file size: 10MB
 * - Recommended dimensions: 1200x400 pixels or 3:1 aspect ratio
 * - Files will be automatically optimized for web delivery
 *
 * **Usage Guidelines:**
 * - Banners should be visually striking and professional
 * - Consider responsive design - banner should work on mobile and desktop
 * - Use images that complement your course branding
 * - Ensure good contrast if overlaying text
 *
 * **Storage Details:**
 * - Files are stored in the course_banners folder
 * - Previous banner will be replaced if a new one is uploaded
 * - Generated URL will be automatically set in the course record
 *
 */
export const uploadCourseBannerMutation = (
  options?: Partial<Options<UploadCourseBannerData>>
): UseMutationOptions<
  UploadCourseBannerResponse,
  UploadCourseBannerError,
  Options<UploadCourseBannerData>
> => {
  const mutationOptions: UseMutationOptions<
    UploadCourseBannerResponse,
    UploadCourseBannerError,
    Options<UploadCourseBannerData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await uploadCourseBanner({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const archiveCourseQueryKey = (options: Options<ArchiveCourseData>) =>
  createQueryKey('archiveCourse', options);

/**
 * Archive course
 * Archives a course, making it completely unavailable.
 *
 * **Important:**
 * - This is typically a permanent action
 * - Course becomes completely inaccessible to new students
 * - Existing enrollments may be handled differently based on business rules
 * - Course data is preserved for historical/audit purposes
 *
 */
export const archiveCourseOptions = (options: Options<ArchiveCourseData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await archiveCourse({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: archiveCourseQueryKey(options),
  });
};

/**
 * Archive course
 * Archives a course, making it completely unavailable.
 *
 * **Important:**
 * - This is typically a permanent action
 * - Course becomes completely inaccessible to new students
 * - Existing enrollments may be handled differently based on business rules
 * - Course data is preserved for historical/audit purposes
 *
 */
export const archiveCourseMutation = (
  options?: Partial<Options<ArchiveCourseData>>
): UseMutationOptions<ArchiveCourseResponse, ArchiveCourseError, Options<ArchiveCourseData>> => {
  const mutationOptions: UseMutationOptions<
    ArchiveCourseResponse,
    ArchiveCourseError,
    Options<ArchiveCourseData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await archiveCourse({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getCourseRequirementsQueryKey = (options: Options<GetCourseRequirementsData>) =>
  createQueryKey('getCourseRequirements', options);

/**
 * Get course requirements
 * Retrieves all requirements for a specific course.
 */
export const getCourseRequirementsOptions = (options: Options<GetCourseRequirementsData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getCourseRequirements({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getCourseRequirementsQueryKey(options),
  });
};

export const getCourseRequirementsInfiniteQueryKey = (
  options: Options<GetCourseRequirementsData>
): QueryKey<Options<GetCourseRequirementsData>> =>
  createQueryKey('getCourseRequirements', options, true);

/**
 * Get course requirements
 * Retrieves all requirements for a specific course.
 */
export const getCourseRequirementsInfiniteOptions = (
  options: Options<GetCourseRequirementsData>
) => {
  return infiniteQueryOptions<
    GetCourseRequirementsResponse,
    GetCourseRequirementsError,
    InfiniteData<GetCourseRequirementsResponse>,
    QueryKey<Options<GetCourseRequirementsData>>,
    | number
    | Pick<QueryKey<Options<GetCourseRequirementsData>>[0], 'body' | 'headers' | 'path' | 'query'>
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<GetCourseRequirementsData>>[0],
          'body' | 'headers' | 'path' | 'query'
        > =
          typeof pageParam === 'object'
            ? pageParam
            : {
                query: {
                  page: pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getCourseRequirements({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: getCourseRequirementsInfiniteQueryKey(options),
    }
  );
};

export const addCourseRequirementQueryKey = (options: Options<AddCourseRequirementData>) =>
  createQueryKey('addCourseRequirement', options);

/**
 * Add requirement to course
 * Adds a new requirement or prerequisite to a course.
 */
export const addCourseRequirementOptions = (options: Options<AddCourseRequirementData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await addCourseRequirement({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: addCourseRequirementQueryKey(options),
  });
};

/**
 * Add requirement to course
 * Adds a new requirement or prerequisite to a course.
 */
export const addCourseRequirementMutation = (
  options?: Partial<Options<AddCourseRequirementData>>
): UseMutationOptions<
  AddCourseRequirementResponse,
  AddCourseRequirementError,
  Options<AddCourseRequirementData>
> => {
  const mutationOptions: UseMutationOptions<
    AddCourseRequirementResponse,
    AddCourseRequirementError,
    Options<AddCourseRequirementData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await addCourseRequirement({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getCourseLessonsQueryKey = (options: Options<GetCourseLessonsData>) =>
  createQueryKey('getCourseLessons', options);

/**
 * Get course lessons
 * Retrieves all lessons for a specific course in sequence order.
 */
export const getCourseLessonsOptions = (options: Options<GetCourseLessonsData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getCourseLessons({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getCourseLessonsQueryKey(options),
  });
};

export const getCourseLessonsInfiniteQueryKey = (
  options: Options<GetCourseLessonsData>
): QueryKey<Options<GetCourseLessonsData>> => createQueryKey('getCourseLessons', options, true);

/**
 * Get course lessons
 * Retrieves all lessons for a specific course in sequence order.
 */
export const getCourseLessonsInfiniteOptions = (options: Options<GetCourseLessonsData>) => {
  return infiniteQueryOptions<
    GetCourseLessonsResponse,
    GetCourseLessonsError,
    InfiniteData<GetCourseLessonsResponse>,
    QueryKey<Options<GetCourseLessonsData>>,
    number | Pick<QueryKey<Options<GetCourseLessonsData>>[0], 'body' | 'headers' | 'path' | 'query'>
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<GetCourseLessonsData>>[0],
          'body' | 'headers' | 'path' | 'query'
        > =
          typeof pageParam === 'object'
            ? pageParam
            : {
                query: {
                  page: pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getCourseLessons({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: getCourseLessonsInfiniteQueryKey(options),
    }
  );
};

export const addCourseLessonQueryKey = (options: Options<AddCourseLessonData>) =>
  createQueryKey('addCourseLesson', options);

/**
 * Add lesson to course
 * Creates a new lesson associated with the specified course.
 */
export const addCourseLessonOptions = (options: Options<AddCourseLessonData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await addCourseLesson({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: addCourseLessonQueryKey(options),
  });
};

/**
 * Add lesson to course
 * Creates a new lesson associated with the specified course.
 */
export const addCourseLessonMutation = (
  options?: Partial<Options<AddCourseLessonData>>
): UseMutationOptions<
  AddCourseLessonResponse,
  AddCourseLessonError,
  Options<AddCourseLessonData>
> => {
  const mutationOptions: UseMutationOptions<
    AddCourseLessonResponse,
    AddCourseLessonError,
    Options<AddCourseLessonData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await addCourseLesson({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getLessonContentQueryKey = (options: Options<GetLessonContentData>) =>
  createQueryKey('getLessonContent', options);

/**
 * Get lesson content
 * Retrieves all content for a lesson in display order with computed properties.
 */
export const getLessonContentOptions = (options: Options<GetLessonContentData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getLessonContent({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getLessonContentQueryKey(options),
  });
};

export const addLessonContentQueryKey = (options: Options<AddLessonContentData>) =>
  createQueryKey('addLessonContent', options);

/**
 * Add content to lesson
 * Adds new content item to a specific lesson with automatic ordering.
 */
export const addLessonContentOptions = (options: Options<AddLessonContentData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await addLessonContent({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: addLessonContentQueryKey(options),
  });
};

/**
 * Add content to lesson
 * Adds new content item to a specific lesson with automatic ordering.
 */
export const addLessonContentMutation = (
  options?: Partial<Options<AddLessonContentData>>
): UseMutationOptions<
  AddLessonContentResponse,
  AddLessonContentError,
  Options<AddLessonContentData>
> => {
  const mutationOptions: UseMutationOptions<
    AddLessonContentResponse,
    AddLessonContentError,
    Options<AddLessonContentData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await addLessonContent({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const reorderLessonContentQueryKey = (options: Options<ReorderLessonContentData>) =>
  createQueryKey('reorderLessonContent', options);

/**
 * Reorder lesson content
 * Updates the display order of content items within a lesson.
 */
export const reorderLessonContentOptions = (options: Options<ReorderLessonContentData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await reorderLessonContent({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: reorderLessonContentQueryKey(options),
  });
};

/**
 * Reorder lesson content
 * Updates the display order of content items within a lesson.
 */
export const reorderLessonContentMutation = (
  options?: Partial<Options<ReorderLessonContentData>>
): UseMutationOptions<
  ReorderLessonContentResponse,
  ReorderLessonContentError,
  Options<ReorderLessonContentData>
> => {
  const mutationOptions: UseMutationOptions<
    ReorderLessonContentResponse,
    ReorderLessonContentError,
    Options<ReorderLessonContentData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await reorderLessonContent({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getCourseAssessmentsQueryKey = (options: Options<GetCourseAssessmentsData>) =>
  createQueryKey('getCourseAssessments', options);

/**
 * Get course assessments
 * Retrieves all assessments for a specific course.
 */
export const getCourseAssessmentsOptions = (options: Options<GetCourseAssessmentsData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getCourseAssessments({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getCourseAssessmentsQueryKey(options),
  });
};

export const getCourseAssessmentsInfiniteQueryKey = (
  options: Options<GetCourseAssessmentsData>
): QueryKey<Options<GetCourseAssessmentsData>> =>
  createQueryKey('getCourseAssessments', options, true);

/**
 * Get course assessments
 * Retrieves all assessments for a specific course.
 */
export const getCourseAssessmentsInfiniteOptions = (options: Options<GetCourseAssessmentsData>) => {
  return infiniteQueryOptions<
    GetCourseAssessmentsResponse,
    GetCourseAssessmentsError,
    InfiniteData<GetCourseAssessmentsResponse>,
    QueryKey<Options<GetCourseAssessmentsData>>,
    | number
    | Pick<QueryKey<Options<GetCourseAssessmentsData>>[0], 'body' | 'headers' | 'path' | 'query'>
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<GetCourseAssessmentsData>>[0],
          'body' | 'headers' | 'path' | 'query'
        > =
          typeof pageParam === 'object'
            ? pageParam
            : {
                query: {
                  page: pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getCourseAssessments({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: getCourseAssessmentsInfiniteQueryKey(options),
    }
  );
};

export const addCourseAssessmentQueryKey = (options: Options<AddCourseAssessmentData>) =>
  createQueryKey('addCourseAssessment', options);

/**
 * Add assessment to course
 * Creates a new assessment for the course with optional rubric association.
 */
export const addCourseAssessmentOptions = (options: Options<AddCourseAssessmentData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await addCourseAssessment({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: addCourseAssessmentQueryKey(options),
  });
};

/**
 * Add assessment to course
 * Creates a new assessment for the course with optional rubric association.
 */
export const addCourseAssessmentMutation = (
  options?: Partial<Options<AddCourseAssessmentData>>
): UseMutationOptions<
  AddCourseAssessmentResponse,
  AddCourseAssessmentError,
  Options<AddCourseAssessmentData>
> => {
  const mutationOptions: UseMutationOptions<
    AddCourseAssessmentResponse,
    AddCourseAssessmentError,
    Options<AddCourseAssessmentData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await addCourseAssessment({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getAllGradingLevelsQueryKey = (options?: Options<GetAllGradingLevelsData>) =>
  createQueryKey('getAllGradingLevels', options);

/**
 * Get all grading levels
 * Retrieves paginated list of all grading levels.
 */
export const getAllGradingLevelsOptions = (options?: Options<GetAllGradingLevelsData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getAllGradingLevels({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getAllGradingLevelsQueryKey(options),
  });
};

export const getAllGradingLevelsInfiniteQueryKey = (
  options?: Options<GetAllGradingLevelsData>
): QueryKey<Options<GetAllGradingLevelsData>> =>
  createQueryKey('getAllGradingLevels', options, true);

/**
 * Get all grading levels
 * Retrieves paginated list of all grading levels.
 */
export const getAllGradingLevelsInfiniteOptions = (options?: Options<GetAllGradingLevelsData>) => {
  return infiniteQueryOptions<
    GetAllGradingLevelsResponse,
    GetAllGradingLevelsError,
    InfiniteData<GetAllGradingLevelsResponse>,
    QueryKey<Options<GetAllGradingLevelsData>>,
    | number
    | Pick<QueryKey<Options<GetAllGradingLevelsData>>[0], 'body' | 'headers' | 'path' | 'query'>
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<GetAllGradingLevelsData>>[0],
          'body' | 'headers' | 'path' | 'query'
        > =
          typeof pageParam === 'object'
            ? pageParam
            : {
                query: {
                  page: pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getAllGradingLevels({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: getAllGradingLevelsInfiniteQueryKey(options),
    }
  );
};

export const createGradingLevelQueryKey = (options: Options<CreateGradingLevelData>) =>
  createQueryKey('createGradingLevel', options);

/**
 * Create grading level
 * Creates a new grading level for assessment scoring.
 */
export const createGradingLevelOptions = (options: Options<CreateGradingLevelData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await createGradingLevel({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: createGradingLevelQueryKey(options),
  });
};

/**
 * Create grading level
 * Creates a new grading level for assessment scoring.
 */
export const createGradingLevelMutation = (
  options?: Partial<Options<CreateGradingLevelData>>
): UseMutationOptions<
  CreateGradingLevelResponse,
  CreateGradingLevelError,
  Options<CreateGradingLevelData>
> => {
  const mutationOptions: UseMutationOptions<
    CreateGradingLevelResponse,
    CreateGradingLevelError,
    Options<CreateGradingLevelData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await createGradingLevel({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getAllDifficultyLevelsQueryKey = (options?: Options<GetAllDifficultyLevelsData>) =>
  createQueryKey('getAllDifficultyLevels', options);

/**
 * Get all difficulty levels
 * Retrieves all difficulty levels in order.
 */
export const getAllDifficultyLevelsOptions = (options?: Options<GetAllDifficultyLevelsData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getAllDifficultyLevels({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getAllDifficultyLevelsQueryKey(options),
  });
};

export const createDifficultyLevelQueryKey = (options: Options<CreateDifficultyLevelData>) =>
  createQueryKey('createDifficultyLevel', options);

/**
 * Create difficulty level
 * Creates a new difficulty level for course classification.
 */
export const createDifficultyLevelOptions = (options: Options<CreateDifficultyLevelData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await createDifficultyLevel({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: createDifficultyLevelQueryKey(options),
  });
};

/**
 * Create difficulty level
 * Creates a new difficulty level for course classification.
 */
export const createDifficultyLevelMutation = (
  options?: Partial<Options<CreateDifficultyLevelData>>
): UseMutationOptions<
  CreateDifficultyLevelResponse,
  CreateDifficultyLevelError,
  Options<CreateDifficultyLevelData>
> => {
  const mutationOptions: UseMutationOptions<
    CreateDifficultyLevelResponse,
    CreateDifficultyLevelError,
    Options<CreateDifficultyLevelData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await createDifficultyLevel({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const reorderDifficultyLevelsQueryKey = (options: Options<ReorderDifficultyLevelsData>) =>
  createQueryKey('reorderDifficultyLevels', options);

/**
 * Reorder difficulty levels
 * Updates the order of difficulty levels.
 */
export const reorderDifficultyLevelsOptions = (options: Options<ReorderDifficultyLevelsData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await reorderDifficultyLevels({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: reorderDifficultyLevelsQueryKey(options),
  });
};

/**
 * Reorder difficulty levels
 * Updates the order of difficulty levels.
 */
export const reorderDifficultyLevelsMutation = (
  options?: Partial<Options<ReorderDifficultyLevelsData>>
): UseMutationOptions<
  ReorderDifficultyLevelsResponse,
  ReorderDifficultyLevelsError,
  Options<ReorderDifficultyLevelsData>
> => {
  const mutationOptions: UseMutationOptions<
    ReorderDifficultyLevelsResponse,
    ReorderDifficultyLevelsError,
    Options<ReorderDifficultyLevelsData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await reorderDifficultyLevels({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getAllContentTypesQueryKey = (options?: Options<GetAllContentTypesData>) =>
  createQueryKey('getAllContentTypes', options);

/**
 * Get all content types
 * Retrieves paginated list of all content types.
 */
export const getAllContentTypesOptions = (options?: Options<GetAllContentTypesData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getAllContentTypes({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getAllContentTypesQueryKey(options),
  });
};

export const getAllContentTypesInfiniteQueryKey = (
  options?: Options<GetAllContentTypesData>
): QueryKey<Options<GetAllContentTypesData>> => createQueryKey('getAllContentTypes', options, true);

/**
 * Get all content types
 * Retrieves paginated list of all content types.
 */
export const getAllContentTypesInfiniteOptions = (options?: Options<GetAllContentTypesData>) => {
  return infiniteQueryOptions<
    GetAllContentTypesResponse,
    GetAllContentTypesError,
    InfiniteData<GetAllContentTypesResponse>,
    QueryKey<Options<GetAllContentTypesData>>,
    | number
    | Pick<QueryKey<Options<GetAllContentTypesData>>[0], 'body' | 'headers' | 'path' | 'query'>
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<GetAllContentTypesData>>[0],
          'body' | 'headers' | 'path' | 'query'
        > =
          typeof pageParam === 'object'
            ? pageParam
            : {
                query: {
                  page: pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getAllContentTypes({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: getAllContentTypesInfiniteQueryKey(options),
    }
  );
};

export const createContentTypeQueryKey = (options: Options<CreateContentTypeData>) =>
  createQueryKey('createContentType', options);

/**
 * Create content type
 * Creates a new content type for lesson content classification.
 */
export const createContentTypeOptions = (options: Options<CreateContentTypeData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await createContentType({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: createContentTypeQueryKey(options),
  });
};

/**
 * Create content type
 * Creates a new content type for lesson content classification.
 */
export const createContentTypeMutation = (
  options?: Partial<Options<CreateContentTypeData>>
): UseMutationOptions<
  CreateContentTypeResponse,
  CreateContentTypeError,
  Options<CreateContentTypeData>
> => {
  const mutationOptions: UseMutationOptions<
    CreateContentTypeResponse,
    CreateContentTypeError,
    Options<CreateContentTypeData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await createContentType({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getAllCategoriesQueryKey = (options?: Options<GetAllCategoriesData>) =>
  createQueryKey('getAllCategories', options);

/**
 * Get all categories
 * Retrieves paginated list of all categories.
 */
export const getAllCategoriesOptions = (options?: Options<GetAllCategoriesData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getAllCategories({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getAllCategoriesQueryKey(options),
  });
};

export const getAllCategoriesInfiniteQueryKey = (
  options?: Options<GetAllCategoriesData>
): QueryKey<Options<GetAllCategoriesData>> => createQueryKey('getAllCategories', options, true);

/**
 * Get all categories
 * Retrieves paginated list of all categories.
 */
export const getAllCategoriesInfiniteOptions = (options?: Options<GetAllCategoriesData>) => {
  return infiniteQueryOptions<
    GetAllCategoriesResponse,
    GetAllCategoriesError,
    InfiniteData<GetAllCategoriesResponse>,
    QueryKey<Options<GetAllCategoriesData>>,
    number | Pick<QueryKey<Options<GetAllCategoriesData>>[0], 'body' | 'headers' | 'path' | 'query'>
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<GetAllCategoriesData>>[0],
          'body' | 'headers' | 'path' | 'query'
        > =
          typeof pageParam === 'object'
            ? pageParam
            : {
                query: {
                  page: pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getAllCategories({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: getAllCategoriesInfiniteQueryKey(options),
    }
  );
};

export const createCategoryQueryKey = (options: Options<CreateCategoryData>) =>
  createQueryKey('createCategory', options);

/**
 * Create category
 * Creates a new category for organizing courses and programs.
 */
export const createCategoryOptions = (options: Options<CreateCategoryData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await createCategory({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: createCategoryQueryKey(options),
  });
};

/**
 * Create category
 * Creates a new category for organizing courses and programs.
 */
export const createCategoryMutation = (
  options?: Partial<Options<CreateCategoryData>>
): UseMutationOptions<CreateCategoryResponse, CreateCategoryError, Options<CreateCategoryData>> => {
  const mutationOptions: UseMutationOptions<
    CreateCategoryResponse,
    CreateCategoryError,
    Options<CreateCategoryData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await createCategory({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getAllCertificatesQueryKey = (options?: Options<GetAllCertificatesData>) =>
  createQueryKey('getAllCertificates', options);

/**
 * Get all certificates
 * Retrieves paginated list of all certificates with filtering support.
 */
export const getAllCertificatesOptions = (options?: Options<GetAllCertificatesData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getAllCertificates({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getAllCertificatesQueryKey(options),
  });
};

export const getAllCertificatesInfiniteQueryKey = (
  options?: Options<GetAllCertificatesData>
): QueryKey<Options<GetAllCertificatesData>> => createQueryKey('getAllCertificates', options, true);

/**
 * Get all certificates
 * Retrieves paginated list of all certificates with filtering support.
 */
export const getAllCertificatesInfiniteOptions = (options?: Options<GetAllCertificatesData>) => {
  return infiniteQueryOptions<
    GetAllCertificatesResponse,
    GetAllCertificatesError,
    InfiniteData<GetAllCertificatesResponse>,
    QueryKey<Options<GetAllCertificatesData>>,
    | number
    | Pick<QueryKey<Options<GetAllCertificatesData>>[0], 'body' | 'headers' | 'path' | 'query'>
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<GetAllCertificatesData>>[0],
          'body' | 'headers' | 'path' | 'query'
        > =
          typeof pageParam === 'object'
            ? pageParam
            : {
                query: {
                  page: pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getAllCertificates({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: getAllCertificatesInfiniteQueryKey(options),
    }
  );
};

export const createCertificateQueryKey = (options: Options<CreateCertificateData>) =>
  createQueryKey('createCertificate', options);

/**
 * Create a new certificate
 * Manually creates a certificate record with automatic number generation.
 */
export const createCertificateOptions = (options: Options<CreateCertificateData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await createCertificate({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: createCertificateQueryKey(options),
  });
};

/**
 * Create a new certificate
 * Manually creates a certificate record with automatic number generation.
 */
export const createCertificateMutation = (
  options?: Partial<Options<CreateCertificateData>>
): UseMutationOptions<
  CreateCertificateResponse,
  CreateCertificateError,
  Options<CreateCertificateData>
> => {
  const mutationOptions: UseMutationOptions<
    CreateCertificateResponse,
    CreateCertificateError,
    Options<CreateCertificateData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await createCertificate({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const revokeCertificateQueryKey = (options: Options<RevokeCertificateData>) =>
  createQueryKey('revokeCertificate', options);

/**
 * Revoke certificate
 * Revokes a certificate with reason, making it invalid.
 */
export const revokeCertificateOptions = (options: Options<RevokeCertificateData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await revokeCertificate({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: revokeCertificateQueryKey(options),
  });
};

/**
 * Revoke certificate
 * Revokes a certificate with reason, making it invalid.
 */
export const revokeCertificateMutation = (
  options?: Partial<Options<RevokeCertificateData>>
): UseMutationOptions<
  RevokeCertificateResponse,
  RevokeCertificateError,
  Options<RevokeCertificateData>
> => {
  const mutationOptions: UseMutationOptions<
    RevokeCertificateResponse,
    RevokeCertificateError,
    Options<RevokeCertificateData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await revokeCertificate({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const generateCertificateUrlQueryKey = (options: Options<GenerateCertificateUrlData>) =>
  createQueryKey('generateCertificateUrl', options);

/**
 * Generate certificate URL
 * Generates and updates the downloadable URL for a certificate.
 */
export const generateCertificateUrlOptions = (options: Options<GenerateCertificateUrlData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await generateCertificateUrl({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: generateCertificateUrlQueryKey(options),
  });
};

/**
 * Generate certificate URL
 * Generates and updates the downloadable URL for a certificate.
 */
export const generateCertificateUrlMutation = (
  options?: Partial<Options<GenerateCertificateUrlData>>
): UseMutationOptions<
  GenerateCertificateUrlResponse,
  GenerateCertificateUrlError,
  Options<GenerateCertificateUrlData>
> => {
  const mutationOptions: UseMutationOptions<
    GenerateCertificateUrlResponse,
    GenerateCertificateUrlError,
    Options<GenerateCertificateUrlData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await generateCertificateUrl({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getCertificateTemplatesQueryKey = (options?: Options<GetCertificateTemplatesData>) =>
  createQueryKey('getCertificateTemplates', options);

/**
 * Get certificate templates
 * Retrieves all available certificate templates.
 */
export const getCertificateTemplatesOptions = (options?: Options<GetCertificateTemplatesData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getCertificateTemplates({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getCertificateTemplatesQueryKey(options),
  });
};

export const getCertificateTemplatesInfiniteQueryKey = (
  options?: Options<GetCertificateTemplatesData>
): QueryKey<Options<GetCertificateTemplatesData>> =>
  createQueryKey('getCertificateTemplates', options, true);

/**
 * Get certificate templates
 * Retrieves all available certificate templates.
 */
export const getCertificateTemplatesInfiniteOptions = (
  options?: Options<GetCertificateTemplatesData>
) => {
  return infiniteQueryOptions<
    GetCertificateTemplatesResponse,
    GetCertificateTemplatesError,
    InfiniteData<GetCertificateTemplatesResponse>,
    QueryKey<Options<GetCertificateTemplatesData>>,
    | number
    | Pick<QueryKey<Options<GetCertificateTemplatesData>>[0], 'body' | 'headers' | 'path' | 'query'>
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<GetCertificateTemplatesData>>[0],
          'body' | 'headers' | 'path' | 'query'
        > =
          typeof pageParam === 'object'
            ? pageParam
            : {
                query: {
                  page: pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getCertificateTemplates({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: getCertificateTemplatesInfiniteQueryKey(options),
    }
  );
};

export const createCertificateTemplateQueryKey = (
  options: Options<CreateCertificateTemplateData>
) => createQueryKey('createCertificateTemplate', options);

/**
 * Create certificate template
 * Creates a new certificate template for generating certificates.
 */
export const createCertificateTemplateOptions = (
  options: Options<CreateCertificateTemplateData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await createCertificateTemplate({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: createCertificateTemplateQueryKey(options),
  });
};

/**
 * Create certificate template
 * Creates a new certificate template for generating certificates.
 */
export const createCertificateTemplateMutation = (
  options?: Partial<Options<CreateCertificateTemplateData>>
): UseMutationOptions<
  CreateCertificateTemplateResponse,
  CreateCertificateTemplateError,
  Options<CreateCertificateTemplateData>
> => {
  const mutationOptions: UseMutationOptions<
    CreateCertificateTemplateResponse,
    CreateCertificateTemplateError,
    Options<CreateCertificateTemplateData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await createCertificateTemplate({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const generateProgramCertificateQueryKey = (
  options: Options<GenerateProgramCertificateData>
) => createQueryKey('generateProgramCertificate', options);

/**
 * Generate program certificate
 * Automatically generates a certificate upon program completion.
 */
export const generateProgramCertificateOptions = (
  options: Options<GenerateProgramCertificateData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await generateProgramCertificate({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: generateProgramCertificateQueryKey(options),
  });
};

/**
 * Generate program certificate
 * Automatically generates a certificate upon program completion.
 */
export const generateProgramCertificateMutation = (
  options?: Partial<Options<GenerateProgramCertificateData>>
): UseMutationOptions<
  GenerateProgramCertificateResponse,
  GenerateProgramCertificateError,
  Options<GenerateProgramCertificateData>
> => {
  const mutationOptions: UseMutationOptions<
    GenerateProgramCertificateResponse,
    GenerateProgramCertificateError,
    Options<GenerateProgramCertificateData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await generateProgramCertificate({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const generateCourseCertificateQueryKey = (
  options: Options<GenerateCourseCertificateData>
) => createQueryKey('generateCourseCertificate', options);

/**
 * Generate course certificate
 * Automatically generates a certificate upon course completion.
 */
export const generateCourseCertificateOptions = (
  options: Options<GenerateCourseCertificateData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await generateCourseCertificate({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: generateCourseCertificateQueryKey(options),
  });
};

/**
 * Generate course certificate
 * Automatically generates a certificate upon course completion.
 */
export const generateCourseCertificateMutation = (
  options?: Partial<Options<GenerateCourseCertificateData>>
): UseMutationOptions<
  GenerateCourseCertificateResponse,
  GenerateCourseCertificateError,
  Options<GenerateCourseCertificateData>
> => {
  const mutationOptions: UseMutationOptions<
    GenerateCourseCertificateResponse,
    GenerateCourseCertificateError,
    Options<GenerateCourseCertificateData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await generateCourseCertificate({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getAllAssignmentsQueryKey = (options?: Options<GetAllAssignmentsData>) =>
  createQueryKey('getAllAssignments', options);

/**
 * Get all assignments
 * Retrieves paginated list of all assignments with filtering support.
 */
export const getAllAssignmentsOptions = (options?: Options<GetAllAssignmentsData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getAllAssignments({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getAllAssignmentsQueryKey(options),
  });
};

export const getAllAssignmentsInfiniteQueryKey = (
  options?: Options<GetAllAssignmentsData>
): QueryKey<Options<GetAllAssignmentsData>> => createQueryKey('getAllAssignments', options, true);

/**
 * Get all assignments
 * Retrieves paginated list of all assignments with filtering support.
 */
export const getAllAssignmentsInfiniteOptions = (options?: Options<GetAllAssignmentsData>) => {
  return infiniteQueryOptions<
    GetAllAssignmentsResponse,
    GetAllAssignmentsError,
    InfiniteData<GetAllAssignmentsResponse>,
    QueryKey<Options<GetAllAssignmentsData>>,
    | number
    | Pick<QueryKey<Options<GetAllAssignmentsData>>[0], 'body' | 'headers' | 'path' | 'query'>
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<GetAllAssignmentsData>>[0],
          'body' | 'headers' | 'path' | 'query'
        > =
          typeof pageParam === 'object'
            ? pageParam
            : {
                query: {
                  page: pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getAllAssignments({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: getAllAssignmentsInfiniteQueryKey(options),
    }
  );
};

export const createAssignmentQueryKey = (options: Options<CreateAssignmentData>) =>
  createQueryKey('createAssignment', options);

/**
 * Create a new assignment
 * Creates a new assignment with default DRAFT status and inactive state.
 */
export const createAssignmentOptions = (options: Options<CreateAssignmentData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await createAssignment({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: createAssignmentQueryKey(options),
  });
};

/**
 * Create a new assignment
 * Creates a new assignment with default DRAFT status and inactive state.
 */
export const createAssignmentMutation = (
  options?: Partial<Options<CreateAssignmentData>>
): UseMutationOptions<
  CreateAssignmentResponse,
  CreateAssignmentError,
  Options<CreateAssignmentData>
> => {
  const mutationOptions: UseMutationOptions<
    CreateAssignmentResponse,
    CreateAssignmentError,
    Options<CreateAssignmentData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await createAssignment({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const submitAssignmentQueryKey = (options: Options<SubmitAssignmentData>) =>
  createQueryKey('submitAssignment', options);

/**
 * Submit assignment
 * Creates a new submission for an assignment by a student.
 */
export const submitAssignmentOptions = (options: Options<SubmitAssignmentData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await submitAssignment({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: submitAssignmentQueryKey(options),
  });
};

/**
 * Submit assignment
 * Creates a new submission for an assignment by a student.
 */
export const submitAssignmentMutation = (
  options?: Partial<Options<SubmitAssignmentData>>
): UseMutationOptions<
  SubmitAssignmentResponse,
  SubmitAssignmentError,
  Options<SubmitAssignmentData>
> => {
  const mutationOptions: UseMutationOptions<
    SubmitAssignmentResponse,
    SubmitAssignmentError,
    Options<SubmitAssignmentData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await submitAssignment({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const returnSubmissionQueryKey = (options: Options<ReturnSubmissionData>) =>
  createQueryKey('returnSubmission', options);

/**
 * Return submission for revision
 * Returns a submission to student with feedback for revision.
 */
export const returnSubmissionOptions = (options: Options<ReturnSubmissionData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await returnSubmission({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: returnSubmissionQueryKey(options),
  });
};

/**
 * Return submission for revision
 * Returns a submission to student with feedback for revision.
 */
export const returnSubmissionMutation = (
  options?: Partial<Options<ReturnSubmissionData>>
): UseMutationOptions<
  ReturnSubmissionResponse,
  ReturnSubmissionError,
  Options<ReturnSubmissionData>
> => {
  const mutationOptions: UseMutationOptions<
    ReturnSubmissionResponse,
    ReturnSubmissionError,
    Options<ReturnSubmissionData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await returnSubmission({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const gradeSubmissionQueryKey = (options: Options<GradeSubmissionData>) =>
  createQueryKey('gradeSubmission', options);

/**
 * Grade submission
 * Grades a student's assignment submission with score and comments.
 */
export const gradeSubmissionOptions = (options: Options<GradeSubmissionData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await gradeSubmission({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: gradeSubmissionQueryKey(options),
  });
};

/**
 * Grade submission
 * Grades a student's assignment submission with score and comments.
 */
export const gradeSubmissionMutation = (
  options?: Partial<Options<GradeSubmissionData>>
): UseMutationOptions<
  GradeSubmissionResponse,
  GradeSubmissionError,
  Options<GradeSubmissionData>
> => {
  const mutationOptions: UseMutationOptions<
    GradeSubmissionResponse,
    GradeSubmissionError,
    Options<GradeSubmissionData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await gradeSubmission({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getAllUsersQueryKey = (options?: Options<GetAllUsersData>) =>
  createQueryKey('getAllUsers', options);

/**
 * Get all users
 * Fetches a paginated list of all users in the system. Supports pagination and sorting by any user field.
 */
export const getAllUsersOptions = (options?: Options<GetAllUsersData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getAllUsers({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getAllUsersQueryKey(options),
  });
};

export const getAllUsersInfiniteQueryKey = (
  options?: Options<GetAllUsersData>
): QueryKey<Options<GetAllUsersData>> => createQueryKey('getAllUsers', options, true);

/**
 * Get all users
 * Fetches a paginated list of all users in the system. Supports pagination and sorting by any user field.
 */
export const getAllUsersInfiniteOptions = (options?: Options<GetAllUsersData>) => {
  return infiniteQueryOptions<
    GetAllUsersResponse,
    GetAllUsersError,
    InfiniteData<GetAllUsersResponse>,
    QueryKey<Options<GetAllUsersData>>,
    number | Pick<QueryKey<Options<GetAllUsersData>>[0], 'body' | 'headers' | 'path' | 'query'>
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<GetAllUsersData>>[0],
          'body' | 'headers' | 'path' | 'query'
        > =
          typeof pageParam === 'object'
            ? pageParam
            : {
                query: {
                  page: pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getAllUsers({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: getAllUsersInfiniteQueryKey(options),
    }
  );
};

export const getInvitationsSentByUserQueryKey = (options: Options<GetInvitationsSentByUserData>) =>
  createQueryKey('getInvitationsSentByUser', options);

/**
 * Get invitations sent by user
 * Retrieves all invitations that have been sent by a specific user across all organizations and branches. This endpoint helps users track invitations they have created. Results are ordered by creation date (most recent first) and include all invitation statuses.
 */
export const getInvitationsSentByUserOptions = (options: Options<GetInvitationsSentByUserData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getInvitationsSentByUser({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getInvitationsSentByUserQueryKey(options),
  });
};

export const getPendingInvitationsForUserQueryKey = (
  options: Options<GetPendingInvitationsForUserData>
) => createQueryKey('getPendingInvitationsForUser', options);

/**
 * Get pending invitations for user by email
 * Retrieves all pending invitations sent to a specific user's email address across all organizations and branches. This endpoint helps users see all outstanding invitations they have received. Only returns invitations with PENDING status that haven't expired.
 */
export const getPendingInvitationsForUserOptions = (
  options: Options<GetPendingInvitationsForUserData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getPendingInvitationsForUser({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getPendingInvitationsForUserQueryKey(options),
  });
};

export const searchQueryKey = (options: Options<SearchData>) => createQueryKey('search', options);

/**
 * Search users
 * Fetches a paginated list of users based on optional filters. Supports pagination and sorting.
 */
export const searchOptions = (options: Options<SearchData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await search({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: searchQueryKey(options),
  });
};

export const searchInfiniteQueryKey = (
  options: Options<SearchData>
): QueryKey<Options<SearchData>> => createQueryKey('search', options, true);

/**
 * Search users
 * Fetches a paginated list of users based on optional filters. Supports pagination and sorting.
 */
export const searchInfiniteOptions = (options: Options<SearchData>) => {
  return infiniteQueryOptions<
    SearchResponse,
    SearchError,
    InfiniteData<SearchResponse>,
    QueryKey<Options<SearchData>>,
    number | Pick<QueryKey<Options<SearchData>>[0], 'body' | 'headers' | 'path' | 'query'>
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<SearchData>>[0], 'body' | 'headers' | 'path' | 'query'> =
          typeof pageParam === 'object'
            ? pageParam
            : {
                query: {
                  page: pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await search({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: searchInfiniteQueryKey(options),
    }
  );
};

export const getProfileImageQueryKey = (options: Options<GetProfileImageData>) =>
  createQueryKey('getProfileImage', options);

/**
 * Get user profile image by file name
 */
export const getProfileImageOptions = (options: Options<GetProfileImageData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getProfileImage({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getProfileImageQueryKey(options),
  });
};

export const search1QueryKey = (options: Options<Search1Data>) =>
  createQueryKey('search1', options);

/**
 * Search training branches
 * Fetches a paginated list of training branches based on optional filters. Supports pagination and sorting.
 */
export const search1Options = (options: Options<Search1Data>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await search1({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: search1QueryKey(options),
  });
};

export const search1InfiniteQueryKey = (
  options: Options<Search1Data>
): QueryKey<Options<Search1Data>> => createQueryKey('search1', options, true);

/**
 * Search training branches
 * Fetches a paginated list of training branches based on optional filters. Supports pagination and sorting.
 */
export const search1InfiniteOptions = (options: Options<Search1Data>) => {
  return infiniteQueryOptions<
    Search1Response,
    Search1Error,
    InfiniteData<Search1Response>,
    QueryKey<Options<Search1Data>>,
    number | Pick<QueryKey<Options<Search1Data>>[0], 'body' | 'headers' | 'path' | 'query'>
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<Search1Data>>[0], 'body' | 'headers' | 'path' | 'query'> =
          typeof pageParam === 'object'
            ? pageParam
            : {
                query: {
                  page: pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await search1({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: search1InfiniteQueryKey(options),
    }
  );
};

export const getTrainingBranchesByOrganisation1QueryKey = (
  options: Options<GetTrainingBranchesByOrganisation1Data>
) => createQueryKey('getTrainingBranchesByOrganisation1', options);

/**
 * Get training branches by organisation UUID
 */
export const getTrainingBranchesByOrganisation1Options = (
  options: Options<GetTrainingBranchesByOrganisation1Data>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getTrainingBranchesByOrganisation1({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getTrainingBranchesByOrganisation1QueryKey(options),
  });
};

export const getTrainingBranchesByOrganisation1InfiniteQueryKey = (
  options: Options<GetTrainingBranchesByOrganisation1Data>
): QueryKey<Options<GetTrainingBranchesByOrganisation1Data>> =>
  createQueryKey('getTrainingBranchesByOrganisation1', options, true);

/**
 * Get training branches by organisation UUID
 */
export const getTrainingBranchesByOrganisation1InfiniteOptions = (
  options: Options<GetTrainingBranchesByOrganisation1Data>
) => {
  return infiniteQueryOptions<
    GetTrainingBranchesByOrganisation1Response,
    GetTrainingBranchesByOrganisation1Error,
    InfiniteData<GetTrainingBranchesByOrganisation1Response>,
    QueryKey<Options<GetTrainingBranchesByOrganisation1Data>>,
    | number
    | Pick<
        QueryKey<Options<GetTrainingBranchesByOrganisation1Data>>[0],
        'body' | 'headers' | 'path' | 'query'
      >
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<GetTrainingBranchesByOrganisation1Data>>[0],
          'body' | 'headers' | 'path' | 'query'
        > =
          typeof pageParam === 'object'
            ? pageParam
            : {
                query: {
                  page: pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getTrainingBranchesByOrganisation1({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: getTrainingBranchesByOrganisation1InfiniteQueryKey(options),
    }
  );
};

export const searchStudentsQueryKey = (options: Options<SearchStudentsData>) =>
  createQueryKey('searchStudents', options);

/**
 * Search students
 * Search for students based on criteria.
 */
export const searchStudentsOptions = (options: Options<SearchStudentsData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await searchStudents({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: searchStudentsQueryKey(options),
  });
};

export const searchStudentsInfiniteQueryKey = (
  options: Options<SearchStudentsData>
): QueryKey<Options<SearchStudentsData>> => createQueryKey('searchStudents', options, true);

/**
 * Search students
 * Search for students based on criteria.
 */
export const searchStudentsInfiniteOptions = (options: Options<SearchStudentsData>) => {
  return infiniteQueryOptions<
    SearchStudentsResponse,
    SearchStudentsError,
    InfiniteData<SearchStudentsResponse>,
    QueryKey<Options<SearchStudentsData>>,
    number | Pick<QueryKey<Options<SearchStudentsData>>[0], 'body' | 'headers' | 'path' | 'query'>
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<SearchStudentsData>>[0],
          'body' | 'headers' | 'path' | 'query'
        > =
          typeof pageParam === 'object'
            ? pageParam
            : {
                query: {
                  page: pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await searchStudents({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: searchStudentsInfiniteQueryKey(options),
    }
  );
};

export const getQuizTotalPointsQueryKey = (options: Options<GetQuizTotalPointsData>) =>
  createQueryKey('getQuizTotalPoints', options);

/**
 * Get quiz total points
 * Returns the maximum possible points for a quiz.
 */
export const getQuizTotalPointsOptions = (options: Options<GetQuizTotalPointsData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getQuizTotalPoints({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getQuizTotalPointsQueryKey(options),
  });
};

export const getQuestionDistributionQueryKey = (options: Options<GetQuestionDistributionData>) =>
  createQueryKey('getQuestionDistribution', options);

/**
 * Get question category distribution
 * Returns distribution of question types within a quiz.
 */
export const getQuestionDistributionOptions = (options: Options<GetQuestionDistributionData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getQuestionDistribution({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getQuestionDistributionQueryKey(options),
  });
};

export const getQuizAttemptsQueryKey = (options: Options<GetQuizAttemptsData>) =>
  createQueryKey('getQuizAttempts', options);

/**
 * Get quiz attempts
 * Retrieves all attempts for a specific quiz with scoring data.
 */
export const getQuizAttemptsOptions = (options: Options<GetQuizAttemptsData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getQuizAttempts({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getQuizAttemptsQueryKey(options),
  });
};

export const getQuizAttemptsInfiniteQueryKey = (
  options: Options<GetQuizAttemptsData>
): QueryKey<Options<GetQuizAttemptsData>> => createQueryKey('getQuizAttempts', options, true);

/**
 * Get quiz attempts
 * Retrieves all attempts for a specific quiz with scoring data.
 */
export const getQuizAttemptsInfiniteOptions = (options: Options<GetQuizAttemptsData>) => {
  return infiniteQueryOptions<
    GetQuizAttemptsResponse,
    GetQuizAttemptsError,
    InfiniteData<GetQuizAttemptsResponse>,
    QueryKey<Options<GetQuizAttemptsData>>,
    number | Pick<QueryKey<Options<GetQuizAttemptsData>>[0], 'body' | 'headers' | 'path' | 'query'>
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<GetQuizAttemptsData>>[0],
          'body' | 'headers' | 'path' | 'query'
        > =
          typeof pageParam === 'object'
            ? pageParam
            : {
                query: {
                  page: pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getQuizAttempts({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: getQuizAttemptsInfiniteQueryKey(options),
    }
  );
};

export const searchQuizzesQueryKey = (options: Options<SearchQuizzesData>) =>
  createQueryKey('searchQuizzes', options);

/**
 * Search quizzes
 * Advanced quiz search with flexible criteria and operators.
 *
 * **Common Quiz Search Examples:**
 * - `title_like=midterm` - Quizzes with "midterm" in title
 * - `lessonUuid=uuid` - Quizzes for specific lesson
 * - `status=PUBLISHED` - Only published quizzes
 * - `active=true` - Only active quizzes
 * - `timeLimitMinutes_gte=30` - Quizzes with 30+ minute time limit
 * - `attemptsAllowed_lte=3` - Quizzes with 3 or fewer attempts allowed
 * - `passingScore_gte=70` - Quizzes with passing score 70%+
 *
 */
export const searchQuizzesOptions = (options: Options<SearchQuizzesData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await searchQuizzes({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: searchQuizzesQueryKey(options),
  });
};

export const searchQuizzesInfiniteQueryKey = (
  options: Options<SearchQuizzesData>
): QueryKey<Options<SearchQuizzesData>> => createQueryKey('searchQuizzes', options, true);

/**
 * Search quizzes
 * Advanced quiz search with flexible criteria and operators.
 *
 * **Common Quiz Search Examples:**
 * - `title_like=midterm` - Quizzes with "midterm" in title
 * - `lessonUuid=uuid` - Quizzes for specific lesson
 * - `status=PUBLISHED` - Only published quizzes
 * - `active=true` - Only active quizzes
 * - `timeLimitMinutes_gte=30` - Quizzes with 30+ minute time limit
 * - `attemptsAllowed_lte=3` - Quizzes with 3 or fewer attempts allowed
 * - `passingScore_gte=70` - Quizzes with passing score 70%+
 *
 */
export const searchQuizzesInfiniteOptions = (options: Options<SearchQuizzesData>) => {
  return infiniteQueryOptions<
    SearchQuizzesResponse,
    SearchQuizzesError,
    InfiniteData<SearchQuizzesResponse>,
    QueryKey<Options<SearchQuizzesData>>,
    number | Pick<QueryKey<Options<SearchQuizzesData>>[0], 'body' | 'headers' | 'path' | 'query'>
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<SearchQuizzesData>>[0],
          'body' | 'headers' | 'path' | 'query'
        > =
          typeof pageParam === 'object'
            ? pageParam
            : {
                query: {
                  page: pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await searchQuizzes({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: searchQuizzesInfiniteQueryKey(options),
    }
  );
};

export const searchQuestionsQueryKey = (options: Options<SearchQuestionsData>) =>
  createQueryKey('searchQuestions', options);

/**
 * Search quiz questions
 * Search questions across all quizzes.
 *
 * **Common Question Search Examples:**
 * - `quizUuid=uuid` - All questions for specific quiz
 * - `questionType=MULTIPLE_CHOICE` - Only multiple choice questions
 * - `points_gte=2` - Questions worth 2+ points
 * - `questionText_like=calculate` - Questions containing "calculate"
 *
 */
export const searchQuestionsOptions = (options: Options<SearchQuestionsData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await searchQuestions({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: searchQuestionsQueryKey(options),
  });
};

export const searchQuestionsInfiniteQueryKey = (
  options: Options<SearchQuestionsData>
): QueryKey<Options<SearchQuestionsData>> => createQueryKey('searchQuestions', options, true);

/**
 * Search quiz questions
 * Search questions across all quizzes.
 *
 * **Common Question Search Examples:**
 * - `quizUuid=uuid` - All questions for specific quiz
 * - `questionType=MULTIPLE_CHOICE` - Only multiple choice questions
 * - `points_gte=2` - Questions worth 2+ points
 * - `questionText_like=calculate` - Questions containing "calculate"
 *
 */
export const searchQuestionsInfiniteOptions = (options: Options<SearchQuestionsData>) => {
  return infiniteQueryOptions<
    SearchQuestionsResponse,
    SearchQuestionsError,
    InfiniteData<SearchQuestionsResponse>,
    QueryKey<Options<SearchQuestionsData>>,
    number | Pick<QueryKey<Options<SearchQuestionsData>>[0], 'body' | 'headers' | 'path' | 'query'>
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<SearchQuestionsData>>[0],
          'body' | 'headers' | 'path' | 'query'
        > =
          typeof pageParam === 'object'
            ? pageParam
            : {
                query: {
                  page: pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await searchQuestions({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: searchQuestionsInfiniteQueryKey(options),
    }
  );
};

export const searchAttemptsQueryKey = (options: Options<SearchAttemptsData>) =>
  createQueryKey('searchAttempts', options);

/**
 * Search quiz attempts
 * Search quiz attempts across all quizzes.
 *
 * **Common Attempt Search Examples:**
 * - `quizUuid=uuid` - All attempts for specific quiz
 * - `enrollmentUuid=uuid` - All attempts by specific student
 * - `status=COMPLETED` - Only completed attempts
 * - `isPassed=true` - Only passing attempts
 * - `percentage_gte=85` - Attempts with 85%+ score
 * - `startedAt_gte=2024-01-01T00:00:00` - Attempts from 2024
 *
 */
export const searchAttemptsOptions = (options: Options<SearchAttemptsData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await searchAttempts({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: searchAttemptsQueryKey(options),
  });
};

export const searchAttemptsInfiniteQueryKey = (
  options: Options<SearchAttemptsData>
): QueryKey<Options<SearchAttemptsData>> => createQueryKey('searchAttempts', options, true);

/**
 * Search quiz attempts
 * Search quiz attempts across all quizzes.
 *
 * **Common Attempt Search Examples:**
 * - `quizUuid=uuid` - All attempts for specific quiz
 * - `enrollmentUuid=uuid` - All attempts by specific student
 * - `status=COMPLETED` - Only completed attempts
 * - `isPassed=true` - Only passing attempts
 * - `percentage_gte=85` - Attempts with 85%+ score
 * - `startedAt_gte=2024-01-01T00:00:00` - Attempts from 2024
 *
 */
export const searchAttemptsInfiniteOptions = (options: Options<SearchAttemptsData>) => {
  return infiniteQueryOptions<
    SearchAttemptsResponse,
    SearchAttemptsError,
    InfiniteData<SearchAttemptsResponse>,
    QueryKey<Options<SearchAttemptsData>>,
    number | Pick<QueryKey<Options<SearchAttemptsData>>[0], 'body' | 'headers' | 'path' | 'query'>
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<SearchAttemptsData>>[0],
          'body' | 'headers' | 'path' | 'query'
        > =
          typeof pageParam === 'object'
            ? pageParam
            : {
                query: {
                  page: pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await searchAttempts({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: searchAttemptsInfiniteQueryKey(options),
    }
  );
};

export const getProgramEnrollmentsQueryKey = (options: Options<GetProgramEnrollmentsData>) =>
  createQueryKey('getProgramEnrollments', options);

/**
 * Get program enrollments
 * Retrieves enrollment data for a specific program with completion analytics.
 */
export const getProgramEnrollmentsOptions = (options: Options<GetProgramEnrollmentsData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getProgramEnrollments({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getProgramEnrollmentsQueryKey(options),
  });
};

export const getProgramEnrollmentsInfiniteQueryKey = (
  options: Options<GetProgramEnrollmentsData>
): QueryKey<Options<GetProgramEnrollmentsData>> =>
  createQueryKey('getProgramEnrollments', options, true);

/**
 * Get program enrollments
 * Retrieves enrollment data for a specific program with completion analytics.
 */
export const getProgramEnrollmentsInfiniteOptions = (
  options: Options<GetProgramEnrollmentsData>
) => {
  return infiniteQueryOptions<
    GetProgramEnrollmentsResponse,
    GetProgramEnrollmentsError,
    InfiniteData<GetProgramEnrollmentsResponse>,
    QueryKey<Options<GetProgramEnrollmentsData>>,
    | number
    | Pick<QueryKey<Options<GetProgramEnrollmentsData>>[0], 'body' | 'headers' | 'path' | 'query'>
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<GetProgramEnrollmentsData>>[0],
          'body' | 'headers' | 'path' | 'query'
        > =
          typeof pageParam === 'object'
            ? pageParam
            : {
                query: {
                  page: pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getProgramEnrollments({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: getProgramEnrollmentsInfiniteQueryKey(options),
    }
  );
};

export const getRequiredCoursesQueryKey = (options: Options<GetRequiredCoursesData>) =>
  createQueryKey('getRequiredCourses', options);

/**
 * Get required courses
 * Retrieves only the required courses for a program.
 */
export const getRequiredCoursesOptions = (options: Options<GetRequiredCoursesData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getRequiredCourses({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getRequiredCoursesQueryKey(options),
  });
};

export const getOptionalCoursesQueryKey = (options: Options<GetOptionalCoursesData>) =>
  createQueryKey('getOptionalCourses', options);

/**
 * Get optional courses
 * Retrieves only the optional courses for a program.
 */
export const getOptionalCoursesOptions = (options: Options<GetOptionalCoursesData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getOptionalCourses({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getOptionalCoursesQueryKey(options),
  });
};

export const getProgramCompletionRateQueryKey = (options: Options<GetProgramCompletionRateData>) =>
  createQueryKey('getProgramCompletionRate', options);

/**
 * Get program completion rate
 * Returns the completion rate percentage for a program.
 */
export const getProgramCompletionRateOptions = (options: Options<GetProgramCompletionRateData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getProgramCompletionRate({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getProgramCompletionRateQueryKey(options),
  });
};

export const getProgramCertificatesQueryKey = (options: Options<GetProgramCertificatesData>) =>
  createQueryKey('getProgramCertificates', options);

/**
 * Get program certificates
 * Retrieves all certificates issued for program completions.
 */
export const getProgramCertificatesOptions = (options: Options<GetProgramCertificatesData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getProgramCertificates({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getProgramCertificatesQueryKey(options),
  });
};

export const getProgramCertificatesInfiniteQueryKey = (
  options: Options<GetProgramCertificatesData>
): QueryKey<Options<GetProgramCertificatesData>> =>
  createQueryKey('getProgramCertificates', options, true);

/**
 * Get program certificates
 * Retrieves all certificates issued for program completions.
 */
export const getProgramCertificatesInfiniteOptions = (
  options: Options<GetProgramCertificatesData>
) => {
  return infiniteQueryOptions<
    GetProgramCertificatesResponse,
    GetProgramCertificatesError,
    InfiniteData<GetProgramCertificatesResponse>,
    QueryKey<Options<GetProgramCertificatesData>>,
    | number
    | Pick<QueryKey<Options<GetProgramCertificatesData>>[0], 'body' | 'headers' | 'path' | 'query'>
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<GetProgramCertificatesData>>[0],
          'body' | 'headers' | 'path' | 'query'
        > =
          typeof pageParam === 'object'
            ? pageParam
            : {
                query: {
                  page: pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getProgramCertificates({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: getProgramCertificatesInfiniteQueryKey(options),
    }
  );
};

export const searchTrainingProgramsQueryKey = (options: Options<SearchTrainingProgramsData>) =>
  createQueryKey('searchTrainingPrograms', options);

/**
 * Search training programs
 * Advanced program search with flexible criteria and operators.
 *
 * **Common Program Search Examples:**
 * - `title_like=data science` - Programs with titles containing "data science"
 * - `status=PUBLISHED` - Only published programs
 * - `active=true` - Only active programs
 * - `status_in=PUBLISHED,ACTIVE` - Published or active programs
 * - `price_lte=500.00` - Programs priced at $500 or less
 * - `price=null` - Free programs
 * - `instructorUuid=uuid` - Programs by specific instructor
 * - `categoryUuid=uuid` - Programs in specific category
 * - `totalDurationHours_gte=40` - Programs 40+ hours long
 * - `totalDurationHours_between=20,100` - Programs between 20-100 hours
 * - `createdDate_gte=2024-01-01T00:00:00` - Programs created after Jan 1, 2024
 *
 * **Advanced Program Queries:**
 * - `status=PUBLISHED&active=true&price_lte=100` - Published, active programs under $100
 * - `title_like=certification&totalDurationHours_gte=50` - Certification programs 50+ hours
 * - `instructorUuid=uuid&status=PUBLISHED` - Published programs by specific instructor
 *
 * For complete operator documentation, see the instructor search endpoint.
 *
 */
export const searchTrainingProgramsOptions = (options: Options<SearchTrainingProgramsData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await searchTrainingPrograms({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: searchTrainingProgramsQueryKey(options),
  });
};

export const searchTrainingProgramsInfiniteQueryKey = (
  options: Options<SearchTrainingProgramsData>
): QueryKey<Options<SearchTrainingProgramsData>> =>
  createQueryKey('searchTrainingPrograms', options, true);

/**
 * Search training programs
 * Advanced program search with flexible criteria and operators.
 *
 * **Common Program Search Examples:**
 * - `title_like=data science` - Programs with titles containing "data science"
 * - `status=PUBLISHED` - Only published programs
 * - `active=true` - Only active programs
 * - `status_in=PUBLISHED,ACTIVE` - Published or active programs
 * - `price_lte=500.00` - Programs priced at $500 or less
 * - `price=null` - Free programs
 * - `instructorUuid=uuid` - Programs by specific instructor
 * - `categoryUuid=uuid` - Programs in specific category
 * - `totalDurationHours_gte=40` - Programs 40+ hours long
 * - `totalDurationHours_between=20,100` - Programs between 20-100 hours
 * - `createdDate_gte=2024-01-01T00:00:00` - Programs created after Jan 1, 2024
 *
 * **Advanced Program Queries:**
 * - `status=PUBLISHED&active=true&price_lte=100` - Published, active programs under $100
 * - `title_like=certification&totalDurationHours_gte=50` - Certification programs 50+ hours
 * - `instructorUuid=uuid&status=PUBLISHED` - Published programs by specific instructor
 *
 * For complete operator documentation, see the instructor search endpoint.
 *
 */
export const searchTrainingProgramsInfiniteOptions = (
  options: Options<SearchTrainingProgramsData>
) => {
  return infiniteQueryOptions<
    unknown,
    SearchTrainingProgramsError,
    InfiniteData<unknown>,
    QueryKey<Options<SearchTrainingProgramsData>>,
    | number
    | Pick<QueryKey<Options<SearchTrainingProgramsData>>[0], 'body' | 'headers' | 'path' | 'query'>
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<SearchTrainingProgramsData>>[0],
          'body' | 'headers' | 'path' | 'query'
        > =
          typeof pageParam === 'object'
            ? pageParam
            : {
                query: {
                  page: pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await searchTrainingPrograms({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: searchTrainingProgramsInfiniteQueryKey(options),
    }
  );
};

export const searchProgramRequirementsQueryKey = (
  options: Options<SearchProgramRequirementsData>
) => createQueryKey('searchProgramRequirements', options);

/**
 * Search program requirements
 * Search program requirements and prerequisites.
 *
 * **Common Program Requirement Search Examples:**
 * - `programUuid=uuid` - All requirements for specific program
 * - `requirementType=PREREQUISITE` - Only prerequisites
 * - `isMandatory=true` - Only mandatory requirements
 * - `requirementText_like=certification` - Requirements mentioning "certification"
 *
 */
export const searchProgramRequirementsOptions = (
  options: Options<SearchProgramRequirementsData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await searchProgramRequirements({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: searchProgramRequirementsQueryKey(options),
  });
};

export const searchProgramRequirementsInfiniteQueryKey = (
  options: Options<SearchProgramRequirementsData>
): QueryKey<Options<SearchProgramRequirementsData>> =>
  createQueryKey('searchProgramRequirements', options, true);

/**
 * Search program requirements
 * Search program requirements and prerequisites.
 *
 * **Common Program Requirement Search Examples:**
 * - `programUuid=uuid` - All requirements for specific program
 * - `requirementType=PREREQUISITE` - Only prerequisites
 * - `isMandatory=true` - Only mandatory requirements
 * - `requirementText_like=certification` - Requirements mentioning "certification"
 *
 */
export const searchProgramRequirementsInfiniteOptions = (
  options: Options<SearchProgramRequirementsData>
) => {
  return infiniteQueryOptions<
    SearchProgramRequirementsResponse,
    SearchProgramRequirementsError,
    InfiniteData<SearchProgramRequirementsResponse>,
    QueryKey<Options<SearchProgramRequirementsData>>,
    | number
    | Pick<
        QueryKey<Options<SearchProgramRequirementsData>>[0],
        'body' | 'headers' | 'path' | 'query'
      >
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<SearchProgramRequirementsData>>[0],
          'body' | 'headers' | 'path' | 'query'
        > =
          typeof pageParam === 'object'
            ? pageParam
            : {
                query: {
                  page: pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await searchProgramRequirements({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: searchProgramRequirementsInfiniteQueryKey(options),
    }
  );
};

export const getPublishedProgramsQueryKey = (options?: Options<GetPublishedProgramsData>) =>
  createQueryKey('getPublishedPrograms', options);

/**
 * Get published programs
 * Retrieves all published programs available for enrollment.
 */
export const getPublishedProgramsOptions = (options?: Options<GetPublishedProgramsData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getPublishedPrograms({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getPublishedProgramsQueryKey(options),
  });
};

export const getPublishedProgramsInfiniteQueryKey = (
  options?: Options<GetPublishedProgramsData>
): QueryKey<Options<GetPublishedProgramsData>> =>
  createQueryKey('getPublishedPrograms', options, true);

/**
 * Get published programs
 * Retrieves all published programs available for enrollment.
 */
export const getPublishedProgramsInfiniteOptions = (
  options?: Options<GetPublishedProgramsData>
) => {
  return infiniteQueryOptions<
    unknown,
    GetPublishedProgramsError,
    InfiniteData<unknown>,
    QueryKey<Options<GetPublishedProgramsData>>,
    | number
    | Pick<QueryKey<Options<GetPublishedProgramsData>>[0], 'body' | 'headers' | 'path' | 'query'>
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<GetPublishedProgramsData>>[0],
          'body' | 'headers' | 'path' | 'query'
        > =
          typeof pageParam === 'object'
            ? pageParam
            : {
                query: {
                  page: pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getPublishedPrograms({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: getPublishedProgramsInfiniteQueryKey(options),
    }
  );
};

export const getProgramsByInstructorQueryKey = (options: Options<GetProgramsByInstructorData>) =>
  createQueryKey('getProgramsByInstructor', options);

/**
 * Get programs by instructor
 * Retrieves all programs created by a specific instructor.
 */
export const getProgramsByInstructorOptions = (options: Options<GetProgramsByInstructorData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getProgramsByInstructor({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getProgramsByInstructorQueryKey(options),
  });
};

export const getProgramsByInstructorInfiniteQueryKey = (
  options: Options<GetProgramsByInstructorData>
): QueryKey<Options<GetProgramsByInstructorData>> =>
  createQueryKey('getProgramsByInstructor', options, true);

/**
 * Get programs by instructor
 * Retrieves all programs created by a specific instructor.
 */
export const getProgramsByInstructorInfiniteOptions = (
  options: Options<GetProgramsByInstructorData>
) => {
  return infiniteQueryOptions<
    unknown,
    GetProgramsByInstructorError,
    InfiniteData<unknown>,
    QueryKey<Options<GetProgramsByInstructorData>>,
    | number
    | Pick<QueryKey<Options<GetProgramsByInstructorData>>[0], 'body' | 'headers' | 'path' | 'query'>
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<GetProgramsByInstructorData>>[0],
          'body' | 'headers' | 'path' | 'query'
        > =
          typeof pageParam === 'object'
            ? pageParam
            : {
                query: {
                  page: pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getProgramsByInstructor({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: getProgramsByInstructorInfiniteQueryKey(options),
    }
  );
};

export const getFreeProgramsQueryKey = (options?: Options<GetFreeProgramsData>) =>
  createQueryKey('getFreePrograms', options);

/**
 * Get free programs
 * Retrieves all programs available at no cost.
 */
export const getFreeProgramsOptions = (options?: Options<GetFreeProgramsData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getFreePrograms({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getFreeProgramsQueryKey(options),
  });
};

export const getFreeProgramsInfiniteQueryKey = (
  options?: Options<GetFreeProgramsData>
): QueryKey<Options<GetFreeProgramsData>> => createQueryKey('getFreePrograms', options, true);

/**
 * Get free programs
 * Retrieves all programs available at no cost.
 */
export const getFreeProgramsInfiniteOptions = (options?: Options<GetFreeProgramsData>) => {
  return infiniteQueryOptions<
    unknown,
    GetFreeProgramsError,
    InfiniteData<unknown>,
    QueryKey<Options<GetFreeProgramsData>>,
    number | Pick<QueryKey<Options<GetFreeProgramsData>>[0], 'body' | 'headers' | 'path' | 'query'>
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<GetFreeProgramsData>>[0],
          'body' | 'headers' | 'path' | 'query'
        > =
          typeof pageParam === 'object'
            ? pageParam
            : {
                query: {
                  page: pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getFreePrograms({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: getFreeProgramsInfiniteQueryKey(options),
    }
  );
};

export const searchProgramEnrollmentsQueryKey = (options: Options<SearchProgramEnrollmentsData>) =>
  createQueryKey('searchProgramEnrollments', options);

/**
 * Search program enrollments
 * Search enrollment records across all programs.
 *
 * **Common Program Enrollment Search Examples:**
 * - `programUuid=uuid` - All enrollments for specific program
 * - `studentUuid=uuid` - All program enrollments for specific student
 * - `status=COMPLETED` - Only completed program enrollments
 * - `progressPercentage_gte=90` - Students with 90%+ program progress
 * - `enrollmentDate_gte=2024-01-01T00:00:00` - Program enrollments from 2024
 * - `finalGrade_gte=85` - Program completions with grade 85+
 *
 */
export const searchProgramEnrollmentsOptions = (options: Options<SearchProgramEnrollmentsData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await searchProgramEnrollments({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: searchProgramEnrollmentsQueryKey(options),
  });
};

export const searchProgramEnrollmentsInfiniteQueryKey = (
  options: Options<SearchProgramEnrollmentsData>
): QueryKey<Options<SearchProgramEnrollmentsData>> =>
  createQueryKey('searchProgramEnrollments', options, true);

/**
 * Search program enrollments
 * Search enrollment records across all programs.
 *
 * **Common Program Enrollment Search Examples:**
 * - `programUuid=uuid` - All enrollments for specific program
 * - `studentUuid=uuid` - All program enrollments for specific student
 * - `status=COMPLETED` - Only completed program enrollments
 * - `progressPercentage_gte=90` - Students with 90%+ program progress
 * - `enrollmentDate_gte=2024-01-01T00:00:00` - Program enrollments from 2024
 * - `finalGrade_gte=85` - Program completions with grade 85+
 *
 */
export const searchProgramEnrollmentsInfiniteOptions = (
  options: Options<SearchProgramEnrollmentsData>
) => {
  return infiniteQueryOptions<
    SearchProgramEnrollmentsResponse,
    SearchProgramEnrollmentsError,
    InfiniteData<SearchProgramEnrollmentsResponse>,
    QueryKey<Options<SearchProgramEnrollmentsData>>,
    | number
    | Pick<
        QueryKey<Options<SearchProgramEnrollmentsData>>[0],
        'body' | 'headers' | 'path' | 'query'
      >
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<SearchProgramEnrollmentsData>>[0],
          'body' | 'headers' | 'path' | 'query'
        > =
          typeof pageParam === 'object'
            ? pageParam
            : {
                query: {
                  page: pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await searchProgramEnrollments({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: searchProgramEnrollmentsInfiniteQueryKey(options),
    }
  );
};

export const searchProgramCoursesQueryKey = (options: Options<SearchProgramCoursesData>) =>
  createQueryKey('searchProgramCourses', options);

/**
 * Search program courses
 * Search course associations within programs.
 *
 * **Common Program Course Search Examples:**
 * - `programUuid=uuid` - All courses for specific program
 * - `courseUuid=uuid` - All programs containing specific course
 * - `isRequired=true` - Only required course associations
 * - `sequenceOrder_gte=3` - Courses from sequence 3 onwards
 *
 */
export const searchProgramCoursesOptions = (options: Options<SearchProgramCoursesData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await searchProgramCourses({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: searchProgramCoursesQueryKey(options),
  });
};

export const searchProgramCoursesInfiniteQueryKey = (
  options: Options<SearchProgramCoursesData>
): QueryKey<Options<SearchProgramCoursesData>> =>
  createQueryKey('searchProgramCourses', options, true);

/**
 * Search program courses
 * Search course associations within programs.
 *
 * **Common Program Course Search Examples:**
 * - `programUuid=uuid` - All courses for specific program
 * - `courseUuid=uuid` - All programs containing specific course
 * - `isRequired=true` - Only required course associations
 * - `sequenceOrder_gte=3` - Courses from sequence 3 onwards
 *
 */
export const searchProgramCoursesInfiniteOptions = (options: Options<SearchProgramCoursesData>) => {
  return infiniteQueryOptions<
    SearchProgramCoursesResponse,
    SearchProgramCoursesError,
    InfiniteData<SearchProgramCoursesResponse>,
    QueryKey<Options<SearchProgramCoursesData>>,
    | number
    | Pick<QueryKey<Options<SearchProgramCoursesData>>[0], 'body' | 'headers' | 'path' | 'query'>
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<SearchProgramCoursesData>>[0],
          'body' | 'headers' | 'path' | 'query'
        > =
          typeof pageParam === 'object'
            ? pageParam
            : {
                query: {
                  page: pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await searchProgramCourses({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: searchProgramCoursesInfiniteQueryKey(options),
    }
  );
};

export const getProgramsByCategoryQueryKey = (options: Options<GetProgramsByCategoryData>) =>
  createQueryKey('getProgramsByCategory', options);

/**
 * Get programs by category
 * Retrieves all programs in a specific category.
 */
export const getProgramsByCategoryOptions = (options: Options<GetProgramsByCategoryData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getProgramsByCategory({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getProgramsByCategoryQueryKey(options),
  });
};

export const getProgramsByCategoryInfiniteQueryKey = (
  options: Options<GetProgramsByCategoryData>
): QueryKey<Options<GetProgramsByCategoryData>> =>
  createQueryKey('getProgramsByCategory', options, true);

/**
 * Get programs by category
 * Retrieves all programs in a specific category.
 */
export const getProgramsByCategoryInfiniteOptions = (
  options: Options<GetProgramsByCategoryData>
) => {
  return infiniteQueryOptions<
    unknown,
    GetProgramsByCategoryError,
    InfiniteData<unknown>,
    QueryKey<Options<GetProgramsByCategoryData>>,
    | number
    | Pick<QueryKey<Options<GetProgramsByCategoryData>>[0], 'body' | 'headers' | 'path' | 'query'>
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<GetProgramsByCategoryData>>[0],
          'body' | 'headers' | 'path' | 'query'
        > =
          typeof pageParam === 'object'
            ? pageParam
            : {
                query: {
                  page: pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getProgramsByCategory({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: getProgramsByCategoryInfiniteQueryKey(options),
    }
  );
};

export const getActiveProgramsQueryKey = (options?: Options<GetActiveProgramsData>) =>
  createQueryKey('getActivePrograms', options);

/**
 * Get active programs
 * Retrieves all currently active and published programs.
 */
export const getActiveProgramsOptions = (options?: Options<GetActiveProgramsData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getActivePrograms({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getActiveProgramsQueryKey(options),
  });
};

export const getActiveProgramsInfiniteQueryKey = (
  options?: Options<GetActiveProgramsData>
): QueryKey<Options<GetActiveProgramsData>> => createQueryKey('getActivePrograms', options, true);

/**
 * Get active programs
 * Retrieves all currently active and published programs.
 */
export const getActiveProgramsInfiniteOptions = (options?: Options<GetActiveProgramsData>) => {
  return infiniteQueryOptions<
    unknown,
    GetActiveProgramsError,
    InfiniteData<unknown>,
    QueryKey<Options<GetActiveProgramsData>>,
    | number
    | Pick<QueryKey<Options<GetActiveProgramsData>>[0], 'body' | 'headers' | 'path' | 'query'>
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<GetActiveProgramsData>>[0],
          'body' | 'headers' | 'path' | 'query'
        > =
          typeof pageParam === 'object'
            ? pageParam
            : {
                query: {
                  page: pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getActivePrograms({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: getActiveProgramsInfiniteQueryKey(options),
    }
  );
};

export const getUsersByOrganisationQueryKey = (options: Options<GetUsersByOrganisationData>) =>
  createQueryKey('getUsersByOrganisation', options);

/**
 * Get users by organisation ID
 */
export const getUsersByOrganisationOptions = (options: Options<GetUsersByOrganisationData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getUsersByOrganisation({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getUsersByOrganisationQueryKey(options),
  });
};

export const getUsersByOrganisationInfiniteQueryKey = (
  options: Options<GetUsersByOrganisationData>
): QueryKey<Options<GetUsersByOrganisationData>> =>
  createQueryKey('getUsersByOrganisation', options, true);

/**
 * Get users by organisation ID
 */
export const getUsersByOrganisationInfiniteOptions = (
  options: Options<GetUsersByOrganisationData>
) => {
  return infiniteQueryOptions<
    GetUsersByOrganisationResponse,
    GetUsersByOrganisationError,
    InfiniteData<GetUsersByOrganisationResponse>,
    QueryKey<Options<GetUsersByOrganisationData>>,
    | number
    | Pick<QueryKey<Options<GetUsersByOrganisationData>>[0], 'body' | 'headers' | 'path' | 'query'>
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<GetUsersByOrganisationData>>[0],
          'body' | 'headers' | 'path' | 'query'
        > =
          typeof pageParam === 'object'
            ? pageParam
            : {
                query: {
                  page: pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getUsersByOrganisation({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: getUsersByOrganisationInfiniteQueryKey(options),
    }
  );
};

export const getUsersByOrganisationAndDomainQueryKey = (
  options: Options<GetUsersByOrganisationAndDomainData>
) => createQueryKey('getUsersByOrganisationAndDomain', options);

/**
 * Get users by organisation and domain
 * Retrieves all users in the organisation filtered by their role/domain. This endpoint is useful for getting all instructors, students, or admins within an organisation.
 */
export const getUsersByOrganisationAndDomainOptions = (
  options: Options<GetUsersByOrganisationAndDomainData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getUsersByOrganisationAndDomain({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getUsersByOrganisationAndDomainQueryKey(options),
  });
};

export const getBranchUsersQueryKey = (options: Options<GetBranchUsersData>) =>
  createQueryKey('getBranchUsers', options);

/**
 * Get users assigned to training branch
 * Retrieves all users that are assigned to a specific training branch within the organization. This includes users with any role/domain within the branch.
 */
export const getBranchUsersOptions = (options: Options<GetBranchUsersData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getBranchUsers({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getBranchUsersQueryKey(options),
  });
};

export const getBranchUsersByDomainQueryKey = (options: Options<GetBranchUsersByDomainData>) =>
  createQueryKey('getBranchUsersByDomain', options);

/**
 * Get users by training branch and domain
 * Retrieves all users in the training branch filtered by their role/domain. This endpoint is useful for getting all instructors, students, or admins within a specific branch.
 */
export const getBranchUsersByDomainOptions = (options: Options<GetBranchUsersByDomainData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getBranchUsersByDomain({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getBranchUsersByDomainQueryKey(options),
  });
};

export const search2QueryKey = (options: Options<Search2Data>) =>
  createQueryKey('search2', options);

/**
 * Search organisations
 * Fetches a paginated list of organisations based on optional filters. Supports pagination and sorting.
 */
export const search2Options = (options: Options<Search2Data>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await search2({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: search2QueryKey(options),
  });
};

export const search2InfiniteQueryKey = (
  options: Options<Search2Data>
): QueryKey<Options<Search2Data>> => createQueryKey('search2', options, true);

/**
 * Search organisations
 * Fetches a paginated list of organisations based on optional filters. Supports pagination and sorting.
 */
export const search2InfiniteOptions = (options: Options<Search2Data>) => {
  return infiniteQueryOptions<
    Search2Response,
    Search2Error,
    InfiniteData<Search2Response>,
    QueryKey<Options<Search2Data>>,
    number | Pick<QueryKey<Options<Search2Data>>[0], 'body' | 'headers' | 'path' | 'query'>
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<Search2Data>>[0], 'body' | 'headers' | 'path' | 'query'> =
          typeof pageParam === 'object'
            ? pageParam
            : {
                query: {
                  page: pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await search2({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: search2InfiniteQueryKey(options),
    }
  );
};

export const validateInvitationQueryKey = (options: Options<ValidateInvitationData>) =>
  createQueryKey('validateInvitation', options);

/**
 * Validate invitation token
 * Validates whether an invitation token is currently valid and can be accepted or declined. Checks if the invitation exists, is in PENDING status, and has not expired. This endpoint is useful for pre-validation before displaying acceptance/decline forms.
 */
export const validateInvitationOptions = (options: Options<ValidateInvitationData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await validateInvitation({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: validateInvitationQueryKey(options),
  });
};

export const getInvitationByTokenQueryKey = (options: Options<GetInvitationByTokenData>) =>
  createQueryKey('getInvitationByToken', options);

/**
 * Get invitation details by token
 * Retrieves complete invitation information using the unique token from the invitation email. This endpoint is typically used by the invitation acceptance/decline pages to display invitation details before the user makes their decision. Includes organization, branch, and role information.
 */
export const getInvitationByTokenOptions = (options: Options<GetInvitationByTokenData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getInvitationByToken({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getInvitationByTokenQueryKey(options),
  });
};

export const getPendingInvitationsForEmailQueryKey = (
  options: Options<GetPendingInvitationsForEmailData>
) => createQueryKey('getPendingInvitationsForEmail', options);

/**
 * Get pending invitations for email address
 * Retrieves all pending invitations sent to a specific email address across all organizations and branches. This endpoint helps users see all outstanding invitations they have received. Only returns invitations with PENDING status that haven't expired.
 */
export const getPendingInvitationsForEmailOptions = (
  options: Options<GetPendingInvitationsForEmailData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getPendingInvitationsForEmail({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getPendingInvitationsForEmailQueryKey(options),
  });
};

export const searchSkillsQueryKey = (options: Options<SearchSkillsData>) =>
  createQueryKey('searchSkills', options);

/**
 * Search instructor skills
 * Search skills with flexible criteria.
 *
 * **Common Skills Search Examples:**
 * - `instructorUuid=uuid` - All skills for specific instructor
 * - `skillName_like=java` - Skills containing "java"
 * - `proficiencyLevel=EXPERT` - Expert level skills only
 * - `proficiencyLevel_in=ADVANCED,EXPERT` - Advanced or expert skills
 * - `skillName_startswith=Data` - Skills starting with "Data"
 * - `proficiencyLevel_noteq=BEGINNER` - Non-beginner skills
 *
 * **Skills Analysis Queries:**
 * - `skillName_like=programming&proficiencyLevel_in=ADVANCED,EXPERT` - Advanced programming skills
 * - `createdDate_gte=2024-01-01&proficiencyLevel=EXPERT` - Recently added expert skills
 *
 * **Proficiency Levels:** BEGINNER, INTERMEDIATE, ADVANCED, EXPERT
 *
 * For complete operator documentation, see the main search endpoint.
 *
 */
export const searchSkillsOptions = (options: Options<SearchSkillsData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await searchSkills({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: searchSkillsQueryKey(options),
  });
};

export const searchSkillsInfiniteQueryKey = (
  options: Options<SearchSkillsData>
): QueryKey<Options<SearchSkillsData>> => createQueryKey('searchSkills', options, true);

/**
 * Search instructor skills
 * Search skills with flexible criteria.
 *
 * **Common Skills Search Examples:**
 * - `instructorUuid=uuid` - All skills for specific instructor
 * - `skillName_like=java` - Skills containing "java"
 * - `proficiencyLevel=EXPERT` - Expert level skills only
 * - `proficiencyLevel_in=ADVANCED,EXPERT` - Advanced or expert skills
 * - `skillName_startswith=Data` - Skills starting with "Data"
 * - `proficiencyLevel_noteq=BEGINNER` - Non-beginner skills
 *
 * **Skills Analysis Queries:**
 * - `skillName_like=programming&proficiencyLevel_in=ADVANCED,EXPERT` - Advanced programming skills
 * - `createdDate_gte=2024-01-01&proficiencyLevel=EXPERT` - Recently added expert skills
 *
 * **Proficiency Levels:** BEGINNER, INTERMEDIATE, ADVANCED, EXPERT
 *
 * For complete operator documentation, see the main search endpoint.
 *
 */
export const searchSkillsInfiniteOptions = (options: Options<SearchSkillsData>) => {
  return infiniteQueryOptions<
    SearchSkillsResponse,
    SearchSkillsError,
    InfiniteData<SearchSkillsResponse>,
    QueryKey<Options<SearchSkillsData>>,
    number | Pick<QueryKey<Options<SearchSkillsData>>[0], 'body' | 'headers' | 'path' | 'query'>
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<SearchSkillsData>>[0],
          'body' | 'headers' | 'path' | 'query'
        > =
          typeof pageParam === 'object'
            ? pageParam
            : {
                query: {
                  page: pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await searchSkills({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: searchSkillsInfiniteQueryKey(options),
    }
  );
};

export const searchInstructorsQueryKey = (options: Options<SearchInstructorsData>) =>
  createQueryKey('searchInstructors', options);

/**
 * Search instructors
 *  Search for instructors using flexible criteria with advanced operators.
 *
 * **Basic Search:**
 * - `field=value` - Exact match (default operation)
 * - `firstName=John` - Find instructors with firstName exactly "John"
 *
 * **Comparison Operators:**
 * - `field_gt=value` - Greater than
 * - `field_lt=value` - Less than
 * - `field_gte=value` - Greater than or equal
 * - `field_lte=value` - Less than or equal
 * - `createdDate_gte=2024-01-01T00:00:00` - Created after Jan 1, 2024
 *
 * **String Operations:**
 * - `field_like=value` - Contains (case-insensitive)
 * - `field_startswith=value` - Starts with (case-insensitive)
 * - `field_endswith=value` - Ends with (case-insensitive)
 * - `lastName_like=smith` - Last name contains "smith"
 *
 * **List Operations:**
 * - `field_in=val1,val2,val3` - Field is in list
 * - `field_notin=val1,val2` - Field is not in list
 * - `status_in=ACTIVE,PENDING` - Status is either ACTIVE or PENDING
 *
 * **Negation:**
 * - `field_noteq=value` - Not equal to value
 * - `isActive_noteq=false` - Is not false (i.e., is true)
 *
 * **Range Operations:**
 * - `field_between=start,end` - Value between start and end (inclusive)
 * - `createdDate_between=2024-01-01T00:00:00,2024-12-31T23:59:59` - Created in 2024
 *
 * **Complex Operations:**
 * - `field_notingroup=relationshipField,groupId` - Not in specific group
 *
 * **Nested Field Access:**
 * - `nestedObject.field=value` - Search in nested objects
 *
 * **Supported Data Types:**
 * - String, UUID, Boolean (true/false or 1/0), Integer, Long, Double, Float, BigDecimal
 * - Date (YYYY-MM-DD), Timestamp, LocalDateTime (ISO format)
 *
 * **Examples:**
 * - `/search?firstName_like=john&isActive=true&createdDate_gte=2024-01-01T00:00:00`
 * - `/search?experience_gt=5&status_in=ACTIVE,VERIFIED`
 * - `/search?email_endswith=@company.com&department_noteq=IT`
 *
 */
export const searchInstructorsOptions = (options: Options<SearchInstructorsData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await searchInstructors({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: searchInstructorsQueryKey(options),
  });
};

export const searchInstructorsInfiniteQueryKey = (
  options: Options<SearchInstructorsData>
): QueryKey<Options<SearchInstructorsData>> => createQueryKey('searchInstructors', options, true);

/**
 * Search instructors
 *  Search for instructors using flexible criteria with advanced operators.
 *
 * **Basic Search:**
 * - `field=value` - Exact match (default operation)
 * - `firstName=John` - Find instructors with firstName exactly "John"
 *
 * **Comparison Operators:**
 * - `field_gt=value` - Greater than
 * - `field_lt=value` - Less than
 * - `field_gte=value` - Greater than or equal
 * - `field_lte=value` - Less than or equal
 * - `createdDate_gte=2024-01-01T00:00:00` - Created after Jan 1, 2024
 *
 * **String Operations:**
 * - `field_like=value` - Contains (case-insensitive)
 * - `field_startswith=value` - Starts with (case-insensitive)
 * - `field_endswith=value` - Ends with (case-insensitive)
 * - `lastName_like=smith` - Last name contains "smith"
 *
 * **List Operations:**
 * - `field_in=val1,val2,val3` - Field is in list
 * - `field_notin=val1,val2` - Field is not in list
 * - `status_in=ACTIVE,PENDING` - Status is either ACTIVE or PENDING
 *
 * **Negation:**
 * - `field_noteq=value` - Not equal to value
 * - `isActive_noteq=false` - Is not false (i.e., is true)
 *
 * **Range Operations:**
 * - `field_between=start,end` - Value between start and end (inclusive)
 * - `createdDate_between=2024-01-01T00:00:00,2024-12-31T23:59:59` - Created in 2024
 *
 * **Complex Operations:**
 * - `field_notingroup=relationshipField,groupId` - Not in specific group
 *
 * **Nested Field Access:**
 * - `nestedObject.field=value` - Search in nested objects
 *
 * **Supported Data Types:**
 * - String, UUID, Boolean (true/false or 1/0), Integer, Long, Double, Float, BigDecimal
 * - Date (YYYY-MM-DD), Timestamp, LocalDateTime (ISO format)
 *
 * **Examples:**
 * - `/search?firstName_like=john&isActive=true&createdDate_gte=2024-01-01T00:00:00`
 * - `/search?experience_gt=5&status_in=ACTIVE,VERIFIED`
 * - `/search?email_endswith=@company.com&department_noteq=IT`
 *
 */
export const searchInstructorsInfiniteOptions = (options: Options<SearchInstructorsData>) => {
  return infiniteQueryOptions<
    SearchInstructorsResponse,
    SearchInstructorsError,
    InfiniteData<SearchInstructorsResponse>,
    QueryKey<Options<SearchInstructorsData>>,
    | number
    | Pick<QueryKey<Options<SearchInstructorsData>>[0], 'body' | 'headers' | 'path' | 'query'>
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<SearchInstructorsData>>[0],
          'body' | 'headers' | 'path' | 'query'
        > =
          typeof pageParam === 'object'
            ? pageParam
            : {
                query: {
                  page: pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await searchInstructors({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: searchInstructorsInfiniteQueryKey(options),
    }
  );
};

export const searchMembershipsQueryKey = (options: Options<SearchMembershipsData>) =>
  createQueryKey('searchMemberships', options);

/**
 * Search instructor memberships
 * Search membership records with flexible criteria.
 *
 * **Common Membership Search Examples:**
 * - `instructorUuid=uuid` - All memberships for specific instructor
 * - `isActive=true` - Active memberships only
 * - `organizationName_like=professional` - Organizations with "professional" in name
 * - `startDate_gte=2023-01-01` - Memberships started in 2023 or later
 * - `endDate=null` - Ongoing memberships (no end date)
 * - `membershipNumber_startswith=PRO` - Numbers starting with "PRO"
 *
 * **Membership Analysis Queries:**
 * - `isActive=true&endDate=null` - Currently active ongoing memberships
 * - `isActive=false&endDate_gte=2024-01-01` - Recently expired memberships
 * - `startDate_between=2020-01-01,2023-12-31` - Joined between 2020-2023
 *
 * For complete operator documentation, see the main search endpoint.
 *
 */
export const searchMembershipsOptions = (options: Options<SearchMembershipsData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await searchMemberships({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: searchMembershipsQueryKey(options),
  });
};

export const searchMembershipsInfiniteQueryKey = (
  options: Options<SearchMembershipsData>
): QueryKey<Options<SearchMembershipsData>> => createQueryKey('searchMemberships', options, true);

/**
 * Search instructor memberships
 * Search membership records with flexible criteria.
 *
 * **Common Membership Search Examples:**
 * - `instructorUuid=uuid` - All memberships for specific instructor
 * - `isActive=true` - Active memberships only
 * - `organizationName_like=professional` - Organizations with "professional" in name
 * - `startDate_gte=2023-01-01` - Memberships started in 2023 or later
 * - `endDate=null` - Ongoing memberships (no end date)
 * - `membershipNumber_startswith=PRO` - Numbers starting with "PRO"
 *
 * **Membership Analysis Queries:**
 * - `isActive=true&endDate=null` - Currently active ongoing memberships
 * - `isActive=false&endDate_gte=2024-01-01` - Recently expired memberships
 * - `startDate_between=2020-01-01,2023-12-31` - Joined between 2020-2023
 *
 * For complete operator documentation, see the main search endpoint.
 *
 */
export const searchMembershipsInfiniteOptions = (options: Options<SearchMembershipsData>) => {
  return infiniteQueryOptions<
    SearchMembershipsResponse,
    SearchMembershipsError,
    InfiniteData<SearchMembershipsResponse>,
    QueryKey<Options<SearchMembershipsData>>,
    | number
    | Pick<QueryKey<Options<SearchMembershipsData>>[0], 'body' | 'headers' | 'path' | 'query'>
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<SearchMembershipsData>>[0],
          'body' | 'headers' | 'path' | 'query'
        > =
          typeof pageParam === 'object'
            ? pageParam
            : {
                query: {
                  page: pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await searchMemberships({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: searchMembershipsInfiniteQueryKey(options),
    }
  );
};

export const searchExperienceQueryKey = (options: Options<SearchExperienceData>) =>
  createQueryKey('searchExperience', options);

/**
 * Search instructor experience
 * Search experience records with flexible criteria.
 *
 * **Common Experience Search Examples:**
 * - `instructorUuid=uuid` - All experience for specific instructor
 * - `isCurrentPosition=true` - Current positions only
 * - `position_like=manager` - Positions containing "manager"
 * - `organizationName_endswith=Ltd` - Organizations ending with "Ltd"
 * - `yearsOfExperience_gte=5` - 5+ years experience
 * - `startDate_gte=2020-01-01` - Started in 2020 or later
 * - `endDate=null` - Ongoing positions (no end date)
 * - `responsibilities_like=team` - Responsibilities mentioning "team"
 *
 * **Experience Analysis Queries:**
 * - `isCurrentPosition=false&endDate_gte=2023-01-01` - Recent past positions
 * - `yearsOfExperience_between=3,10` - Mid-level experience (3-10 years)
 *
 * For complete operator documentation, see the main search endpoint.
 *
 */
export const searchExperienceOptions = (options: Options<SearchExperienceData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await searchExperience({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: searchExperienceQueryKey(options),
  });
};

export const searchExperienceInfiniteQueryKey = (
  options: Options<SearchExperienceData>
): QueryKey<Options<SearchExperienceData>> => createQueryKey('searchExperience', options, true);

/**
 * Search instructor experience
 * Search experience records with flexible criteria.
 *
 * **Common Experience Search Examples:**
 * - `instructorUuid=uuid` - All experience for specific instructor
 * - `isCurrentPosition=true` - Current positions only
 * - `position_like=manager` - Positions containing "manager"
 * - `organizationName_endswith=Ltd` - Organizations ending with "Ltd"
 * - `yearsOfExperience_gte=5` - 5+ years experience
 * - `startDate_gte=2020-01-01` - Started in 2020 or later
 * - `endDate=null` - Ongoing positions (no end date)
 * - `responsibilities_like=team` - Responsibilities mentioning "team"
 *
 * **Experience Analysis Queries:**
 * - `isCurrentPosition=false&endDate_gte=2023-01-01` - Recent past positions
 * - `yearsOfExperience_between=3,10` - Mid-level experience (3-10 years)
 *
 * For complete operator documentation, see the main search endpoint.
 *
 */
export const searchExperienceInfiniteOptions = (options: Options<SearchExperienceData>) => {
  return infiniteQueryOptions<
    SearchExperienceResponse,
    SearchExperienceError,
    InfiniteData<SearchExperienceResponse>,
    QueryKey<Options<SearchExperienceData>>,
    number | Pick<QueryKey<Options<SearchExperienceData>>[0], 'body' | 'headers' | 'path' | 'query'>
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<SearchExperienceData>>[0],
          'body' | 'headers' | 'path' | 'query'
        > =
          typeof pageParam === 'object'
            ? pageParam
            : {
                query: {
                  page: pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await searchExperience({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: searchExperienceInfiniteQueryKey(options),
    }
  );
};

export const searchEducationQueryKey = (options: Options<SearchEducationData>) =>
  createQueryKey('searchEducation', options);

/**
 * Search instructor education
 * Search education records with flexible criteria.
 *
 * **Common Education Search Examples:**
 * - `instructorUuid=uuid` - All education for specific instructor
 * - `qualification_like=degree` - Qualifications containing "degree"
 * - `schoolName_startswith=University` - Schools starting with "University"
 * - `yearCompleted_gte=2020` - Completed in 2020 or later
 * - `yearCompleted_between=2015,2020` - Completed between 2015-2020
 * - `certificateNumber_noteq=null` - Has certificate number
 *
 * For complete operator documentation, see the main search endpoint.
 *
 */
export const searchEducationOptions = (options: Options<SearchEducationData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await searchEducation({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: searchEducationQueryKey(options),
  });
};

export const searchEducationInfiniteQueryKey = (
  options: Options<SearchEducationData>
): QueryKey<Options<SearchEducationData>> => createQueryKey('searchEducation', options, true);

/**
 * Search instructor education
 * Search education records with flexible criteria.
 *
 * **Common Education Search Examples:**
 * - `instructorUuid=uuid` - All education for specific instructor
 * - `qualification_like=degree` - Qualifications containing "degree"
 * - `schoolName_startswith=University` - Schools starting with "University"
 * - `yearCompleted_gte=2020` - Completed in 2020 or later
 * - `yearCompleted_between=2015,2020` - Completed between 2015-2020
 * - `certificateNumber_noteq=null` - Has certificate number
 *
 * For complete operator documentation, see the main search endpoint.
 *
 */
export const searchEducationInfiniteOptions = (options: Options<SearchEducationData>) => {
  return infiniteQueryOptions<
    SearchEducationResponse,
    SearchEducationError,
    InfiniteData<SearchEducationResponse>,
    QueryKey<Options<SearchEducationData>>,
    number | Pick<QueryKey<Options<SearchEducationData>>[0], 'body' | 'headers' | 'path' | 'query'>
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<SearchEducationData>>[0],
          'body' | 'headers' | 'path' | 'query'
        > =
          typeof pageParam === 'object'
            ? pageParam
            : {
                query: {
                  page: pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await searchEducation({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: searchEducationInfiniteQueryKey(options),
    }
  );
};

export const searchDocumentsQueryKey = (options: Options<SearchDocumentsData>) =>
  createQueryKey('searchDocuments', options);

/**
 * Search instructor documents
 * Search documents with flexible criteria using advanced operators.
 *
 * **Common Document Search Examples:**
 * - `instructorUuid=uuid` - All documents for specific instructor
 * - `isVerified=false` - Unverified documents
 * - `status=PENDING` - Documents with pending status
 * - `status_in=APPROVED,VERIFIED` - Approved or verified documents
 * - `expiryDate_lte=2025-12-31` - Documents expiring by end of 2025
 * - `mimeType_like=pdf` - PDF documents
 * - `fileSizeBytes_gt=1048576` - Files larger than 1MB
 * - `title_startswith=Certificate` - Titles starting with "Certificate"
 * - `createdDate_between=2024-01-01T00:00:00,2024-12-31T23:59:59` - Created in 2024
 *
 * **Special Document Queries:**
 * - `isVerified=false&expiryDate_lte=2025-12-31` - Unverified expiring documents
 * - `status_noteq=EXPIRED&expiryDate_lt=2025-07-02` - Non-expired but overdue docs
 *
 * For complete operator documentation, see the main search endpoint.
 *
 */
export const searchDocumentsOptions = (options: Options<SearchDocumentsData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await searchDocuments({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: searchDocumentsQueryKey(options),
  });
};

export const searchDocumentsInfiniteQueryKey = (
  options: Options<SearchDocumentsData>
): QueryKey<Options<SearchDocumentsData>> => createQueryKey('searchDocuments', options, true);

/**
 * Search instructor documents
 * Search documents with flexible criteria using advanced operators.
 *
 * **Common Document Search Examples:**
 * - `instructorUuid=uuid` - All documents for specific instructor
 * - `isVerified=false` - Unverified documents
 * - `status=PENDING` - Documents with pending status
 * - `status_in=APPROVED,VERIFIED` - Approved or verified documents
 * - `expiryDate_lte=2025-12-31` - Documents expiring by end of 2025
 * - `mimeType_like=pdf` - PDF documents
 * - `fileSizeBytes_gt=1048576` - Files larger than 1MB
 * - `title_startswith=Certificate` - Titles starting with "Certificate"
 * - `createdDate_between=2024-01-01T00:00:00,2024-12-31T23:59:59` - Created in 2024
 *
 * **Special Document Queries:**
 * - `isVerified=false&expiryDate_lte=2025-12-31` - Unverified expiring documents
 * - `status_noteq=EXPIRED&expiryDate_lt=2025-07-02` - Non-expired but overdue docs
 *
 * For complete operator documentation, see the main search endpoint.
 *
 */
export const searchDocumentsInfiniteOptions = (options: Options<SearchDocumentsData>) => {
  return infiniteQueryOptions<
    SearchDocumentsResponse,
    SearchDocumentsError,
    InfiniteData<SearchDocumentsResponse>,
    QueryKey<Options<SearchDocumentsData>>,
    number | Pick<QueryKey<Options<SearchDocumentsData>>[0], 'body' | 'headers' | 'path' | 'query'>
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<SearchDocumentsData>>[0],
          'body' | 'headers' | 'path' | 'query'
        > =
          typeof pageParam === 'object'
            ? pageParam
            : {
                query: {
                  page: pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await searchDocuments({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: searchDocumentsInfiniteQueryKey(options),
    }
  );
};

export const getStatusTransitionsQueryKey = (options: Options<GetStatusTransitionsData>) =>
  createQueryKey('getStatusTransitions', options);

/**
 * Get available status transitions
 * Returns the list of valid status transitions for a course based on its current state and business rules.
 *
 * **Status Transition Rules:**
 * - DRAFT → IN_REVIEW, ARCHIVED
 * - IN_REVIEW → DRAFT, PUBLISHED, ARCHIVED
 * - PUBLISHED → DRAFT (if no active enrollments), ARCHIVED
 * - ARCHIVED → (no transitions - permanent state)
 *
 */
export const getStatusTransitionsOptions = (options: Options<GetStatusTransitionsData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getStatusTransitions({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getStatusTransitionsQueryKey(options),
  });
};

export const getCourseEnrollmentsQueryKey = (options: Options<GetCourseEnrollmentsData>) =>
  createQueryKey('getCourseEnrollments', options);

/**
 * Get course enrollments
 * Retrieves enrollment data for a specific course with analytics.
 */
export const getCourseEnrollmentsOptions = (options: Options<GetCourseEnrollmentsData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getCourseEnrollments({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getCourseEnrollmentsQueryKey(options),
  });
};

export const getCourseEnrollmentsInfiniteQueryKey = (
  options: Options<GetCourseEnrollmentsData>
): QueryKey<Options<GetCourseEnrollmentsData>> =>
  createQueryKey('getCourseEnrollments', options, true);

/**
 * Get course enrollments
 * Retrieves enrollment data for a specific course with analytics.
 */
export const getCourseEnrollmentsInfiniteOptions = (options: Options<GetCourseEnrollmentsData>) => {
  return infiniteQueryOptions<
    GetCourseEnrollmentsResponse,
    GetCourseEnrollmentsError,
    InfiniteData<GetCourseEnrollmentsResponse>,
    QueryKey<Options<GetCourseEnrollmentsData>>,
    | number
    | Pick<QueryKey<Options<GetCourseEnrollmentsData>>[0], 'body' | 'headers' | 'path' | 'query'>
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<GetCourseEnrollmentsData>>[0],
          'body' | 'headers' | 'path' | 'query'
        > =
          typeof pageParam === 'object'
            ? pageParam
            : {
                query: {
                  page: pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getCourseEnrollments({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: getCourseEnrollmentsInfiniteQueryKey(options),
    }
  );
};

export const getCourseCompletionRateQueryKey = (options: Options<GetCourseCompletionRateData>) =>
  createQueryKey('getCourseCompletionRate', options);

/**
 * Get course completion rate
 * Returns the completion rate percentage for a course.
 */
export const getCourseCompletionRateOptions = (options: Options<GetCourseCompletionRateData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getCourseCompletionRate({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getCourseCompletionRateQueryKey(options),
  });
};

/**
 * Remove all categories from course
 * Removes all category associations from a course.
 */
export const removeAllCategoriesFromCourseMutation = (
  options?: Partial<Options<RemoveAllCategoriesFromCourseData>>
): UseMutationOptions<
  RemoveAllCategoriesFromCourseResponse,
  RemoveAllCategoriesFromCourseError,
  Options<RemoveAllCategoriesFromCourseData>
> => {
  const mutationOptions: UseMutationOptions<
    RemoveAllCategoriesFromCourseResponse,
    RemoveAllCategoriesFromCourseError,
    Options<RemoveAllCategoriesFromCourseData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await removeAllCategoriesFromCourse({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getCourseCategoriesQueryKey = (options: Options<GetCourseCategoriesData>) =>
  createQueryKey('getCourseCategories', options);

/**
 * Get course categories
 * Retrieves all categories assigned to a specific course.
 */
export const getCourseCategoriesOptions = (options: Options<GetCourseCategoriesData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getCourseCategories({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getCourseCategoriesQueryKey(options),
  });
};

export const searchCoursesQueryKey = (options: Options<SearchCoursesData>) =>
  createQueryKey('searchCourses', options);

/**
 * Search courses with enhanced category filtering
 * Advanced course search with flexible criteria and operators, including category-based filtering.
 *
 * **Category-Specific Search Examples:**
 * - `categoryUuids_in=uuid1,uuid2` - Courses in any of these categories
 * - `categoryUuids_contains=uuid` - Courses containing specific category
 * - `categoryNames_like=programming` - Courses in categories with "programming" in the name
 * - `categoryCount_gte=2` - Courses assigned to 2 or more categories
 * - `hasMultipleCategories=true` - Courses with multiple category assignments
 *
 * **Combined Search Examples:**
 * - `status=PUBLISHED&categoryUuids_in=uuid1,uuid2&price_lte=100` - Published courses under $100 in specific categories
 * - `name_like=java&categoryNames_like=programming&active=true` - Active Java courses in programming categories
 *
 * For complete operator documentation, see the general course search endpoint.
 *
 */
export const searchCoursesOptions = (options: Options<SearchCoursesData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await searchCourses({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: searchCoursesQueryKey(options),
  });
};

export const searchCoursesInfiniteQueryKey = (
  options: Options<SearchCoursesData>
): QueryKey<Options<SearchCoursesData>> => createQueryKey('searchCourses', options, true);

/**
 * Search courses with enhanced category filtering
 * Advanced course search with flexible criteria and operators, including category-based filtering.
 *
 * **Category-Specific Search Examples:**
 * - `categoryUuids_in=uuid1,uuid2` - Courses in any of these categories
 * - `categoryUuids_contains=uuid` - Courses containing specific category
 * - `categoryNames_like=programming` - Courses in categories with "programming" in the name
 * - `categoryCount_gte=2` - Courses assigned to 2 or more categories
 * - `hasMultipleCategories=true` - Courses with multiple category assignments
 *
 * **Combined Search Examples:**
 * - `status=PUBLISHED&categoryUuids_in=uuid1,uuid2&price_lte=100` - Published courses under $100 in specific categories
 * - `name_like=java&categoryNames_like=programming&active=true` - Active Java courses in programming categories
 *
 * For complete operator documentation, see the general course search endpoint.
 *
 */
export const searchCoursesInfiniteOptions = (options: Options<SearchCoursesData>) => {
  return infiniteQueryOptions<
    SearchCoursesResponse,
    SearchCoursesError,
    InfiniteData<SearchCoursesResponse>,
    QueryKey<Options<SearchCoursesData>>,
    number | Pick<QueryKey<Options<SearchCoursesData>>[0], 'body' | 'headers' | 'path' | 'query'>
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<SearchCoursesData>>[0],
          'body' | 'headers' | 'path' | 'query'
        > =
          typeof pageParam === 'object'
            ? pageParam
            : {
                query: {
                  page: pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await searchCourses({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: searchCoursesInfiniteQueryKey(options),
    }
  );
};

export const searchRequirementsQueryKey = (options: Options<SearchRequirementsData>) =>
  createQueryKey('searchRequirements', options);

/**
 * Search course requirements
 * Search course requirements and prerequisites.
 *
 * **Common Requirement Search Examples:**
 * - `courseUuid=uuid` - All requirements for specific course
 * - `requirementType=PREREQUISITE` - Only prerequisites
 * - `isMandatory=true` - Only mandatory requirements
 * - `requirementText_like=experience` - Requirements mentioning "experience"
 *
 */
export const searchRequirementsOptions = (options: Options<SearchRequirementsData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await searchRequirements({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: searchRequirementsQueryKey(options),
  });
};

export const searchRequirementsInfiniteQueryKey = (
  options: Options<SearchRequirementsData>
): QueryKey<Options<SearchRequirementsData>> => createQueryKey('searchRequirements', options, true);

/**
 * Search course requirements
 * Search course requirements and prerequisites.
 *
 * **Common Requirement Search Examples:**
 * - `courseUuid=uuid` - All requirements for specific course
 * - `requirementType=PREREQUISITE` - Only prerequisites
 * - `isMandatory=true` - Only mandatory requirements
 * - `requirementText_like=experience` - Requirements mentioning "experience"
 *
 */
export const searchRequirementsInfiniteOptions = (options: Options<SearchRequirementsData>) => {
  return infiniteQueryOptions<
    SearchRequirementsResponse,
    SearchRequirementsError,
    InfiniteData<SearchRequirementsResponse>,
    QueryKey<Options<SearchRequirementsData>>,
    | number
    | Pick<QueryKey<Options<SearchRequirementsData>>[0], 'body' | 'headers' | 'path' | 'query'>
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<SearchRequirementsData>>[0],
          'body' | 'headers' | 'path' | 'query'
        > =
          typeof pageParam === 'object'
            ? pageParam
            : {
                query: {
                  page: pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await searchRequirements({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: searchRequirementsInfiniteQueryKey(options),
    }
  );
};

export const getPublishedCoursesQueryKey = (options?: Options<GetPublishedCoursesData>) =>
  createQueryKey('getPublishedCourses', options);

/**
 * Get published courses
 * Retrieves all published courses available for enrollment.
 */
export const getPublishedCoursesOptions = (options?: Options<GetPublishedCoursesData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getPublishedCourses({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getPublishedCoursesQueryKey(options),
  });
};

export const getPublishedCoursesInfiniteQueryKey = (
  options?: Options<GetPublishedCoursesData>
): QueryKey<Options<GetPublishedCoursesData>> =>
  createQueryKey('getPublishedCourses', options, true);

/**
 * Get published courses
 * Retrieves all published courses available for enrollment.
 */
export const getPublishedCoursesInfiniteOptions = (options?: Options<GetPublishedCoursesData>) => {
  return infiniteQueryOptions<
    GetPublishedCoursesResponse,
    GetPublishedCoursesError,
    InfiniteData<GetPublishedCoursesResponse>,
    QueryKey<Options<GetPublishedCoursesData>>,
    | number
    | Pick<QueryKey<Options<GetPublishedCoursesData>>[0], 'body' | 'headers' | 'path' | 'query'>
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<GetPublishedCoursesData>>[0],
          'body' | 'headers' | 'path' | 'query'
        > =
          typeof pageParam === 'object'
            ? pageParam
            : {
                query: {
                  page: pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getPublishedCourses({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: getPublishedCoursesInfiniteQueryKey(options),
    }
  );
};

export const getCourseMediaQueryKey = (options: Options<GetCourseMediaData>) =>
  createQueryKey('getCourseMedia', options);

/**
 * Get course media by file name
 * Retrieves course media files (thumbnails, banners, intro videos) by their file name.
 * This endpoint serves the actual media files with appropriate content types and caching headers.
 *
 * **File Types Served:**
 * - Course thumbnails from course_thumbnails folder
 * - Course banners from course_banners folder
 * - Course intro videos from course_intro_videos folder
 *
 * **Response Features:**
 * - Automatic content type detection
 * - Optimized caching headers for performance
 * - Support for range requests (for videos)
 * - Proper file serving with inline disposition
 *
 * **Usage:**
 * - File names are typically returned from upload endpoints
 * - URLs are automatically generated and stored in course records
 * - Direct access via this endpoint for custom implementations
 *
 */
export const getCourseMediaOptions = (options: Options<GetCourseMediaData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getCourseMedia({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getCourseMediaQueryKey(options),
  });
};

export const searchLessonsQueryKey = (options: Options<SearchLessonsData>) =>
  createQueryKey('searchLessons', options);

/**
 * Search lessons
 * Search course lessons with advanced filtering.
 *
 * **Common Lesson Search Examples:**
 * - `courseUuid=uuid` - All lessons for specific course
 * - `status=PUBLISHED` - Only published lessons
 * - `active=true` - Only active lessons
 * - `lessonNumber_gte=5` - Lessons from lesson 5 onwards
 * - `title_like=introduction` - Lessons with "introduction" in title
 * - `durationHours_between=1,3` - Lessons between 1-3 hours
 *
 */
export const searchLessonsOptions = (options: Options<SearchLessonsData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await searchLessons({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: searchLessonsQueryKey(options),
  });
};

export const searchLessonsInfiniteQueryKey = (
  options: Options<SearchLessonsData>
): QueryKey<Options<SearchLessonsData>> => createQueryKey('searchLessons', options, true);

/**
 * Search lessons
 * Search course lessons with advanced filtering.
 *
 * **Common Lesson Search Examples:**
 * - `courseUuid=uuid` - All lessons for specific course
 * - `status=PUBLISHED` - Only published lessons
 * - `active=true` - Only active lessons
 * - `lessonNumber_gte=5` - Lessons from lesson 5 onwards
 * - `title_like=introduction` - Lessons with "introduction" in title
 * - `durationHours_between=1,3` - Lessons between 1-3 hours
 *
 */
export const searchLessonsInfiniteOptions = (options: Options<SearchLessonsData>) => {
  return infiniteQueryOptions<
    SearchLessonsResponse,
    SearchLessonsError,
    InfiniteData<SearchLessonsResponse>,
    QueryKey<Options<SearchLessonsData>>,
    number | Pick<QueryKey<Options<SearchLessonsData>>[0], 'body' | 'headers' | 'path' | 'query'>
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<SearchLessonsData>>[0],
          'body' | 'headers' | 'path' | 'query'
        > =
          typeof pageParam === 'object'
            ? pageParam
            : {
                query: {
                  page: pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await searchLessons({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: searchLessonsInfiniteQueryKey(options),
    }
  );
};

export const getCoursesByInstructorQueryKey = (options: Options<GetCoursesByInstructorData>) =>
  createQueryKey('getCoursesByInstructor', options);

/**
 * Get courses by instructor
 * Retrieves all courses created by a specific instructor.
 */
export const getCoursesByInstructorOptions = (options: Options<GetCoursesByInstructorData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getCoursesByInstructor({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getCoursesByInstructorQueryKey(options),
  });
};

export const getCoursesByInstructorInfiniteQueryKey = (
  options: Options<GetCoursesByInstructorData>
): QueryKey<Options<GetCoursesByInstructorData>> =>
  createQueryKey('getCoursesByInstructor', options, true);

/**
 * Get courses by instructor
 * Retrieves all courses created by a specific instructor.
 */
export const getCoursesByInstructorInfiniteOptions = (
  options: Options<GetCoursesByInstructorData>
) => {
  return infiniteQueryOptions<
    GetCoursesByInstructorResponse,
    GetCoursesByInstructorError,
    InfiniteData<GetCoursesByInstructorResponse>,
    QueryKey<Options<GetCoursesByInstructorData>>,
    | number
    | Pick<QueryKey<Options<GetCoursesByInstructorData>>[0], 'body' | 'headers' | 'path' | 'query'>
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<GetCoursesByInstructorData>>[0],
          'body' | 'headers' | 'path' | 'query'
        > =
          typeof pageParam === 'object'
            ? pageParam
            : {
                query: {
                  page: pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getCoursesByInstructor({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: getCoursesByInstructorInfiniteQueryKey(options),
    }
  );
};

export const searchEnrollmentsQueryKey = (options: Options<SearchEnrollmentsData>) =>
  createQueryKey('searchEnrollments', options);

/**
 * Search course enrollments
 * Search enrollment records across all courses.
 *
 * **Common Enrollment Search Examples:**
 * - `courseUuid=uuid` - All enrollments for specific course
 * - `studentUuid=uuid` - All enrollments for specific student
 * - `status=COMPLETED` - Only completed enrollments
 * - `progressPercentage_gte=80` - Students with 80%+ progress
 * - `enrollmentDate_gte=2024-01-01T00:00:00` - Enrollments from 2024
 *
 */
export const searchEnrollmentsOptions = (options: Options<SearchEnrollmentsData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await searchEnrollments({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: searchEnrollmentsQueryKey(options),
  });
};

export const searchEnrollmentsInfiniteQueryKey = (
  options: Options<SearchEnrollmentsData>
): QueryKey<Options<SearchEnrollmentsData>> => createQueryKey('searchEnrollments', options, true);

/**
 * Search course enrollments
 * Search enrollment records across all courses.
 *
 * **Common Enrollment Search Examples:**
 * - `courseUuid=uuid` - All enrollments for specific course
 * - `studentUuid=uuid` - All enrollments for specific student
 * - `status=COMPLETED` - Only completed enrollments
 * - `progressPercentage_gte=80` - Students with 80%+ progress
 * - `enrollmentDate_gte=2024-01-01T00:00:00` - Enrollments from 2024
 *
 */
export const searchEnrollmentsInfiniteOptions = (options: Options<SearchEnrollmentsData>) => {
  return infiniteQueryOptions<
    SearchEnrollmentsResponse,
    SearchEnrollmentsError,
    InfiniteData<SearchEnrollmentsResponse>,
    QueryKey<Options<SearchEnrollmentsData>>,
    | number
    | Pick<QueryKey<Options<SearchEnrollmentsData>>[0], 'body' | 'headers' | 'path' | 'query'>
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<SearchEnrollmentsData>>[0],
          'body' | 'headers' | 'path' | 'query'
        > =
          typeof pageParam === 'object'
            ? pageParam
            : {
                query: {
                  page: pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await searchEnrollments({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: searchEnrollmentsInfiniteQueryKey(options),
    }
  );
};

export const searchLessonContentQueryKey = (options: Options<SearchLessonContentData>) =>
  createQueryKey('searchLessonContent', options);

/**
 * Search lesson content
 * Search lesson content across all courses.
 *
 * **Common Content Search Examples:**
 * - `lessonUuid=uuid` - All content for specific lesson
 * - `contentTypeUuid=uuid` - Content of specific type
 * - `isRequired=true` - Only required content
 * - `title_like=video` - Content with "video" in title
 * - `fileSizeBytes_gt=1048576` - Files larger than 1MB
 *
 */
export const searchLessonContentOptions = (options: Options<SearchLessonContentData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await searchLessonContent({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: searchLessonContentQueryKey(options),
  });
};

export const searchLessonContentInfiniteQueryKey = (
  options: Options<SearchLessonContentData>
): QueryKey<Options<SearchLessonContentData>> =>
  createQueryKey('searchLessonContent', options, true);

/**
 * Search lesson content
 * Search lesson content across all courses.
 *
 * **Common Content Search Examples:**
 * - `lessonUuid=uuid` - All content for specific lesson
 * - `contentTypeUuid=uuid` - Content of specific type
 * - `isRequired=true` - Only required content
 * - `title_like=video` - Content with "video" in title
 * - `fileSizeBytes_gt=1048576` - Files larger than 1MB
 *
 */
export const searchLessonContentInfiniteOptions = (options: Options<SearchLessonContentData>) => {
  return infiniteQueryOptions<
    SearchLessonContentResponse,
    SearchLessonContentError,
    InfiniteData<SearchLessonContentResponse>,
    QueryKey<Options<SearchLessonContentData>>,
    | number
    | Pick<QueryKey<Options<SearchLessonContentData>>[0], 'body' | 'headers' | 'path' | 'query'>
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<SearchLessonContentData>>[0],
          'body' | 'headers' | 'path' | 'query'
        > =
          typeof pageParam === 'object'
            ? pageParam
            : {
                query: {
                  page: pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await searchLessonContent({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: searchLessonContentInfiniteQueryKey(options),
    }
  );
};

export const getCoursesByCategoryQueryKey = (options: Options<GetCoursesByCategoryData>) =>
  createQueryKey('getCoursesByCategory', options);

/**
 * Get courses by category
 * Retrieves all courses in a specific category.
 *
 * **Enhanced Category Search:**
 * This endpoint now supports the many-to-many relationship, returning courses that have
 * the specified category assigned to them, regardless of what other categories they may also have.
 *
 */
export const getCoursesByCategoryOptions = (options: Options<GetCoursesByCategoryData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getCoursesByCategory({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getCoursesByCategoryQueryKey(options),
  });
};

export const getCoursesByCategoryInfiniteQueryKey = (
  options: Options<GetCoursesByCategoryData>
): QueryKey<Options<GetCoursesByCategoryData>> =>
  createQueryKey('getCoursesByCategory', options, true);

/**
 * Get courses by category
 * Retrieves all courses in a specific category.
 *
 * **Enhanced Category Search:**
 * This endpoint now supports the many-to-many relationship, returning courses that have
 * the specified category assigned to them, regardless of what other categories they may also have.
 *
 */
export const getCoursesByCategoryInfiniteOptions = (options: Options<GetCoursesByCategoryData>) => {
  return infiniteQueryOptions<
    GetCoursesByCategoryResponse,
    GetCoursesByCategoryError,
    InfiniteData<GetCoursesByCategoryResponse>,
    QueryKey<Options<GetCoursesByCategoryData>>,
    | number
    | Pick<QueryKey<Options<GetCoursesByCategoryData>>[0], 'body' | 'headers' | 'path' | 'query'>
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<GetCoursesByCategoryData>>[0],
          'body' | 'headers' | 'path' | 'query'
        > =
          typeof pageParam === 'object'
            ? pageParam
            : {
                query: {
                  page: pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getCoursesByCategory({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: getCoursesByCategoryInfiniteQueryKey(options),
    }
  );
};

export const searchCategoryMappingsQueryKey = (options: Options<SearchCategoryMappingsData>) =>
  createQueryKey('searchCategoryMappings', options);

/**
 * Search course category mappings
 * Search course-category relationships.
 *
 * **Common Mapping Search Examples:**
 * - `courseUuid=uuid` - All category mappings for specific course
 * - `categoryUuid=uuid` - All course mappings for specific category
 * - `courseName_like=java` - Mappings for courses with "java" in name
 * - `categoryName_like=programming` - Mappings for categories with "programming" in name
 *
 */
export const searchCategoryMappingsOptions = (options: Options<SearchCategoryMappingsData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await searchCategoryMappings({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: searchCategoryMappingsQueryKey(options),
  });
};

export const searchCategoryMappingsInfiniteQueryKey = (
  options: Options<SearchCategoryMappingsData>
): QueryKey<Options<SearchCategoryMappingsData>> =>
  createQueryKey('searchCategoryMappings', options, true);

/**
 * Search course category mappings
 * Search course-category relationships.
 *
 * **Common Mapping Search Examples:**
 * - `courseUuid=uuid` - All category mappings for specific course
 * - `categoryUuid=uuid` - All course mappings for specific category
 * - `courseName_like=java` - Mappings for courses with "java" in name
 * - `categoryName_like=programming` - Mappings for categories with "programming" in name
 *
 */
export const searchCategoryMappingsInfiniteOptions = (
  options: Options<SearchCategoryMappingsData>
) => {
  return infiniteQueryOptions<
    SearchCategoryMappingsResponse,
    SearchCategoryMappingsError,
    InfiniteData<SearchCategoryMappingsResponse>,
    QueryKey<Options<SearchCategoryMappingsData>>,
    | number
    | Pick<QueryKey<Options<SearchCategoryMappingsData>>[0], 'body' | 'headers' | 'path' | 'query'>
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<SearchCategoryMappingsData>>[0],
          'body' | 'headers' | 'path' | 'query'
        > =
          typeof pageParam === 'object'
            ? pageParam
            : {
                query: {
                  page: pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await searchCategoryMappings({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: searchCategoryMappingsInfiniteQueryKey(options),
    }
  );
};

export const searchAssessmentsQueryKey = (options: Options<SearchAssessmentsData>) =>
  createQueryKey('searchAssessments', options);

/**
 * Search course assessments
 * Search assessments across all courses.
 *
 * **Common Assessment Search Examples:**
 * - `courseUuid=uuid` - All assessments for specific course
 * - `assessmentType=QUIZ` - Only quiz assessments
 * - `isRequired=true` - Only required assessments
 * - `weightPercentage_gte=20` - Assessments worth 20% or more
 *
 */
export const searchAssessmentsOptions = (options: Options<SearchAssessmentsData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await searchAssessments({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: searchAssessmentsQueryKey(options),
  });
};

export const searchAssessmentsInfiniteQueryKey = (
  options: Options<SearchAssessmentsData>
): QueryKey<Options<SearchAssessmentsData>> => createQueryKey('searchAssessments', options, true);

/**
 * Search course assessments
 * Search assessments across all courses.
 *
 * **Common Assessment Search Examples:**
 * - `courseUuid=uuid` - All assessments for specific course
 * - `assessmentType=QUIZ` - Only quiz assessments
 * - `isRequired=true` - Only required assessments
 * - `weightPercentage_gte=20` - Assessments worth 20% or more
 *
 */
export const searchAssessmentsInfiniteOptions = (options: Options<SearchAssessmentsData>) => {
  return infiniteQueryOptions<
    SearchAssessmentsResponse,
    SearchAssessmentsError,
    InfiniteData<SearchAssessmentsResponse>,
    QueryKey<Options<SearchAssessmentsData>>,
    | number
    | Pick<QueryKey<Options<SearchAssessmentsData>>[0], 'body' | 'headers' | 'path' | 'query'>
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<SearchAssessmentsData>>[0],
          'body' | 'headers' | 'path' | 'query'
        > =
          typeof pageParam === 'object'
            ? pageParam
            : {
                query: {
                  page: pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await searchAssessments({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: searchAssessmentsInfiniteQueryKey(options),
    }
  );
};

export const getActiveCoursesQueryKey = (options?: Options<GetActiveCoursesData>) =>
  createQueryKey('getActiveCourses', options);

/**
 * Get active courses
 * Retrieves all currently active and published courses.
 */
export const getActiveCoursesOptions = (options?: Options<GetActiveCoursesData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getActiveCourses({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getActiveCoursesQueryKey(options),
  });
};

export const getActiveCoursesInfiniteQueryKey = (
  options?: Options<GetActiveCoursesData>
): QueryKey<Options<GetActiveCoursesData>> => createQueryKey('getActiveCourses', options, true);

/**
 * Get active courses
 * Retrieves all currently active and published courses.
 */
export const getActiveCoursesInfiniteOptions = (options?: Options<GetActiveCoursesData>) => {
  return infiniteQueryOptions<
    GetActiveCoursesResponse,
    GetActiveCoursesError,
    InfiniteData<GetActiveCoursesResponse>,
    QueryKey<Options<GetActiveCoursesData>>,
    number | Pick<QueryKey<Options<GetActiveCoursesData>>[0], 'body' | 'headers' | 'path' | 'query'>
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<GetActiveCoursesData>>[0],
          'body' | 'headers' | 'path' | 'query'
        > =
          typeof pageParam === 'object'
            ? pageParam
            : {
                query: {
                  page: pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getActiveCourses({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: getActiveCoursesInfiniteQueryKey(options),
    }
  );
};

export const searchContentTypesQueryKey = (options: Options<SearchContentTypesData>) =>
  createQueryKey('searchContentTypes', options);

/**
 * Search content types
 * Search content types with filtering options.
 *
 * **Common Content Type Search Examples:**
 * - `name_like=video` - Content types with "video" in name
 * - `mimeTypes_like=image/` - Image content types
 * - `maxFileSizeMb_gte=100` - Large file content types
 *
 */
export const searchContentTypesOptions = (options: Options<SearchContentTypesData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await searchContentTypes({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: searchContentTypesQueryKey(options),
  });
};

export const searchContentTypesInfiniteQueryKey = (
  options: Options<SearchContentTypesData>
): QueryKey<Options<SearchContentTypesData>> => createQueryKey('searchContentTypes', options, true);

/**
 * Search content types
 * Search content types with filtering options.
 *
 * **Common Content Type Search Examples:**
 * - `name_like=video` - Content types with "video" in name
 * - `mimeTypes_like=image/` - Image content types
 * - `maxFileSizeMb_gte=100` - Large file content types
 *
 */
export const searchContentTypesInfiniteOptions = (options: Options<SearchContentTypesData>) => {
  return infiniteQueryOptions<
    SearchContentTypesResponse,
    SearchContentTypesError,
    InfiniteData<SearchContentTypesResponse>,
    QueryKey<Options<SearchContentTypesData>>,
    | number
    | Pick<QueryKey<Options<SearchContentTypesData>>[0], 'body' | 'headers' | 'path' | 'query'>
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<SearchContentTypesData>>[0],
          'body' | 'headers' | 'path' | 'query'
        > =
          typeof pageParam === 'object'
            ? pageParam
            : {
                query: {
                  page: pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await searchContentTypes({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: searchContentTypesInfiniteQueryKey(options),
    }
  );
};

export const checkMimeTypeSupportQueryKey = (options: Options<CheckMimeTypeSupportData>) =>
  createQueryKey('checkMimeTypeSupport', options);

/**
 * Check MIME type support
 * Checks if a specific MIME type is supported by the system.
 */
export const checkMimeTypeSupportOptions = (options: Options<CheckMimeTypeSupportData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await checkMimeTypeSupport({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: checkMimeTypeSupportQueryKey(options),
  });
};

export const getMediaContentTypesQueryKey = (options?: Options<GetMediaContentTypesData>) =>
  createQueryKey('getMediaContentTypes', options);

/**
 * Get media content types
 * Retrieves content types for media files (video, audio, images).
 */
export const getMediaContentTypesOptions = (options?: Options<GetMediaContentTypesData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getMediaContentTypes({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getMediaContentTypesQueryKey(options),
  });
};

export const getSubCategoriesQueryKey = (options: Options<GetSubCategoriesData>) =>
  createQueryKey('getSubCategories', options);

/**
 * Get subcategories
 * Retrieves all subcategories for a specific parent category.
 */
export const getSubCategoriesOptions = (options: Options<GetSubCategoriesData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getSubCategories({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getSubCategoriesQueryKey(options),
  });
};

export const searchCategoriesQueryKey = (options: Options<SearchCategoriesData>) =>
  createQueryKey('searchCategories', options);

/**
 * Search categories
 * Search categories with filtering options.
 *
 * **Common Category Search Examples:**
 * - `name_like=technology` - Categories with "technology" in name
 * - `parentUuid=null` - Root categories only
 * - `parentUuid=uuid` - Subcategories of specific parent
 * - `isActive=true` - Only active categories
 *
 */
export const searchCategoriesOptions = (options: Options<SearchCategoriesData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await searchCategories({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: searchCategoriesQueryKey(options),
  });
};

export const searchCategoriesInfiniteQueryKey = (
  options: Options<SearchCategoriesData>
): QueryKey<Options<SearchCategoriesData>> => createQueryKey('searchCategories', options, true);

/**
 * Search categories
 * Search categories with filtering options.
 *
 * **Common Category Search Examples:**
 * - `name_like=technology` - Categories with "technology" in name
 * - `parentUuid=null` - Root categories only
 * - `parentUuid=uuid` - Subcategories of specific parent
 * - `isActive=true` - Only active categories
 *
 */
export const searchCategoriesInfiniteOptions = (options: Options<SearchCategoriesData>) => {
  return infiniteQueryOptions<
    SearchCategoriesResponse,
    SearchCategoriesError,
    InfiniteData<SearchCategoriesResponse>,
    QueryKey<Options<SearchCategoriesData>>,
    number | Pick<QueryKey<Options<SearchCategoriesData>>[0], 'body' | 'headers' | 'path' | 'query'>
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<SearchCategoriesData>>[0],
          'body' | 'headers' | 'path' | 'query'
        > =
          typeof pageParam === 'object'
            ? pageParam
            : {
                query: {
                  page: pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await searchCategories({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: searchCategoriesInfiniteQueryKey(options),
    }
  );
};

export const getRootCategoriesQueryKey = (options?: Options<GetRootCategoriesData>) =>
  createQueryKey('getRootCategories', options);

/**
 * Get root categories
 * Retrieves all top-level categories (no parent).
 */
export const getRootCategoriesOptions = (options?: Options<GetRootCategoriesData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getRootCategories({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getRootCategoriesQueryKey(options),
  });
};

export const verifyCertificateQueryKey = (options: Options<VerifyCertificateData>) =>
  createQueryKey('verifyCertificate', options);

/**
 * Verify certificate
 * Verifies the authenticity of a certificate using its certificate number.
 */
export const verifyCertificateOptions = (options: Options<VerifyCertificateData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await verifyCertificate({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: verifyCertificateQueryKey(options),
  });
};

export const searchCertificateTemplatesQueryKey = (
  options: Options<SearchCertificateTemplatesData>
) => createQueryKey('searchCertificateTemplates', options);

/**
 * Search certificate templates
 * Search certificate templates with filtering.
 *
 * **Common Template Search Examples:**
 * - `templateType=COURSE` - Course certificate templates
 * - `templateType=PROGRAM` - Program certificate templates
 * - `status=PUBLISHED` - Published templates
 * - `active=true` - Active templates
 * - `name_like=modern` - Templates with "modern" in name
 *
 */
export const searchCertificateTemplatesOptions = (
  options: Options<SearchCertificateTemplatesData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await searchCertificateTemplates({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: searchCertificateTemplatesQueryKey(options),
  });
};

export const searchCertificateTemplatesInfiniteQueryKey = (
  options: Options<SearchCertificateTemplatesData>
): QueryKey<Options<SearchCertificateTemplatesData>> =>
  createQueryKey('searchCertificateTemplates', options, true);

/**
 * Search certificate templates
 * Search certificate templates with filtering.
 *
 * **Common Template Search Examples:**
 * - `templateType=COURSE` - Course certificate templates
 * - `templateType=PROGRAM` - Program certificate templates
 * - `status=PUBLISHED` - Published templates
 * - `active=true` - Active templates
 * - `name_like=modern` - Templates with "modern" in name
 *
 */
export const searchCertificateTemplatesInfiniteOptions = (
  options: Options<SearchCertificateTemplatesData>
) => {
  return infiniteQueryOptions<
    SearchCertificateTemplatesResponse,
    SearchCertificateTemplatesError,
    InfiniteData<SearchCertificateTemplatesResponse>,
    QueryKey<Options<SearchCertificateTemplatesData>>,
    | number
    | Pick<
        QueryKey<Options<SearchCertificateTemplatesData>>[0],
        'body' | 'headers' | 'path' | 'query'
      >
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<SearchCertificateTemplatesData>>[0],
          'body' | 'headers' | 'path' | 'query'
        > =
          typeof pageParam === 'object'
            ? pageParam
            : {
                query: {
                  page: pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await searchCertificateTemplates({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: searchCertificateTemplatesInfiniteQueryKey(options),
    }
  );
};

export const getStudentCertificatesQueryKey = (options: Options<GetStudentCertificatesData>) =>
  createQueryKey('getStudentCertificates', options);

/**
 * Get student certificates
 * Retrieves all certificates earned by a specific student.
 */
export const getStudentCertificatesOptions = (options: Options<GetStudentCertificatesData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getStudentCertificates({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getStudentCertificatesQueryKey(options),
  });
};

export const getDownloadableCertificatesQueryKey = (
  options: Options<GetDownloadableCertificatesData>
) => createQueryKey('getDownloadableCertificates', options);

/**
 * Get downloadable certificates
 * Retrieves all valid certificates available for download by a student.
 */
export const getDownloadableCertificatesOptions = (
  options: Options<GetDownloadableCertificatesData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getDownloadableCertificates({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getDownloadableCertificatesQueryKey(options),
  });
};

export const searchCertificatesQueryKey = (options: Options<SearchCertificatesData>) =>
  createQueryKey('searchCertificates', options);

/**
 * Search certificates
 * Advanced certificate search with flexible criteria and operators.
 *
 * **Common Certificate Search Examples:**
 * - `studentUuid=uuid` - All certificates for specific student
 * - `courseUuid=uuid` - All certificates for specific course
 * - `programUuid=uuid` - All certificates for specific program
 * - `isValid=true` - Only valid certificates
 * - `isValid=false` - Only revoked certificates
 * - `finalGrade_gte=85` - Certificates with grade 85%+
 * - `issuedDate_gte=2024-01-01T00:00:00` - Certificates issued from 2024
 * - `certificateNumber_like=CERT-2024` - Certificates from 2024
 *
 * **Certificate Analytics Queries:**
 * - `courseUuid_noteq=null&isValid=true` - Valid course certificates
 * - `programUuid_noteq=null&isValid=true` - Valid program certificates
 * - `finalGrade_between=80,100&isValid=true` - High-grade valid certificates
 *
 */
export const searchCertificatesOptions = (options: Options<SearchCertificatesData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await searchCertificates({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: searchCertificatesQueryKey(options),
  });
};

export const searchCertificatesInfiniteQueryKey = (
  options: Options<SearchCertificatesData>
): QueryKey<Options<SearchCertificatesData>> => createQueryKey('searchCertificates', options, true);

/**
 * Search certificates
 * Advanced certificate search with flexible criteria and operators.
 *
 * **Common Certificate Search Examples:**
 * - `studentUuid=uuid` - All certificates for specific student
 * - `courseUuid=uuid` - All certificates for specific course
 * - `programUuid=uuid` - All certificates for specific program
 * - `isValid=true` - Only valid certificates
 * - `isValid=false` - Only revoked certificates
 * - `finalGrade_gte=85` - Certificates with grade 85%+
 * - `issuedDate_gte=2024-01-01T00:00:00` - Certificates issued from 2024
 * - `certificateNumber_like=CERT-2024` - Certificates from 2024
 *
 * **Certificate Analytics Queries:**
 * - `courseUuid_noteq=null&isValid=true` - Valid course certificates
 * - `programUuid_noteq=null&isValid=true` - Valid program certificates
 * - `finalGrade_between=80,100&isValid=true` - High-grade valid certificates
 *
 */
export const searchCertificatesInfiniteOptions = (options: Options<SearchCertificatesData>) => {
  return infiniteQueryOptions<
    SearchCertificatesResponse,
    SearchCertificatesError,
    InfiniteData<SearchCertificatesResponse>,
    QueryKey<Options<SearchCertificatesData>>,
    | number
    | Pick<QueryKey<Options<SearchCertificatesData>>[0], 'body' | 'headers' | 'path' | 'query'>
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<SearchCertificatesData>>[0],
          'body' | 'headers' | 'path' | 'query'
        > =
          typeof pageParam === 'object'
            ? pageParam
            : {
                query: {
                  page: pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await searchCertificates({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: searchCertificatesInfiniteQueryKey(options),
    }
  );
};

export const getRevokedCertificatesQueryKey = (options?: Options<GetRevokedCertificatesData>) =>
  createQueryKey('getRevokedCertificates', options);

/**
 * Get revoked certificates
 * Retrieves all revoked certificates for administrative review.
 */
export const getRevokedCertificatesOptions = (options?: Options<GetRevokedCertificatesData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getRevokedCertificates({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getRevokedCertificatesQueryKey(options),
  });
};

export const getProgramCertificates1QueryKey = (options?: Options<GetProgramCertificates1Data>) =>
  createQueryKey('getProgramCertificates1', options);

/**
 * Get program certificates
 * Retrieves all certificates issued for program completions.
 */
export const getProgramCertificates1Options = (options?: Options<GetProgramCertificates1Data>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getProgramCertificates1({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getProgramCertificates1QueryKey(options),
  });
};

export const getCertificateByNumberQueryKey = (options: Options<GetCertificateByNumberData>) =>
  createQueryKey('getCertificateByNumber', options);

/**
 * Get certificate by number
 * Retrieves certificate details using certificate number for public verification.
 */
export const getCertificateByNumberOptions = (options: Options<GetCertificateByNumberData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getCertificateByNumber({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getCertificateByNumberQueryKey(options),
  });
};

export const getCourseCertificatesQueryKey = (options?: Options<GetCourseCertificatesData>) =>
  createQueryKey('getCourseCertificates', options);

/**
 * Get course certificates
 * Retrieves all certificates issued for course completions.
 */
export const getCourseCertificatesOptions = (options?: Options<GetCourseCertificatesData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getCourseCertificates({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getCourseCertificatesQueryKey(options),
  });
};

export const getAssignmentSubmissionsQueryKey = (options: Options<GetAssignmentSubmissionsData>) =>
  createQueryKey('getAssignmentSubmissions', options);

/**
 * Get assignment submissions
 * Retrieves all submissions for a specific assignment.
 */
export const getAssignmentSubmissionsOptions = (options: Options<GetAssignmentSubmissionsData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getAssignmentSubmissions({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getAssignmentSubmissionsQueryKey(options),
  });
};

export const getHighPerformanceSubmissionsQueryKey = (
  options: Options<GetHighPerformanceSubmissionsData>
) => createQueryKey('getHighPerformanceSubmissions', options);

/**
 * Get high performance submissions
 * Returns submissions with scores above 85%.
 */
export const getHighPerformanceSubmissionsOptions = (
  options: Options<GetHighPerformanceSubmissionsData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getHighPerformanceSubmissions({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getHighPerformanceSubmissionsQueryKey(options),
  });
};

export const getAverageScoreQueryKey = (options: Options<GetAverageScoreData>) =>
  createQueryKey('getAverageScore', options);

/**
 * Get average submission score
 * Returns the average score for all graded submissions of an assignment.
 */
export const getAverageScoreOptions = (options: Options<GetAverageScoreData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getAverageScore({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getAverageScoreQueryKey(options),
  });
};

export const getSubmissionAnalyticsQueryKey = (options: Options<GetSubmissionAnalyticsData>) =>
  createQueryKey('getSubmissionAnalytics', options);

/**
 * Get submission analytics
 * Returns analytics data for assignment submissions including category distribution.
 */
export const getSubmissionAnalyticsOptions = (options: Options<GetSubmissionAnalyticsData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getSubmissionAnalytics({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getSubmissionAnalyticsQueryKey(options),
  });
};

export const searchSubmissionsQueryKey = (options: Options<SearchSubmissionsData>) =>
  createQueryKey('searchSubmissions', options);

/**
 * Search assignment submissions
 * Search submissions across all assignments.
 *
 * **Common Submission Search Examples:**
 * - `assignmentUuid=uuid` - All submissions for specific assignment
 * - `enrollmentUuid=uuid` - All submissions by specific student
 * - `status=GRADED` - Only graded submissions
 * - `percentage_gte=90` - Submissions with 90%+ score
 * - `submittedAt_gte=2024-01-01T00:00:00` - Submissions from 2024
 * - `gradedByUuid=uuid` - Submissions graded by specific instructor
 *
 */
export const searchSubmissionsOptions = (options: Options<SearchSubmissionsData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await searchSubmissions({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: searchSubmissionsQueryKey(options),
  });
};

export const searchSubmissionsInfiniteQueryKey = (
  options: Options<SearchSubmissionsData>
): QueryKey<Options<SearchSubmissionsData>> => createQueryKey('searchSubmissions', options, true);

/**
 * Search assignment submissions
 * Search submissions across all assignments.
 *
 * **Common Submission Search Examples:**
 * - `assignmentUuid=uuid` - All submissions for specific assignment
 * - `enrollmentUuid=uuid` - All submissions by specific student
 * - `status=GRADED` - Only graded submissions
 * - `percentage_gte=90` - Submissions with 90%+ score
 * - `submittedAt_gte=2024-01-01T00:00:00` - Submissions from 2024
 * - `gradedByUuid=uuid` - Submissions graded by specific instructor
 *
 */
export const searchSubmissionsInfiniteOptions = (options: Options<SearchSubmissionsData>) => {
  return infiniteQueryOptions<
    SearchSubmissionsResponse,
    SearchSubmissionsError,
    InfiniteData<SearchSubmissionsResponse>,
    QueryKey<Options<SearchSubmissionsData>>,
    | number
    | Pick<QueryKey<Options<SearchSubmissionsData>>[0], 'body' | 'headers' | 'path' | 'query'>
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<SearchSubmissionsData>>[0],
          'body' | 'headers' | 'path' | 'query'
        > =
          typeof pageParam === 'object'
            ? pageParam
            : {
                query: {
                  page: pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await searchSubmissions({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: searchSubmissionsInfiniteQueryKey(options),
    }
  );
};

export const searchAssignmentsQueryKey = (options: Options<SearchAssignmentsData>) =>
  createQueryKey('searchAssignments', options);

/**
 * Search assignments
 * Advanced assignment search with flexible criteria and operators.
 *
 * **Common Assignment Search Examples:**
 * - `title_like=essay` - Assignments with "essay" in title
 * - `lessonUuid=uuid` - Assignments for specific lesson
 * - `status=PUBLISHED` - Only published assignments
 * - `active=true` - Only active assignments
 * - `dueDate_gte=2024-12-01T00:00:00` - Assignments due from Dec 1, 2024
 * - `maxPoints_gte=50` - Assignments worth 50+ points
 *
 */
export const searchAssignmentsOptions = (options: Options<SearchAssignmentsData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await searchAssignments({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: searchAssignmentsQueryKey(options),
  });
};

export const searchAssignmentsInfiniteQueryKey = (
  options: Options<SearchAssignmentsData>
): QueryKey<Options<SearchAssignmentsData>> => createQueryKey('searchAssignments', options, true);

/**
 * Search assignments
 * Advanced assignment search with flexible criteria and operators.
 *
 * **Common Assignment Search Examples:**
 * - `title_like=essay` - Assignments with "essay" in title
 * - `lessonUuid=uuid` - Assignments for specific lesson
 * - `status=PUBLISHED` - Only published assignments
 * - `active=true` - Only active assignments
 * - `dueDate_gte=2024-12-01T00:00:00` - Assignments due from Dec 1, 2024
 * - `maxPoints_gte=50` - Assignments worth 50+ points
 *
 */
export const searchAssignmentsInfiniteOptions = (options: Options<SearchAssignmentsData>) => {
  return infiniteQueryOptions<
    SearchAssignmentsResponse,
    SearchAssignmentsError,
    InfiniteData<SearchAssignmentsResponse>,
    QueryKey<Options<SearchAssignmentsData>>,
    | number
    | Pick<QueryKey<Options<SearchAssignmentsData>>[0], 'body' | 'headers' | 'path' | 'query'>
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<SearchAssignmentsData>>[0],
          'body' | 'headers' | 'path' | 'query'
        > =
          typeof pageParam === 'object'
            ? pageParam
            : {
                query: {
                  page: pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await searchAssignments({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: searchAssignmentsInfiniteQueryKey(options),
    }
  );
};

export const getPendingGradingQueryKey = (options: Options<GetPendingGradingData>) =>
  createQueryKey('getPendingGrading', options);

/**
 * Get pending grading
 * Retrieves all submissions pending grading for a specific instructor.
 */
export const getPendingGradingOptions = (options: Options<GetPendingGradingData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getPendingGrading({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getPendingGradingQueryKey(options),
  });
};

/**
 * Cancel pending invitation
 * Cancels a pending invitation within this organization, preventing it from being accepted or declined. Only the original inviter or an organization administrator can cancel invitations. This action is irreversible and the invitation cannot be reactivated.
 */
export const cancelInvitationMutation = (
  options?: Partial<Options<CancelInvitationData>>
): UseMutationOptions<
  CancelInvitationResponse,
  CancelInvitationError,
  Options<CancelInvitationData>
> => {
  const mutationOptions: UseMutationOptions<
    CancelInvitationResponse,
    CancelInvitationError,
    Options<CancelInvitationData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await cancelInvitation({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Cleanup old invitations
 * System maintenance endpoint to delete old invitations that are expired, declined, or cancelled. This helps maintain database cleanliness by removing old invitation records.
 */
export const cleanupOldInvitationsMutation = (
  options?: Partial<Options<CleanupOldInvitationsData>>
): UseMutationOptions<
  CleanupOldInvitationsResponse,
  CleanupOldInvitationsError,
  Options<CleanupOldInvitationsData>
> => {
  const mutationOptions: UseMutationOptions<
    CleanupOldInvitationsResponse,
    CleanupOldInvitationsError,
    Options<CleanupOldInvitationsData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await cleanupOldInvitations({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Remove category from course
 * Removes a specific category from a course without affecting other categories.
 */
export const removeCategoryFromCourseMutation = (
  options?: Partial<Options<RemoveCategoryFromCourseData>>
): UseMutationOptions<
  RemoveCategoryFromCourseResponse,
  RemoveCategoryFromCourseError,
  Options<RemoveCategoryFromCourseData>
> => {
  const mutationOptions: UseMutationOptions<
    RemoveCategoryFromCourseResponse,
    RemoveCategoryFromCourseError,
    Options<RemoveCategoryFromCourseData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await removeCategoryFromCourse({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};
