// This file is auto-generated by @hey-api/openapi-ts

import { z } from 'zod';

export const zResponseDtoVoid = z.object({
  data: z.record(z.unknown()).optional(),
  status: z.number().int().optional(),
  message: z.string().optional(),
  errors: z.record(z.string()).optional(),
  timestamp: z.string().datetime().optional(),
});

/**
 * **[OPTIONAL]** User's gender information. Used for demographic analytics and personalization. Can be null if not specified or preferred not to disclose.
 */
export const zGenderEnum = z
  .enum(['MALE', 'FEMALE', 'OTHER', 'PREFER_NOT_TO_SAY'])
  .describe(
    "**[OPTIONAL]** User's gender information. Used for demographic analytics and personalization. Can be null if not specified or preferred not to disclose."
  );

/**
 * **[READ-ONLY]** List of domain roles that define the user's functional areas within the system. Determines available features and workflows. Can contain multiple values.
 */
export const zUserDomainEnum = z
  .enum(['student', 'instructor', 'admin', 'organisation_user', 'course_creator'])
  .describe(
    "**[READ-ONLY]** List of domain roles that define the user's functional areas within the system. Determines available features and workflows. Can contain multiple values."
  );

export const zUserOrganisationAffiliationDto = z.object({
  organisation_uuid: z.string().uuid().optional(),
  organisation_name: z.string().optional(),
  domain_in_organisation: z.string().optional(),
  branch_uuid: z.string().uuid().optional(),
  branch_name: z.string().optional(),
  start_date: z.string().date().optional(),
  end_date: z.string().date().optional(),
  active: z.boolean().optional(),
  affiliated_date: z.string().datetime().optional(),
});

/**
 * Complete user profile information including personal details, authentication, and organizational data
 */
export const zUser = z
  .object({
    uuid: z
      .string()
      .uuid()
      .describe(
        '**[READ-ONLY]** Unique system identifier for the user. Auto-generated by the system and cannot be modified.'
      )
      .readonly()
      .optional(),
    first_name: z
      .string()
      .min(0)
      .max(50)
      .describe(
        "**[REQUIRED]** User's given/first name. Used for display purposes and official documentation. Must not be blank."
      ),
    middle_name: z
      .string()
      .min(0)
      .max(50)
      .describe(
        "**[OPTIONAL]** User's middle name or initial. Can be null or empty if not applicable."
      )
      .optional(),
    last_name: z
      .string()
      .min(0)
      .max(50)
      .describe(
        "**[REQUIRED]** User's family/last name. Used for display purposes and official documentation. Must not be blank."
      ),
    email: z
      .string()
      .email()
      .min(0)
      .max(100)
      .describe(
        "**[REQUIRED]** User's primary email address. Must be unique across the system and follow valid email format. Used for authentication and notifications."
      ),
    username: z
      .string()
      .min(0)
      .max(50)
      .describe(
        '**[REQUIRED]** Unique username for system login. Must be unique across the system and cannot be changed after account creation.'
      ),
    dob: z
      .string()
      .date()
      .describe(
        "**[REQUIRED]** User's date of birth in ISO 8601 format (YYYY-MM-DD). Used for age verification and personalization features."
      ),
    phone_number: z
      .string()
      .min(0)
      .max(20)
      .regex(/^(\+254|0)?[17]\d{8}$/)
      .describe(
        "**[REQUIRED]** User's contact phone number. Should include country code for international numbers. Used for notifications and verification."
      ),
    active: z
      .boolean()
      .describe(
        '**[REQUIRED]** Indicates whether the user account is active and can access the system. Inactive users cannot log in or perform any operations.'
      ),
    keycloak_id: z
      .string()
      .min(0)
      .max(255)
      .describe(
        '**[OPTIONAL]** Keycloak user identifier for authentication integration. Links the user to their Keycloak identity for SSO functionality.'
      )
      .optional(),
    gender: zGenderEnum.optional(),
    user_domain: zUserDomainEnum.optional(),
    profile_image_url: z
      .string()
      .url()
      .describe(
        "**[READ-ONLY]** URL to the user's profile image/avatar. Automatically generated after image upload and cannot be directly modified."
      )
      .readonly()
      .optional(),
    created_date: z
      .string()
      .datetime()
      .describe(
        '**[READ-ONLY]** Timestamp when the user account was first created. Automatically set by the system and cannot be modified.'
      )
      .readonly()
      .optional(),
    updated_date: z
      .string()
      .datetime()
      .describe(
        '**[READ-ONLY]** Timestamp when the user account was last modified. Automatically updated by the system on any changes and cannot be directly modified.'
      )
      .readonly()
      .optional(),
    created_by: z
      .string()
      .describe(
        '**[READ-ONLY]** Identifier of the user who created this account. Automatically set by the system for audit purposes.'
      )
      .readonly()
      .optional(),
    updated_by: z
      .string()
      .describe(
        '**[READ-ONLY]** Identifier of the user who last updated this account. Automatically set by the system for audit purposes.'
      )
      .readonly()
      .optional(),
    organisation_affiliations: z
      .array(zUserOrganisationAffiliationDto)
      .describe(
        "**[READ-ONLY]** List of organization affiliations showing the user's specific roles within each organization they belong to. Includes organization details, branch assignments, and temporal information."
      )
      .readonly()
      .optional(),
    display_name: z
      .string()
      .describe(
        "**[READ-ONLY]** User's display name for UI purposes, consisting of first name and last name only (excludes middle name). Automatically computed from name components."
      )
      .readonly()
      .optional(),
    full_name: z
      .string()
      .describe(
        "**[READ-ONLY]** User's complete full name including first, middle (if present), and last names concatenated together. Automatically computed from individual name components."
      )
      .readonly()
      .optional(),
  })
  .describe(
    'Complete user profile information including personal details, authentication, and organizational data'
  );

export const zApiResponseUser = z.object({
  success: z.boolean().optional(),
  data: zUser.optional(),
  message: z.string().optional(),
  error: z.record(z.unknown()).optional(),
});

/**
 * Training branch information including location details and point of contact
 */
export const zTrainingBranch = z
  .object({
    uuid: z
      .string()
      .uuid()
      .describe(
        '**[READ-ONLY]** Unique system identifier for the training branch. Auto-generated by the system and cannot be modified.'
      )
      .readonly()
      .optional(),
    organisation_uuid: z
      .string()
      .uuid()
      .describe('**[REQUIRED]** UUID of the parent organisation this branch belongs to.'),
    branch_name: z
      .string()
      .min(0)
      .max(200)
      .describe('**[REQUIRED]** Name of the training branch or location. Must not be blank.'),
    address: z
      .string()
      .describe('**[OPTIONAL]** Physical address of the training branch.')
      .optional(),
    poc_name: z
      .string()
      .min(0)
      .max(200)
      .describe('**[REQUIRED]** Name of the point of contact for this branch.'),
    poc_email: z
      .string()
      .max(320)
      .describe('**[REQUIRED]** Email address of the point of contact for this branch.'),
    poc_telephone: z
      .string()
      .max(20)
      .regex(/^(\+254|0)?\d{8,9}$/)
      .describe('**[REQUIRED]** Telephone number of the point of contact for this branch.'),
    active: z
      .boolean()
      .describe('**[REQUIRED]** Indicates whether the training branch is active and operational.'),
    created_date: z
      .string()
      .datetime()
      .describe(
        '**[READ-ONLY]** Timestamp when the training branch was first created. Automatically set by the system and cannot be modified.'
      )
      .readonly()
      .optional(),
    updated_date: z
      .string()
      .datetime()
      .describe(
        '**[READ-ONLY]** Timestamp when the training branch was last updated. Automatically updated by the system on any changes and cannot be directly modified.'
      )
      .readonly()
      .optional(),
  })
  .describe('Training branch information including location details and point of contact');

export const zApiResponseTrainingBranch = z.object({
  success: z.boolean().optional(),
  data: zTrainingBranch.optional(),
  message: z.string().optional(),
  error: z.record(z.unknown()).optional(),
});

/**
 * Student profile information including guardian contacts and academic details. Links to a base user account.
 */
export const zStudent = z
  .object({
    uuid: z
      .string()
      .uuid()
      .describe(
        '**[READ-ONLY]** Unique system identifier for the student profile. Auto-generated by the system.'
      )
      .readonly()
      .optional(),
    user_uuid: z
      .string()
      .uuid()
      .describe(
        '**[REQUIRED]** Reference to the base user account UUID. Links student profile to user authentication and personal details.'
      ),
    first_guardian_name: z
      .string()
      .min(0)
      .max(100)
      .describe(
        '**[OPTIONAL]** Full name of the primary guardian/parent. This is the main emergency contact for the student.'
      )
      .optional(),
    first_guardian_mobile: z
      .string()
      .min(0)
      .max(20)
      .regex(/^(\+254|0)?[17]\d{8}$/)
      .describe(
        '**[OPTIONAL]** Mobile phone number of the primary guardian. Used for emergency contacts and notifications. Should include country code.'
      )
      .optional(),
    second_guardian_name: z
      .string()
      .min(0)
      .max(100)
      .describe(
        '**[OPTIONAL]** Full name of the secondary guardian/parent. Additional emergency contact for the student.'
      )
      .optional(),
    second_guardian_mobile: z
      .string()
      .min(0)
      .max(20)
      .regex(/^(\+254|0)?[17]\d{8}$/)
      .describe(
        '**[OPTIONAL]** Mobile phone number of the secondary guardian. Alternative contact for emergencies and notifications. Should include country code.'
      )
      .optional(),
    primaryGuardianContact: z.string().optional(),
    allGuardianContacts: z.array(z.string()).optional(),
    secondaryGuardianContact: z.string().optional(),
    created_date: z
      .string()
      .datetime()
      .describe(
        '**[READ-ONLY]** Timestamp when the student profile was first created. Automatically set by the system.'
      )
      .readonly()
      .optional(),
    created_by: z
      .string()
      .describe(
        '**[READ-ONLY]** Email or username of the user who created this student profile. Used for audit trails.'
      )
      .readonly()
      .optional(),
    updated_date: z
      .string()
      .datetime()
      .describe(
        '**[READ-ONLY]** Timestamp when the student profile was last modified. Automatically updated by the system on any changes.'
      )
      .readonly()
      .optional(),
    updated_by: z
      .string()
      .describe(
        '**[READ-ONLY]** Email or username of the user who last modified this student profile. Used for audit trails.'
      )
      .readonly()
      .optional(),
  })
  .describe(
    'Student profile information including guardian contacts and academic details. Links to a base user account.'
  );

/**
 * **[REQUIRED]** Rubric publication status in the content workflow.
 */
export const zStatusEnum = z
  .enum(['DRAFT', 'IN_REVIEW', 'PUBLISHED', 'ARCHIVED'])
  .describe('**[REQUIRED]** Rubric publication status in the content workflow.');

/**
 * **[OPTIONAL]** Unit of measurement for weight calculations.
 */
export const zWeightUnitEnum = z
  .enum(['percentage', 'points', 'ratio'])
  .describe('**[OPTIONAL]** Unit of measurement for weight calculations.');

/**
 * Assessment rubric with evaluation criteria and grading standards
 */
export const zAssessmentRubric = z
  .object({
    uuid: z
      .string()
      .uuid()
      .describe(
        '**[READ-ONLY]** Unique system identifier for the assessment rubric. Auto-generated by the system.'
      )
      .readonly()
      .optional(),
    title: z
      .string()
      .min(0)
      .max(255)
      .describe(
        '**[REQUIRED]** Title of the assessment rubric that clearly describes its purpose.'
      ),
    description: z
      .string()
      .min(0)
      .max(1000)
      .describe("**[OPTIONAL]** Detailed description of the rubric's purpose and assessment scope.")
      .optional(),
    rubric_type: z
      .string()
      .min(0)
      .max(50)
      .describe('**[REQUIRED]** Type of assessment this rubric is designed for.'),
    course_creator_uuid: z
      .string()
      .uuid()
      .describe('**[REQUIRED]** Reference to the course creator UUID who defined this rubric.'),
    is_public: z
      .boolean()
      .describe(
        '**[OPTIONAL]** Indicates if this rubric is publicly available for other course creators to use.'
      )
      .optional(),
    status: zStatusEnum,
    active: z
      .boolean()
      .describe(
        '**[OPTIONAL]** Indicates if the rubric is actively available for use. Can only be true for published rubrics.'
      )
      .optional(),
    total_weight: z
      .number()
      .gte(1)
      .lte(1000)
      .describe('**[OPTIONAL]** Total weight distribution across all criteria for this rubric.')
      .optional(),
    weight_unit: zWeightUnitEnum.optional(),
    uses_custom_levels: z
      .boolean()
      .describe(
        '**[OPTIONAL]** Indicates whether this rubric uses custom scoring levels or global grading levels.'
      )
      .optional(),
    max_score: z
      .number()
      .gte(0)
      .describe(
        '**[OPTIONAL]** Maximum possible score for this rubric based on weighted criteria and highest scoring levels.'
      )
      .optional(),
    min_passing_score: z
      .number()
      .gte(0)
      .describe('**[OPTIONAL]** Minimum score required to pass this rubric assessment.')
      .optional(),
    created_date: z
      .string()
      .datetime()
      .describe(
        '**[READ-ONLY]** Timestamp when the rubric was created. Automatically set by the system.'
      )
      .readonly()
      .optional(),
    created_by: z
      .string()
      .describe(
        '**[READ-ONLY]** Email or username of the user who created this rubric. Used for audit trails.'
      )
      .readonly()
      .optional(),
    updated_date: z
      .string()
      .datetime()
      .describe(
        '**[READ-ONLY]** Timestamp when the rubric was last modified. Automatically updated by the system.'
      )
      .readonly()
      .optional(),
    updated_by: z
      .string()
      .describe(
        '**[READ-ONLY]** Email or username of the user who last modified this rubric. Used for audit trails.'
      )
      .readonly()
      .optional(),
    is_published: z
      .boolean()
      .describe('**[READ-ONLY]** Indicates if the rubric is published and available for use.')
      .readonly()
      .optional(),
    rubric_category: z
      .string()
      .describe('**[READ-ONLY]** Formatted category of the rubric based on its type.')
      .readonly()
      .optional(),
    assessment_scope: z
      .string()
      .describe(
        '**[READ-ONLY]** Scope of the rubric usage. All rubrics are general-use and can be associated with multiple courses.'
      )
      .readonly()
      .optional(),
    usage_status: z
      .string()
      .describe('**[READ-ONLY]** Comprehensive status indicating usage and accessibility.')
      .readonly()
      .optional(),
  })
  .describe('Assessment rubric with evaluation criteria and grading standards');

export const zApiResponseAssessmentRubric = z.object({
  success: z.boolean().optional(),
  data: zAssessmentRubric.optional(),
  message: z.string().optional(),
  error: z.record(z.unknown()).optional(),
});

/**
 * Custom scoring level within a rubric defining evaluation standards and point values
 */
export const zRubricScoringLevel = z
  .object({
    uuid: z
      .string()
      .uuid()
      .describe(
        '**[READ-ONLY]** Unique system identifier for the rubric scoring level. Auto-generated by the system.'
      )
      .readonly()
      .optional(),
    rubric_uuid: z
      .string()
      .uuid()
      .describe('**[REQUIRED]** Reference to the rubric UUID that contains this scoring level.'),
    name: z
      .string()
      .min(0)
      .max(50)
      .describe('**[REQUIRED]** Name of the scoring level for display in the rubric matrix.'),
    description: z
      .string()
      .min(0)
      .max(1000)
      .describe('**[OPTIONAL]** Detailed description of what constitutes this performance level.')
      .optional(),
    points: z
      .number()
      .gte(0)
      .lte(1000)
      .describe('**[REQUIRED]** Point value assigned to this scoring level for calculations.'),
    level_order: z
      .number()
      .int()
      .gte(1)
      .describe(
        '**[REQUIRED]** Display order of the level in the rubric matrix (1 = highest performance).'
      ),
    color_code: z
      .string()
      .regex(/^#[0-9A-Fa-f]{6}$/)
      .describe('**[OPTIONAL]** Hex color code for UI display and visual distinction.')
      .optional(),
    is_passing: z
      .boolean()
      .describe('**[REQUIRED]** Indicates whether this scoring level constitutes a passing grade.'),
    created_date: z
      .string()
      .datetime()
      .describe(
        '**[READ-ONLY]** Timestamp when the scoring level was created. Automatically set by the system.'
      )
      .readonly()
      .optional(),
    created_by: z
      .string()
      .describe(
        '**[READ-ONLY]** Email or username of the user who created this scoring level. Used for audit trails.'
      )
      .readonly()
      .optional(),
    updated_date: z
      .string()
      .datetime()
      .describe(
        '**[READ-ONLY]** Timestamp when the scoring level was last modified. Automatically updated by the system.'
      )
      .readonly()
      .optional(),
    updated_by: z
      .string()
      .describe(
        '**[READ-ONLY]** Email or username of the user who last modified this scoring level. Used for audit trails.'
      )
      .readonly()
      .optional(),
    display_name: z
      .string()
      .describe('**[READ-ONLY]** Formatted display name combining level name and points for UI.')
      .readonly()
      .optional(),
    performance_indicator: z
      .string()
      .describe(
        '**[READ-ONLY]** Performance classification based on level order and passing status.'
      )
      .readonly()
      .optional(),
    css_color_class: z
      .string()
      .describe('**[READ-ONLY]** CSS-safe color class name derived from the color code.')
      .readonly()
      .optional(),
    is_highest_level: z
      .boolean()
      .describe(
        '**[READ-ONLY]** Indicates if this is the highest performance level (level_order = 1).'
      )
      .readonly()
      .optional(),
  })
  .describe('Custom scoring level within a rubric defining evaluation standards and point values');

export const zApiResponseRubricScoringLevel = z.object({
  success: z.boolean().optional(),
  data: zRubricScoringLevel.optional(),
  message: z.string().optional(),
  error: z.record(z.unknown()).optional(),
});

/**
 * Single cell in the rubric matrix representing criteria-scoring level intersection
 */
export const zRubricMatrixCell = z
  .object({
    criteria_uuid: z
      .string()
      .uuid()
      .describe('**[REQUIRED]** UUID of the criteria (row) this cell belongs to.'),
    scoring_level_uuid: z
      .string()
      .uuid()
      .describe('**[REQUIRED]** UUID of the scoring level (column) this cell belongs to.'),
    description: z
      .string()
      .min(0)
      .max(1000)
      .describe('**[REQUIRED]** Description of performance expectations at this intersection.'),
    points: z
      .number()
      .describe('**[READ-ONLY]** Point value for this cell (derived from scoring level).')
      .readonly()
      .optional(),
  })
  .describe('Single cell in the rubric matrix representing criteria-scoring level intersection');

/**
 * Individual assessment criteria within a rubric defining evaluation components
 */
export const zRubricCriteria = z
  .object({
    uuid: z
      .string()
      .uuid()
      .describe(
        '**[READ-ONLY]** Unique system identifier for the rubric criteria. Auto-generated by the system.'
      )
      .readonly()
      .optional(),
    rubric_uuid: z
      .string()
      .uuid()
      .describe('**[REQUIRED]** Reference to the rubric UUID that contains this criteria.'),
    component_name: z
      .string()
      .min(0)
      .max(100)
      .describe('**[REQUIRED]** Name of the assessment component being evaluated.'),
    description: z
      .string()
      .min(0)
      .max(500)
      .describe('**[OPTIONAL]** Detailed description of what this criteria evaluates and measures.')
      .optional(),
    display_order: z
      .number()
      .int()
      .gte(1)
      .describe(
        '**[REQUIRED]** Display order of the criteria within the rubric for consistent presentation.'
      ),
    created_date: z
      .string()
      .datetime()
      .describe(
        '**[READ-ONLY]** Timestamp when the criteria was created. Automatically set by the system.'
      )
      .readonly()
      .optional(),
    created_by: z
      .string()
      .describe(
        '**[READ-ONLY]** Email or username of the user who created this criteria. Used for audit trails.'
      )
      .readonly()
      .optional(),
    updated_date: z
      .string()
      .datetime()
      .describe(
        '**[READ-ONLY]** Timestamp when the criteria was last modified. Automatically updated by the system.'
      )
      .readonly()
      .optional(),
    updated_by: z
      .string()
      .describe(
        '**[READ-ONLY]** Email or username of the user who last modified this criteria. Used for audit trails.'
      )
      .readonly()
      .optional(),
    is_primary_criteria: z
      .boolean()
      .describe('**[READ-ONLY]** Indicates if this is a primary assessment criteria.')
      .readonly()
      .optional(),
    criteria_category: z
      .string()
      .describe('**[READ-ONLY]** Category classification of the assessment criteria.')
      .readonly()
      .optional(),
    weight_suggestion: z
      .string()
      .describe('**[READ-ONLY]** Suggested weight or priority level for this criteria.')
      .readonly()
      .optional(),
    criteria_number: z
      .string()
      .describe('**[READ-ONLY]** Formatted criteria number for display in assessment interface.')
      .readonly()
      .optional(),
  })
  .describe('Individual assessment criteria within a rubric defining evaluation components');

/**
 * Statistical information about rubric matrix completion and scoring
 */
export const zMatrixStatistics = z
  .object({
    total_cells: z
      .number()
      .int()
      .describe('Total number of matrix cells (criteria × scoring levels)')
      .optional(),
    completed_cells: z.number().int().describe('Number of cells with descriptions').optional(),
    completion_percentage: z.number().describe('Percentage of cells that are completed').optional(),
    max_possible_score: z
      .number()
      .describe('Maximum possible raw score (highest level × criteria count)')
      .optional(),
    weighted_max_score: z
      .number()
      .describe('Maximum weighted score considering criteria weights')
      .optional(),
    min_passing_score: z
      .number()
      .describe('Minimum passing score based on passing levels')
      .optional(),
    is_ready_for_use: z
      .boolean()
      .describe('Whether the matrix is ready for use (high completion rate)')
      .optional(),
  })
  .describe('Statistical information about rubric matrix completion and scoring');

/**
 * Complete rubric matrix with criteria, scoring levels, and intersection descriptions
 */
export const zRubricMatrix = z
  .object({
    rubric: zAssessmentRubric,
    scoring_levels: z
      .array(zRubricScoringLevel)
      .describe('**[REQUIRED]** List of scoring levels (columns) ordered by level_order.'),
    criteria: z
      .array(zRubricCriteria)
      .describe('**[REQUIRED]** List of criteria (rows) ordered by display_order.'),
    matrix_cells: z
      .record(zRubricMatrixCell)
      .describe(
        "**[REQUIRED]** Matrix cells mapping criteria to scoring levels with descriptions. Key format: 'criteriaUuid_scoringLevelUuid'."
      ),
    matrix_statistics: zMatrixStatistics.optional(),
    is_complete: z
      .boolean()
      .describe('**[READ-ONLY]** Whether all matrix cells have been completed with descriptions.')
      .readonly()
      .optional(),
    expected_cell_count: z
      .number()
      .int()
      .describe(
        '**[READ-ONLY]** Expected number of matrix cells (criteria count × scoring levels count).'
      )
      .readonly()
      .optional(),
  })
  .describe('Complete rubric matrix with criteria, scoring levels, and intersection descriptions');

export const zApiResponseRubricMatrix = z.object({
  success: z.boolean().optional(),
  data: zRubricMatrix.optional(),
  message: z.string().optional(),
  error: z.record(z.unknown()).optional(),
});

export const zApiResponseRubricCriteria = z.object({
  success: z.boolean().optional(),
  data: zRubricCriteria.optional(),
  message: z.string().optional(),
  error: z.record(z.unknown()).optional(),
});

/**
 * Scoring description for rubric criteria at specific grading levels
 */
export const zRubricScoring = z
  .object({
    uuid: z
      .string()
      .uuid()
      .describe(
        '**[READ-ONLY]** Unique system identifier for the rubric scoring. Auto-generated by the system.'
      )
      .readonly()
      .optional(),
    criteria_uuid: z
      .string()
      .uuid()
      .describe('**[REQUIRED]** Reference to the rubric criteria UUID this scoring applies to.'),
    rubric_scoring_level_uuid: z
      .string()
      .uuid()
      .describe(
        '**[REQUIRED]** Reference to the rubric scoring level UUID this scoring represents.'
      ),
    description: z
      .string()
      .min(0)
      .max(1000)
      .describe(
        '**[REQUIRED]** Detailed description of performance expectations at this grading level.'
      ),
    created_date: z
      .string()
      .datetime()
      .describe(
        '**[READ-ONLY]** Timestamp when the scoring was created. Automatically set by the system.'
      )
      .readonly()
      .optional(),
    created_by: z
      .string()
      .describe(
        '**[READ-ONLY]** Email or username of the user who created this scoring. Used for audit trails.'
      )
      .readonly()
      .optional(),
    updated_date: z
      .string()
      .datetime()
      .describe(
        '**[READ-ONLY]** Timestamp when the scoring was last modified. Automatically updated by the system.'
      )
      .readonly()
      .optional(),
    updated_by: z
      .string()
      .describe(
        '**[READ-ONLY]** Email or username of the user who last modified this scoring. Used for audit trails.'
      )
      .readonly()
      .optional(),
    performance_expectation: z
      .string()
      .describe('**[READ-ONLY]** Classification of performance expectation level.')
      .readonly()
      .optional(),
    score_range: z
      .string()
      .describe('**[READ-ONLY]** Expected score range for this performance level.')
      .readonly()
      .optional(),
    is_passing_level: z
      .boolean()
      .describe('**[READ-ONLY]** Indicates if this scoring level represents passing performance.')
      .readonly()
      .optional(),
    feedback_category: z
      .string()
      .describe('**[READ-ONLY]** Feedback category for constructive assessment guidance.')
      .readonly()
      .optional(),
  })
  .describe('Scoring description for rubric criteria at specific grading levels');

export const zApiResponseRubricScoring = z.object({
  success: z.boolean().optional(),
  data: zRubricScoring.optional(),
  message: z.string().optional(),
  error: z.record(z.unknown()).optional(),
});

/**
 * Quiz assessment with configurable questions, timing, and scoring
 */
export const zQuiz = z
  .object({
    uuid: z
      .string()
      .uuid()
      .describe(
        '**[READ-ONLY]** Unique system identifier for the quiz. Auto-generated by the system.'
      )
      .readonly()
      .optional(),
    lesson_uuid: z
      .string()
      .uuid()
      .describe('**[REQUIRED]** Reference to the lesson UUID that contains this quiz.'),
    title: z
      .string()
      .min(0)
      .max(255)
      .describe('**[REQUIRED]** Quiz title that clearly describes the assessment content.'),
    description: z
      .string()
      .min(0)
      .max(1000)
      .describe('**[OPTIONAL]** Detailed description of the quiz purpose and content coverage.')
      .optional(),
    instructions: z
      .string()
      .min(0)
      .max(1000)
      .describe('**[OPTIONAL]** Instructions for students on how to complete the quiz.')
      .optional(),
    time_limit_minutes: z
      .number()
      .int()
      .gte(1)
      .describe(
        '**[OPTIONAL]** Time limit for completing the quiz in minutes. Null means no time limit.'
      )
      .optional(),
    attempts_allowed: z
      .number()
      .int()
      .gte(1)
      .describe(
        '**[REQUIRED]** Number of attempts allowed for this quiz. Set to 1 for single attempt.'
      ),
    passing_score: z
      .number()
      .gte(0)
      .lte(100)
      .describe('**[REQUIRED]** Minimum score percentage required to pass the quiz.'),
    rubric_uuid: z
      .string()
      .uuid()
      .describe('**[OPTIONAL]** Reference to assessment rubric UUID for detailed grading criteria.')
      .optional(),
    status: zStatusEnum,
    active: z
      .boolean()
      .describe(
        '**[OPTIONAL]** Indicates if the quiz is actively available to students. Can only be true for published quizzes.'
      )
      .optional(),
    created_date: z
      .string()
      .datetime()
      .describe(
        '**[READ-ONLY]** Timestamp when the quiz was created. Automatically set by the system.'
      )
      .readonly()
      .optional(),
    created_by: z
      .string()
      .describe(
        '**[READ-ONLY]** Email or username of the user who created this quiz. Used for audit trails.'
      )
      .readonly()
      .optional(),
    updated_date: z
      .string()
      .datetime()
      .describe(
        '**[READ-ONLY]** Timestamp when the quiz was last modified. Automatically updated by the system.'
      )
      .readonly()
      .optional(),
    updated_by: z
      .string()
      .describe(
        '**[READ-ONLY]** Email or username of the user who last modified this quiz. Used for audit trails.'
      )
      .readonly()
      .optional(),
    is_published: z
      .boolean()
      .describe('**[READ-ONLY]** Indicates if the quiz is published and accessible to students.')
      .readonly()
      .optional(),
    time_limit_display: z
      .string()
      .describe('**[READ-ONLY]** Human-readable format of quiz time limit.')
      .readonly()
      .optional(),
    is_timed: z
      .boolean()
      .describe('**[READ-ONLY]** Indicates if the quiz has a time limit.')
      .readonly()
      .optional(),
    has_multiple_attempts: z
      .boolean()
      .describe('**[READ-ONLY]** Indicates if students can take the quiz multiple times.')
      .readonly()
      .optional(),
  })
  .describe('Quiz assessment with configurable questions, timing, and scoring');

export const zApiResponseQuiz = z.object({
  success: z.boolean().optional(),
  data: zQuiz.optional(),
  message: z.string().optional(),
  error: z.record(z.unknown()).optional(),
});

/**
 * **[REQUIRED]** Type of question determining the answer format and validation.
 */
export const zQuestionTypeEnum = z
  .enum(['MULTIPLE_CHOICE', 'TRUE_FALSE', 'SHORT_ANSWER', 'ESSAY'])
  .describe('**[REQUIRED]** Type of question determining the answer format and validation.');

/**
 * Individual question within a quiz supporting multiple question types
 */
export const zQuizQuestion = z
  .object({
    uuid: z
      .string()
      .uuid()
      .describe(
        '**[READ-ONLY]** Unique system identifier for the quiz question. Auto-generated by the system.'
      )
      .readonly()
      .optional(),
    quiz_uuid: z
      .string()
      .uuid()
      .describe('**[REQUIRED]** Reference to the quiz UUID that contains this question.'),
    question_text: z
      .string()
      .min(0)
      .max(2000)
      .describe('**[REQUIRED]** The actual question text that students will see and answer.'),
    question_type: zQuestionTypeEnum,
    points: z
      .number()
      .gte(0.01)
      .describe('**[REQUIRED]** Point value for this question when answered correctly.'),
    display_order: z
      .number()
      .int()
      .gte(1)
      .describe(
        '**[REQUIRED]** Display order of the question within the quiz for sequential presentation.'
      ),
    created_date: z
      .string()
      .datetime()
      .describe(
        '**[READ-ONLY]** Timestamp when the question was created. Automatically set by the system.'
      )
      .readonly()
      .optional(),
    created_by: z
      .string()
      .describe(
        '**[READ-ONLY]** Email or username of the user who created this question. Used for audit trails.'
      )
      .readonly()
      .optional(),
    updated_date: z
      .string()
      .datetime()
      .describe(
        '**[READ-ONLY]** Timestamp when the question was last modified. Automatically updated by the system.'
      )
      .readonly()
      .optional(),
    updated_by: z
      .string()
      .describe(
        '**[READ-ONLY]** Email or username of the user who last modified this question. Used for audit trails.'
      )
      .readonly()
      .optional(),
    requires_options: z
      .boolean()
      .describe(
        '**[READ-ONLY]** Indicates if this question type requires predefined answer options.'
      )
      .readonly()
      .optional(),
    question_category: z
      .string()
      .describe('**[READ-ONLY]** Human-readable category of the question type.')
      .readonly()
      .optional(),
    points_display: z
      .string()
      .describe('**[READ-ONLY]** Human-readable format of the points value.')
      .readonly()
      .optional(),
    question_number: z
      .string()
      .describe('**[READ-ONLY]** Formatted question number for display in quiz interface.')
      .readonly()
      .optional(),
  })
  .describe('Individual question within a quiz supporting multiple question types');

export const zApiResponseQuizQuestion = z.object({
  success: z.boolean().optional(),
  data: zQuizQuestion.optional(),
  message: z.string().optional(),
  error: z.record(z.unknown()).optional(),
});

/**
 * Individual answer option for quiz questions with correctness and ordering information
 */
export const zQuizQuestionOption = z
  .object({
    uuid: z
      .string()
      .uuid()
      .describe(
        '**[READ-ONLY]** Unique system identifier for the quiz question option. Auto-generated by the system.'
      )
      .readonly()
      .optional(),
    question_uuid: z
      .string()
      .uuid()
      .describe('**[REQUIRED]** Reference to the quiz question UUID this option belongs to.'),
    option_text: z
      .string()
      .min(0)
      .max(1000)
      .describe('**[REQUIRED]** Text content of the answer option displayed to students.'),
    is_correct: z
      .boolean()
      .describe('**[OPTIONAL]** Indicates if this option is the correct answer for the question.')
      .optional(),
    display_order: z
      .number()
      .int()
      .gte(1)
      .describe("**[OPTIONAL]** Display order of this option within the question's answer choices.")
      .optional(),
    created_date: z
      .string()
      .datetime()
      .describe(
        '**[READ-ONLY]** Timestamp when the option was created. Automatically set by the system.'
      )
      .readonly()
      .optional(),
    created_by: z
      .string()
      .describe(
        '**[READ-ONLY]** Email or username of the user who created this option. Used for audit trails.'
      )
      .readonly()
      .optional(),
    updated_date: z
      .string()
      .datetime()
      .describe(
        '**[READ-ONLY]** Timestamp when the option was last modified. Automatically updated by the system.'
      )
      .readonly()
      .optional(),
    updated_by: z
      .string()
      .describe(
        '**[READ-ONLY]** Email or username of the user who last modified this option. Used for audit trails.'
      )
      .readonly()
      .optional(),
    option_category: z
      .string()
      .describe('**[READ-ONLY]** Formatted category of the option based on its correctness status.')
      .readonly()
      .optional(),
    is_incorrect: z
      .boolean()
      .describe('**[READ-ONLY]** Indicates if this option is an incorrect answer choice.')
      .readonly()
      .optional(),
    position_display: z
      .string()
      .describe("**[READ-ONLY]** Formatted display of the option's position within the question.")
      .readonly()
      .optional(),
    correctness_status: z
      .string()
      .describe(
        '**[READ-ONLY]** Status description indicating whether this option is correct or incorrect.'
      )
      .readonly()
      .optional(),
    option_summary: z
      .string()
      .describe(
        '**[READ-ONLY]** Comprehensive summary of the option including correctness and position.'
      )
      .readonly()
      .optional(),
  })
  .describe(
    'Individual answer option for quiz questions with correctness and ordering information'
  );

export const zApiResponseQuizQuestionOption = z.object({
  success: z.boolean().optional(),
  data: zQuizQuestionOption.optional(),
  message: z.string().optional(),
  error: z.record(z.unknown()).optional(),
});

export const zSchemaEnum = z.enum(['draft', 'in_review', 'published', 'archived']);

/**
 * Training program bundling multiple courses into structured learning pathways
 */
export const zTrainingProgram = z
  .object({
    uuid: z
      .string()
      .uuid()
      .describe(
        '**[READ-ONLY]** Unique system identifier for the training program. Auto-generated by the system.'
      )
      .readonly()
      .optional(),
    title: z
      .string()
      .min(0)
      .max(255)
      .describe(
        '**[REQUIRED]** Title of the training program that clearly describes the learning pathway.'
      ),
    instructor_uuid: z
      .string()
      .uuid()
      .describe(
        '**[REQUIRED]** Reference to the instructor UUID who created and manages this program.'
      ),
    category_uuid: z
      .string()
      .uuid()
      .describe(
        '**[OPTIONAL]** Reference to the category UUID for program organization and discovery.'
      )
      .optional(),
    description: z
      .string()
      .min(0)
      .max(2000)
      .describe(
        '**[OPTIONAL]** Detailed description of the program content, approach, and outcomes.'
      )
      .optional(),
    objectives: z
      .string()
      .min(0)
      .max(1000)
      .describe(
        '**[OPTIONAL]** Learning objectives and goals students will achieve upon program completion.'
      )
      .optional(),
    status: zSchemaEnum,
    prerequisites: z
      .string()
      .min(0)
      .max(1000)
      .describe(
        '**[OPTIONAL]** Required knowledge and skills students should have before starting this program.'
      )
      .optional(),
    total_duration_hours: z
      .number()
      .int()
      .gte(0)
      .describe('**[REQUIRED]** Total program duration in hours across all courses.'),
    total_duration_minutes: z
      .number()
      .int()
      .gte(0)
      .lte(59)
      .describe('**[REQUIRED]** Additional program duration in minutes (0-59).'),
    class_limit: z
      .number()
      .int()
      .gte(1)
      .describe('**[OPTIONAL]** Maximum number of students that can enroll in the program.')
      .optional(),
    price: z
      .number()
      .gte(0)
      .describe(
        '**[OPTIONAL]** Program price in the system currency. Set to null or 0 for free programs.'
      )
      .optional(),
    active: z
      .boolean()
      .describe(
        '**[OPTIONAL]** Indicates if the program is actively available to students. Can only be true for published programs.'
      )
      .optional(),
    published: z.boolean().describe('**[REQUIRED]** Indicates if the program is published,'),
    created_date: z
      .string()
      .datetime()
      .describe(
        '**[READ-ONLY]** Timestamp when the program was created. Automatically set by the system.'
      )
      .readonly()
      .optional(),
    created_by: z
      .string()
      .describe(
        '**[READ-ONLY]** Email or username of the user who created this program. Used for audit trails.'
      )
      .readonly()
      .optional(),
    updated_date: z
      .string()
      .datetime()
      .describe(
        '**[READ-ONLY]** Timestamp when the program was last modified. Automatically updated by the system.'
      )
      .readonly()
      .optional(),
    updated_by: z
      .string()
      .describe(
        '**[READ-ONLY]** Email or username of the user who last modified this program. Used for audit trails.'
      )
      .readonly()
      .optional(),
    program_type: z
      .string()
      .describe('**[READ-ONLY]** Classification of program type based on duration and content.')
      .readonly()
      .optional(),
    is_free: z
      .boolean()
      .describe('**[READ-ONLY]** Indicates if the program is offered for free.')
      .readonly()
      .optional(),
    total_duration_display: z
      .string()
      .describe('**[READ-ONLY]** Human-readable format of total program duration.')
      .readonly()
      .optional(),
  })
  .describe('Training program bundling multiple courses into structured learning pathways');

export const zApiResponseTrainingProgram = z.object({
  success: z.boolean().optional(),
  data: zTrainingProgram.optional(),
  message: z.string().optional(),
  error: z.record(z.unknown()).optional(),
});

/**
 * **[REQUIRED]** Type of requirement classification for this program element.
 */
export const zRequirementTypeEnum = z
  .enum(['STUDENT', 'TRAINING_CENTER', 'INSTRUCTOR'])
  .describe('**[REQUIRED]** Type of requirement classification for this program element.');

/**
 * Program requirement with type classification and mandatory status
 */
export const zProgramRequirement = z
  .object({
    uuid: z
      .string()
      .uuid()
      .describe(
        '**[READ-ONLY]** Unique system identifier for the program requirement. Auto-generated by the system.'
      )
      .readonly()
      .optional(),
    program_uuid: z
      .string()
      .uuid()
      .describe('**[REQUIRED]** Reference to the program UUID this requirement applies to.'),
    requirement_type: zRequirementTypeEnum,
    requirement_text: z
      .string()
      .min(0)
      .max(2000)
      .describe(
        '**[REQUIRED]** Detailed text describing the specific requirement and its criteria.'
      ),
    is_mandatory: z
      .boolean()
      .describe('**[OPTIONAL]** Indicates if this requirement is mandatory for program completion.')
      .optional(),
    created_date: z
      .string()
      .datetime()
      .describe(
        '**[READ-ONLY]** Timestamp when the requirement was created. Automatically set by the system.'
      )
      .readonly()
      .optional(),
    created_by: z
      .string()
      .describe(
        '**[READ-ONLY]** Email or username of the user who created this requirement. Used for audit trails.'
      )
      .readonly()
      .optional(),
    updated_date: z
      .string()
      .datetime()
      .describe(
        '**[READ-ONLY]** Timestamp when the requirement was last modified. Automatically updated by the system.'
      )
      .readonly()
      .optional(),
    updated_by: z
      .string()
      .describe(
        '**[READ-ONLY]** Email or username of the user who last modified this requirement. Used for audit trails.'
      )
      .readonly()
      .optional(),
    is_optional: z
      .boolean()
      .describe('**[READ-ONLY]** Indicates if the requirement is optional (not mandatory).')
      .readonly()
      .optional(),
    requirement_category: z
      .string()
      .describe(
        '**[READ-ONLY]** Formatted category of the requirement based on type and mandatory status.'
      )
      .readonly()
      .optional(),
    requirement_priority: z
      .string()
      .describe(
        '**[READ-ONLY]** Priority level of the requirement based on type and mandatory status.'
      )
      .readonly()
      .optional(),
    compliance_level: z
      .string()
      .describe(
        '**[READ-ONLY]** Compliance level indicating how strictly the requirement must be followed.'
      )
      .readonly()
      .optional(),
    requirement_summary: z
      .string()
      .describe(
        '**[READ-ONLY]** Comprehensive summary of the requirement including type and compliance level.'
      )
      .readonly()
      .optional(),
  })
  .describe('Program requirement with type classification and mandatory status');

export const zApiResponseProgramRequirement = z.object({
  success: z.boolean().optional(),
  data: zProgramRequirement.optional(),
  message: z.string().optional(),
  error: z.record(z.unknown()).optional(),
});

/**
 * Association between programs and courses with sequencing and requirement information
 */
export const zProgramCourse = z
  .object({
    uuid: z
      .string()
      .uuid()
      .describe(
        '**[READ-ONLY]** Unique system identifier for the program-course association. Auto-generated by the system.'
      )
      .readonly()
      .optional(),
    program_uuid: z
      .string()
      .uuid()
      .describe('**[REQUIRED]** Reference to the program UUID that contains this course.'),
    course_uuid: z
      .string()
      .uuid()
      .describe('**[REQUIRED]** Reference to the course UUID that is part of this program.'),
    sequence_order: z
      .number()
      .int()
      .gte(1)
      .describe('**[OPTIONAL]** Sequential order of this course within the program curriculum.')
      .optional(),
    is_required: z
      .boolean()
      .describe('**[OPTIONAL]** Indicates if this course is required for program completion.')
      .optional(),
    prerequisite_course_uuid: z
      .string()
      .uuid()
      .describe(
        '**[OPTIONAL]** Reference to the prerequisite course UUID that must be completed before this course.'
      )
      .optional(),
    created_date: z
      .string()
      .datetime()
      .describe(
        '**[READ-ONLY]** Timestamp when the program-course association was created. Automatically set by the system.'
      )
      .readonly()
      .optional(),
    created_by: z
      .string()
      .describe(
        '**[READ-ONLY]** Email or username of the user who created this association. Used for audit trails.'
      )
      .readonly()
      .optional(),
    updated_date: z
      .string()
      .datetime()
      .describe(
        '**[READ-ONLY]** Timestamp when the association was last modified. Automatically updated by the system.'
      )
      .readonly()
      .optional(),
    updated_by: z
      .string()
      .describe(
        '**[READ-ONLY]** Email or username of the user who last modified this association. Used for audit trails.'
      )
      .readonly()
      .optional(),
    association_category: z
      .string()
      .describe(
        '**[READ-ONLY]** Formatted category of the course association based on requirement status.'
      )
      .readonly()
      .optional(),
    has_prerequisites: z
      .boolean()
      .describe('**[READ-ONLY]** Indicates if this course has prerequisite requirements.')
      .readonly()
      .optional(),
    sequence_display: z
      .string()
      .describe(
        '**[READ-ONLY]** Formatted display of the course position within the program sequence.'
      )
      .readonly()
      .optional(),
    requirement_status: z
      .string()
      .describe('**[READ-ONLY]** Requirement status of the course within the program.')
      .readonly()
      .optional(),
    curriculum_summary: z
      .string()
      .describe(
        "**[READ-ONLY]** Comprehensive summary of the course's role within the program curriculum."
      )
      .readonly()
      .optional(),
  })
  .describe('Association between programs and courses with sequencing and requirement information');

export const zApiResponseProgramCourse = z.object({
  success: z.boolean().optional(),
  data: zProgramCourse.optional(),
  message: z.string().optional(),
  error: z.record(z.unknown()).optional(),
});

/**
 * Complete organisation profile information including basic details, configuration, and metadata
 */
export const zOrganisation = z
  .object({
    uuid: z
      .string()
      .uuid()
      .describe(
        '**[READ-ONLY]** Unique system identifier for the organisation. Auto-generated by the system and cannot be modified.'
      )
      .readonly()
      .optional(),
    name: z
      .string()
      .min(0)
      .max(50)
      .describe(
        "**[REQUIRED]** Organisation's official name. Used for display purposes and official documentation. Must not be blank."
      ),
    description: z
      .string()
      .describe(
        "**[OPTIONAL]** Detailed description of the organisation. Provides additional context about the organisation's purpose and activities."
      )
      .optional(),
    active: z
      .boolean()
      .describe(
        '**[REQUIRED]** Indicates whether the organisation is active and can access the system. Inactive organisations cannot perform any operations.'
      ),
    licence_no: z
      .string()
      .max(100)
      .describe(
        '**[OPTIONAL]** Official licence number or registration number for the organisation. Used for regulatory compliance and verification.'
      )
      .optional(),
    location: z
      .string()
      .max(200)
      .describe('**[OPTIONAL]** Physical location or address of the organisation.')
      .optional(),
    country: z
      .string()
      .max(100)
      .describe('**[OPTIONAL]** Country where the organisation is located.')
      .optional(),
    slug: z
      .string()
      .describe(
        "**[READ-ONLY]** URL-friendly slug for the organisation's public profile. Auto-generated from the organisation name."
      )
      .readonly()
      .optional(),
    latitude: z
      .number()
      .describe("**[OPTIONAL]** Latitude coordinate for the organisation's location.")
      .optional(),
    longitude: z
      .number()
      .describe("**[OPTIONAL]** Longitude coordinate for the organisation's location.")
      .optional(),
    admin_verified: z
      .boolean()
      .describe(
        '**[READ-ONLY]** Indicates whether the organisation has been verified/approved by an admin. Only verified organisations can access certain platform features and are displayed with verification badges.'
      )
      .readonly()
      .optional(),
    created_date: z
      .string()
      .datetime()
      .describe(
        '**[READ-ONLY]** Timestamp when the organisation was first created. Automatically set by the system and cannot be modified.'
      )
      .readonly()
      .optional(),
    updated_date: z
      .string()
      .datetime()
      .describe(
        '**[READ-ONLY]** Timestamp when the organisation was last updated. Automatically updated by the system on any changes and cannot be directly modified.'
      )
      .readonly()
      .optional(),
  })
  .describe(
    'Complete organisation profile information including basic details, configuration, and metadata'
  );

export const zApiResponseOrganisation = z.object({
  success: z.boolean().optional(),
  data: zOrganisation.optional(),
  message: z.string().optional(),
  error: z.record(z.unknown()).optional(),
});

/**
 * Instructor profile including location data for educational service delivery
 */
export const zInstructor = z
  .object({
    uuid: z
      .string()
      .uuid()
      .describe(
        '**[READ-ONLY]** Unique system identifier for the instructor profile. Auto-generated by the system.'
      )
      .readonly()
      .optional(),
    user_uuid: z
      .string()
      .uuid()
      .describe(
        '**[REQUIRED]** Reference to the base user account UUID. Links instructor profile to user authentication and personal details.'
      ),
    latitude: z
      .number()
      .gte(-90)
      .lte(90)
      .describe(
        "**[OPTIONAL]** Geographical latitude coordinate of instructor's primary training location. Used for location-based instructor matching and distance calculations."
      )
      .optional(),
    longitude: z
      .number()
      .gte(-180)
      .lte(180)
      .describe(
        "**[OPTIONAL]** Geographical longitude coordinate of instructor's primary training location. Used for location-based instructor matching and distance calculations."
      )
      .optional(),
    website: z
      .string()
      .url()
      .min(0)
      .max(255)
      .describe(
        "**[OPTIONAL]** Professional website or portfolio URL. Used to showcase instructor's work, testimonials, and additional credentials."
      )
      .optional(),
    bio: z
      .string()
      .min(0)
      .max(2000)
      .describe(
        "**[OPTIONAL]** Professional biography describing instructor's background, expertise, teaching philosophy, and experience. Used in instructor profiles and course descriptions."
      )
      .optional(),
    professional_headline: z
      .string()
      .min(0)
      .max(150)
      .describe(
        "**[OPTIONAL]** Professional headline or title that summarizes instructor's expertise and role. Used in search results and instructor listings."
      )
      .optional(),
    full_name: z
      .string()
      .describe(
        '**[READ-ONLY]** Complete name of the instructor including titles and credentials. Automatically derived from user profile and professional credentials.'
      )
      .readonly()
      .optional(),
    admin_verified: z
      .boolean()
      .describe(
        '**[READ-ONLY]** Indicates whether the instructor has been verified by an administrator. True if verified, false if not verified, null if verification status is unknown or pending.'
      )
      .readonly()
      .optional(),
    created_date: z
      .string()
      .datetime()
      .describe(
        '**[READ-ONLY]** Timestamp when the instructor profile was first created. Automatically set by the system.'
      )
      .readonly()
      .optional(),
    created_by: z
      .string()
      .describe(
        '**[READ-ONLY]** Email or username of the user who created this instructor profile. Used for audit trails and administrative purposes.'
      )
      .readonly()
      .optional(),
    updated_date: z
      .string()
      .datetime()
      .describe(
        '**[READ-ONLY]** Timestamp when the instructor profile was last modified. Automatically updated by the system on any changes.'
      )
      .readonly()
      .optional(),
    updated_by: z
      .string()
      .describe(
        '**[READ-ONLY]** Email or username of the user who last modified this instructor profile. Used for audit trails and administrative purposes.'
      )
      .readonly()
      .optional(),
    is_profile_complete: z
      .boolean()
      .describe(
        '**[READ-ONLY]** Indicates if the instructor profile is considered complete. Requires bio and professional headline.'
      )
      .readonly()
      .optional(),
    has_location_coordinates: z
      .boolean()
      .describe(
        '**[READ-ONLY]** Indicates if the instructor has both latitude and longitude coordinates configured.'
      )
      .readonly()
      .optional(),
    formatted_location: z
      .string()
      .describe(
        '**[READ-ONLY]** Formatted location coordinates as a string. Returns null if location coordinates are not available.'
      )
      .readonly()
      .optional(),
  })
  .describe('Instructor profile including location data for educational service delivery');

/**
 * **[REQUIRED]** Level of proficiency in this skill. Indicates instructor's competency and teaching capability.
 */
export const zProficiencyLevelEnum = z
  .enum(['BEGINNER', 'INTERMEDIATE', 'ADVANCED', 'EXPERT'])
  .describe(
    "**[REQUIRED]** Level of proficiency in this skill. Indicates instructor's competency and teaching capability."
  );

/**
 * Technical and professional skill record for instructors with proficiency levels and competency classifications
 */
export const zInstructorSkill = z
  .object({
    uuid: z
      .string()
      .uuid()
      .describe(
        '**[READ-ONLY]** Unique system identifier for the skill record. Auto-generated by the system.'
      )
      .readonly()
      .optional(),
    instructor_uuid: z
      .string()
      .uuid()
      .describe(
        '**[REQUIRED]** Reference to the instructor profile UUID. Links skill record to specific instructor.'
      ),
    skill_name: z
      .string()
      .min(0)
      .max(100)
      .describe(
        '**[REQUIRED]** Name of the technical or professional skill. Should be specific and standardized for consistency.'
      ),
    proficiency_level: zProficiencyLevelEnum,
    created_date: z
      .string()
      .datetime()
      .describe(
        '**[READ-ONLY]** Timestamp when the skill record was first created. Automatically set by the system.'
      )
      .readonly()
      .optional(),
    created_by: z
      .string()
      .describe('**[READ-ONLY]** Email or username of the user who created this skill record.')
      .readonly()
      .optional(),
    updated_date: z
      .string()
      .datetime()
      .describe(
        '**[READ-ONLY]** Timestamp when the skill record was last modified. Automatically updated by the system.'
      )
      .readonly()
      .optional(),
    updated_by: z
      .string()
      .describe(
        '**[READ-ONLY]** Email or username of the user who last modified this skill record.'
      )
      .readonly()
      .optional(),
    display_name: z
      .string()
      .describe('**[READ-ONLY]** Formatted skill name for display in UI components.')
      .readonly()
      .optional(),
    summary: z
      .string()
      .describe('**[READ-ONLY]** Brief summary of the skill for display in skill lists.')
      .readonly()
      .optional(),
    proficiency_description: z
      .string()
      .describe('**[READ-ONLY]** Human-readable description of the proficiency level.')
      .readonly()
      .optional(),
  })
  .describe(
    'Technical and professional skill record for instructors with proficiency levels and competency classifications'
  );

export const zApiResponseInstructorSkill = z.object({
  success: z.boolean().optional(),
  data: zInstructorSkill.optional(),
  message: z.string().optional(),
  error: z.record(z.unknown()).optional(),
});

/**
 * **[READ-ONLY]** Current status of the membership.
 */
export const zMembershipStatusEnum = z
  .enum(['ACTIVE', 'INACTIVE', 'EXPIRED', 'UNKNOWN'])
  .describe('**[READ-ONLY]** Current status of the membership.');

/**
 * **[READ-ONLY]** Classification of organization type based on name keywords.
 */
export const zOrganizationTypeEnum = z
  .enum([
    'PROFESSIONAL_INSTITUTE',
    'CERTIFICATION_BODY',
    'INDUSTRY_ASSOCIATION',
    'ACADEMIC_SOCIETY',
    'TRADE_ORGANIZATION',
    'OTHER',
  ])
  .describe('**[READ-ONLY]** Classification of organization type based on name keywords.');

/**
 * Professional membership record for instructors including associations, industry bodies, and certification organizations
 */
export const zInstructorProfessionalMembership = z
  .object({
    uuid: z
      .string()
      .uuid()
      .describe(
        '**[READ-ONLY]** Unique system identifier for the membership record. Auto-generated by the system.'
      )
      .readonly()
      .optional(),
    instructor_uuid: z
      .string()
      .uuid()
      .describe(
        '**[REQUIRED]** Reference to the instructor profile UUID. Links membership record to specific instructor.'
      ),
    organization_name: z
      .string()
      .min(0)
      .max(255)
      .describe(
        '**[REQUIRED]** Full name of the professional organization, association, or certification body.'
      ),
    membership_number: z
      .string()
      .min(0)
      .max(100)
      .describe(
        '**[OPTIONAL]** Official membership number or identifier issued by the organization.'
      )
      .optional(),
    start_date: z
      .string()
      .date()
      .describe('**[OPTIONAL]** Date when the membership began or was first obtained.')
      .optional(),
    end_date: z
      .string()
      .date()
      .describe(
        '**[OPTIONAL]** Date when the membership ended or expired. Should be null for active memberships.'
      )
      .optional(),
    is_active: z
      .boolean()
      .describe(
        '**[OPTIONAL]** Indicates whether the membership is currently active. True for active memberships, false for inactive or expired.'
      )
      .optional(),
    created_date: z
      .string()
      .datetime()
      .describe(
        '**[READ-ONLY]** Timestamp when the membership record was first created. Automatically set by the system.'
      )
      .readonly()
      .optional(),
    created_by: z
      .string()
      .describe('**[READ-ONLY]** Email or username of the user who created this membership record.')
      .readonly()
      .optional(),
    updated_date: z
      .string()
      .datetime()
      .describe(
        '**[READ-ONLY]** Timestamp when the membership record was last modified. Automatically updated by the system.'
      )
      .readonly()
      .optional(),
    updated_by: z
      .string()
      .describe(
        '**[READ-ONLY]** Email or username of the user who last modified this membership record.'
      )
      .readonly()
      .optional(),
    is_valid: z
      .boolean()
      .describe('**[READ-ONLY]** Indicates if the membership is currently valid and active.')
      .readonly()
      .optional(),
    summary: z
      .string()
      .describe('**[READ-ONLY]** Brief summary of the membership for display in listings.')
      .readonly()
      .optional(),
    is_complete: z
      .boolean()
      .describe('**[READ-ONLY]** Indicates if the membership record has all essential information.')
      .readonly()
      .optional(),
    formatted_duration: z
      .string()
      .describe('**[READ-ONLY]** Human-readable formatted duration of membership.')
      .readonly()
      .optional(),
    membership_status: zMembershipStatusEnum.optional(),
    membership_period: z
      .string()
      .describe('**[READ-ONLY]** Formatted membership period showing start and end dates.')
      .readonly()
      .optional(),
    is_long_standing_member: z
      .boolean()
      .describe('**[READ-ONLY]** Indicates if this membership has been held for 5 years or more.')
      .readonly()
      .optional(),
    has_membership_number: z
      .boolean()
      .describe('**[READ-ONLY]** Indicates if the membership has a membership number documented.')
      .readonly()
      .optional(),
    organization_type: zOrganizationTypeEnum.optional(),
    years_of_membership: z
      .number()
      .describe('**[READ-ONLY]** Years of membership calculated with decimal precision.')
      .readonly()
      .optional(),
    is_recent_membership: z
      .boolean()
      .describe('**[READ-ONLY]** Indicates if this membership was started within the last 3 years.')
      .readonly()
      .optional(),
    membership_duration_months: z
      .number()
      .int()
      .describe(
        '**[READ-ONLY]** Duration of membership calculated from start and end dates, in months.'
      )
      .readonly()
      .optional(),
  })
  .describe(
    'Professional membership record for instructors including associations, industry bodies, and certification organizations'
  );

export const zApiResponseInstructorProfessionalMembership = z.object({
  success: z.boolean().optional(),
  data: zInstructorProfessionalMembership.optional(),
  message: z.string().optional(),
  error: z.record(z.unknown()).optional(),
});

/**
 * **[READ-ONLY]** Classification of experience level based on position title and duration.
 */
export const zExperienceLevelEnum = z
  .enum(['ENTRY', 'JUNIOR', 'MID', 'SENIOR', 'LEAD', 'EXECUTIVE'])
  .describe(
    '**[READ-ONLY]** Classification of experience level based on position title and duration.'
  );

/**
 * Professional work experience record for instructors including positions, organizations, responsibilities, and employment duration
 */
export const zInstructorExperience = z
  .object({
    uuid: z
      .string()
      .uuid()
      .describe(
        '**[READ-ONLY]** Unique system identifier for the experience record. Auto-generated by the system.'
      )
      .readonly()
      .optional(),
    instructor_uuid: z
      .string()
      .uuid()
      .describe(
        '**[REQUIRED]** Reference to the instructor profile UUID. Links experience record to specific instructor.'
      ),
    position: z
      .string()
      .min(0)
      .max(255)
      .describe('**[REQUIRED]** Job title or position held by the instructor in this role.'),
    organization_name: z
      .string()
      .min(0)
      .max(255)
      .describe(
        '**[REQUIRED]** Name of the organization, company, or institution where the instructor worked.'
      ),
    responsibilities: z
      .string()
      .min(0)
      .max(2000)
      .describe(
        '**[OPTIONAL]** Detailed description of key responsibilities, achievements, and duties performed in this position.'
      )
      .optional(),
    years_of_experience: z
      .number()
      .gte(0)
      .lte(50)
      .describe(
        '**[OPTIONAL]** Total years of experience in this position, including fractional years for more precise representation.'
      )
      .optional(),
    start_date: z
      .string()
      .date()
      .describe('**[OPTIONAL]** Date when employment in this position began.')
      .optional(),
    end_date: z
      .string()
      .date()
      .describe(
        '**[OPTIONAL]** Date when employment in this position ended. Should be null for current positions.'
      )
      .optional(),
    is_current_position: z
      .boolean()
      .describe(
        "**[OPTIONAL]** Indicates whether this is the instructor's current position. True for ongoing employment."
      )
      .optional(),
    created_date: z
      .string()
      .datetime()
      .describe(
        '**[READ-ONLY]** Timestamp when the experience record was first created. Automatically set by the system.'
      )
      .readonly()
      .optional(),
    created_by: z
      .string()
      .describe('**[READ-ONLY]** Email or username of the user who created this experience record.')
      .readonly()
      .optional(),
    updated_date: z
      .string()
      .datetime()
      .describe(
        '**[READ-ONLY]** Timestamp when the experience record was last modified. Automatically updated by the system.'
      )
      .readonly()
      .optional(),
    updated_by: z
      .string()
      .describe(
        '**[READ-ONLY]** Email or username of the user who last modified this experience record.'
      )
      .readonly()
      .optional(),
    summary: z
      .string()
      .describe('**[READ-ONLY]** Brief summary of the experience for display in listings.')
      .readonly()
      .optional(),
    is_complete: z
      .boolean()
      .describe('**[READ-ONLY]** Indicates if the experience record has all essential information.')
      .readonly()
      .optional(),
    duration_in_months: z
      .number()
      .int()
      .describe(
        '**[READ-ONLY]** Duration of employment calculated from start and end dates, in months.'
      )
      .readonly()
      .optional(),
    formatted_duration: z
      .string()
      .describe('**[READ-ONLY]** Human-readable formatted duration of employment.')
      .readonly()
      .optional(),
    employment_period: z
      .string()
      .describe('**[READ-ONLY]** Formatted employment period showing start and end dates.')
      .readonly()
      .optional(),
    is_long_term_position: z
      .boolean()
      .describe('**[READ-ONLY]** Indicates if this position was held for 2 years or more.')
      .readonly()
      .optional(),
    has_responsibilities: z
      .boolean()
      .describe('**[READ-ONLY]** Indicates if the position has responsibilities documented.')
      .readonly()
      .optional(),
    experience_level: zExperienceLevelEnum.optional(),
    is_recent_experience: z
      .boolean()
      .describe('**[READ-ONLY]** Indicates if this experience is recent (within the last 5 years).')
      .readonly()
      .optional(),
    calculated_years: z
      .number()
      .describe('**[READ-ONLY]** Calculated years of experience based on start and end dates.')
      .readonly()
      .optional(),
  })
  .describe(
    'Professional work experience record for instructors including positions, organizations, responsibilities, and employment duration'
  );

export const zApiResponseInstructorExperience = z.object({
  success: z.boolean().optional(),
  data: zInstructorExperience.optional(),
  message: z.string().optional(),
  error: z.record(z.unknown()).optional(),
});

/**
 * **[READ-ONLY]** Classification of education level based on qualification type.
 */
export const zEducationLevelEnum = z
  .enum(['CERTIFICATE', 'DIPLOMA', 'UNDERGRADUATE', 'POSTGRADUATE', 'DOCTORAL', 'OTHER'])
  .describe('**[READ-ONLY]** Classification of education level based on qualification type.');

/**
 * Educational qualification record for instructors including degrees, diplomas, certificates, and academic credentials
 */
export const zInstructorEducation = z
  .object({
    uuid: z
      .string()
      .uuid()
      .describe(
        '**[READ-ONLY]** Unique system identifier for the education record. Auto-generated by the system.'
      )
      .readonly()
      .optional(),
    instructor_uuid: z
      .string()
      .uuid()
      .describe(
        '**[REQUIRED]** Reference to the instructor profile UUID. Links education record to specific instructor.'
      ),
    qualification: z
      .string()
      .min(0)
      .max(255)
      .describe(
        '**[REQUIRED]** Name or title of the academic qualification, degree, diploma, or certificate obtained.'
      ),
    school_name: z
      .string()
      .min(0)
      .max(255)
      .describe(
        '**[REQUIRED]** Full name of the educational institution, university, college, or training organization.'
      ),
    year_completed: z
      .number()
      .int()
      .gte(1950)
      .lte(2030)
      .describe(
        '**[OPTIONAL]** Year when the qualification was completed or awarded. Must be a valid year not in the future.'
      )
      .optional(),
    certificate_number: z
      .string()
      .min(0)
      .max(100)
      .describe(
        '**[OPTIONAL]** Official certificate, diploma, or degree number issued by the educational institution.'
      )
      .optional(),
    created_date: z
      .string()
      .datetime()
      .describe(
        '**[READ-ONLY]** Timestamp when the education record was first created. Automatically set by the system.'
      )
      .readonly()
      .optional(),
    created_by: z
      .string()
      .describe('**[READ-ONLY]** Email or username of the user who created this education record.')
      .readonly()
      .optional(),
    updated_date: z
      .string()
      .datetime()
      .describe(
        '**[READ-ONLY]** Timestamp when the education record was last modified. Automatically updated by the system.'
      )
      .readonly()
      .optional(),
    updated_by: z
      .string()
      .describe(
        '**[READ-ONLY]** Email or username of the user who last modified this education record.'
      )
      .readonly()
      .optional(),
    full_description: z
      .string()
      .describe('**[READ-ONLY]** Complete description combining qualification, school, and year.')
      .readonly()
      .optional(),
    is_complete: z
      .boolean()
      .describe('**[READ-ONLY]** Indicates if the education record has all essential information.')
      .readonly()
      .optional(),
    is_recent_qualification: z
      .boolean()
      .describe(
        '**[READ-ONLY]** Indicates if this qualification was completed within the last 10 years.'
      )
      .readonly()
      .optional(),
    years_since_completion: z
      .number()
      .int()
      .describe('**[READ-ONLY]** Number of years since the qualification was completed.')
      .readonly()
      .optional(),
    education_level: zEducationLevelEnum.optional(),
    has_certificate_number: z
      .boolean()
      .describe(
        '**[READ-ONLY]** Indicates if the education record has a certificate number provided.'
      )
      .readonly()
      .optional(),
    formatted_completion: z
      .string()
      .describe('**[READ-ONLY]** Formatted string showing year of completion and school name.')
      .readonly()
      .optional(),
  })
  .describe(
    'Educational qualification record for instructors including degrees, diplomas, certificates, and academic credentials'
  );

export const zApiResponseInstructorEducation = z.object({
  success: z.boolean().optional(),
  data: zInstructorEducation.optional(),
  message: z.string().optional(),
  error: z.record(z.unknown()).optional(),
});

/**
 * **[READ-ONLY]** Current status of the document in the verification workflow.
 */
export const zStatusEnum2 = z
  .enum(['PENDING', 'APPROVED', 'REJECTED', 'EXPIRED', 'UNDER_REVIEW'])
  .describe('**[READ-ONLY]** Current status of the document in the verification workflow.');

/**
 * **[READ-ONLY]** Human-readable verification status of the document.
 */
export const zVerificationStatusEnum = z
  .enum(['VERIFIED', 'PENDING', 'REJECTED'])
  .describe('**[READ-ONLY]** Human-readable verification status of the document.');

/**
 * Document record for instructor credential verification including educational certificates, experience documents, and professional memberships
 */
export const zInstructorDocument = z
  .object({
    uuid: z
      .string()
      .uuid()
      .describe(
        '**[READ-ONLY]** Unique system identifier for the document record. Auto-generated by the system.'
      )
      .readonly()
      .optional(),
    instructor_uuid: z
      .string()
      .uuid()
      .describe(
        '**[REQUIRED]** Reference to the instructor profile UUID. Links document to specific instructor.'
      ),
    document_type_uuid: z
      .string()
      .uuid()
      .describe(
        '**[REQUIRED]** Reference to the document type UUID. Defines the category and validation rules for this document.'
      ),
    education_uuid: z
      .string()
      .uuid()
      .describe(
        '**[OPTIONAL]** Reference to specific education record UUID if this document supports an educational qualification.'
      )
      .optional(),
    experience_uuid: z
      .string()
      .uuid()
      .describe(
        '**[OPTIONAL]** Reference to specific experience record UUID if this document supports work experience.'
      )
      .optional(),
    membership_uuid: z
      .string()
      .uuid()
      .describe(
        '**[OPTIONAL]** Reference to specific membership record UUID if this document supports professional body membership.'
      )
      .optional(),
    original_filename: z
      .string()
      .min(0)
      .max(255)
      .describe(
        '**[REQUIRED]** Original filename as uploaded by the user. Preserved for user reference and display purposes.'
      ),
    title: z
      .string()
      .min(0)
      .max(255)
      .describe(
        '**[REQUIRED]** Descriptive title for the document. Used for identification and display in document lists.'
      ),
    description: z
      .string()
      .min(0)
      .max(2000)
      .describe(
        '**[OPTIONAL]** Detailed description of the document content and its relevance to instructor qualifications.'
      )
      .optional(),
    status: zStatusEnum2.optional(),
    expiry_date: z
      .string()
      .date()
      .describe(
        '**[OPTIONAL]** Expiry date of the document if applicable. Used for certificates and time-limited credentials.'
      )
      .optional(),
    stored_filename: z
      .string()
      .describe(
        '**[READ-ONLY]** System-generated filename for secure storage. Used internally for file system operations.'
      )
      .readonly()
      .optional(),
    file_path: z
      .string()
      .describe(
        '**[READ-ONLY]** Full file system path where the document is stored. Used for internal file operations.'
      )
      .readonly()
      .optional(),
    file_size_bytes: z.coerce
      .bigint()
      .gte(BigInt(1))
      .describe('**[READ-ONLY]** File size in bytes. Automatically calculated during upload.')
      .readonly()
      .optional(),
    mime_type: z
      .string()
      .describe(
        '**[READ-ONLY]** MIME type of the uploaded file. Automatically detected during upload.'
      )
      .readonly()
      .optional(),
    file_hash: z
      .string()
      .describe(
        '**[READ-ONLY]** SHA-256 hash of the file content. Used for integrity verification and duplicate detection.'
      )
      .readonly()
      .optional(),
    upload_date: z
      .string()
      .datetime()
      .describe(
        '**[READ-ONLY]** Timestamp when the document was uploaded. Automatically set by the system.'
      )
      .readonly()
      .optional(),
    is_verified: z
      .boolean()
      .describe(
        '**[READ-ONLY]** Verification status of the document. True if verified by admin, false if not verified, null if pending.'
      )
      .readonly()
      .optional(),
    verified_by: z
      .string()
      .describe(
        '**[READ-ONLY]** Email or username of the administrator who verified this document.'
      )
      .readonly()
      .optional(),
    verified_at: z
      .string()
      .datetime()
      .describe(
        '**[READ-ONLY]** Timestamp when the document was verified. Set automatically when verification is completed.'
      )
      .readonly()
      .optional(),
    verification_notes: z
      .string()
      .max(2000)
      .describe(
        '**[READ-ONLY]** Notes or comments from the verification process. Includes details about verification outcome.'
      )
      .readonly()
      .optional(),
    created_date: z
      .string()
      .datetime()
      .describe(
        '**[READ-ONLY]** Timestamp when the document record was first created. Automatically set by the system.'
      )
      .readonly()
      .optional(),
    created_by: z
      .string()
      .describe('**[READ-ONLY]** Email or username of the user who created this document record.')
      .readonly()
      .optional(),
    updated_date: z
      .string()
      .datetime()
      .describe(
        '**[READ-ONLY]** Timestamp when the document record was last modified. Automatically updated by the system.'
      )
      .readonly()
      .optional(),
    updated_by: z
      .string()
      .describe(
        '**[READ-ONLY]** Email or username of the user who last modified this document record.'
      )
      .readonly()
      .optional(),
    is_expired: z
      .boolean()
      .describe('**[READ-ONLY]** Indicates if the document has expired based on the expiry date.')
      .readonly()
      .optional(),
    file_size_formatted: z
      .string()
      .describe('**[READ-ONLY]** Human-readable formatted file size.')
      .readonly()
      .optional(),
    days_until_expiry: z
      .number()
      .int()
      .describe(
        '**[READ-ONLY]** Number of days until document expiry. Returns null if no expiry date or already expired.'
      )
      .readonly()
      .optional(),
    is_pending_verification: z
      .boolean()
      .describe('**[READ-ONLY]** Indicates if the document is pending verification.')
      .readonly()
      .optional(),
    has_expiry_date: z
      .boolean()
      .describe('**[READ-ONLY]** Indicates if the document has an expiry date configured.')
      .readonly()
      .optional(),
    verification_status: zVerificationStatusEnum.optional(),
  })
  .describe(
    'Document record for instructor credential verification including educational certificates, experience documents, and professional memberships'
  );

export const zApiResponseInstructorDocument = z.object({
  success: z.boolean().optional(),
  data: zInstructorDocument.optional(),
  message: z.string().optional(),
  error: z.record(z.unknown()).optional(),
});

/**
 * **[REQUIRED]** Type of availability pattern.
 */
export const zAvailabilityTypeEnum = z
  .enum(['daily', 'weekly', 'monthly', 'custom'])
  .describe('**[REQUIRED]** Type of availability pattern.');

export const zLocalTime = z.object({
  hour: z.number().int().optional(),
  minute: z.number().int().optional(),
  second: z.number().int().optional(),
  nano: z.number().int().optional(),
});

/**
 * Instructor availability slot that defines when an instructor is available for teaching
 */
export const zAvailabilitySlot = z
  .object({
    uuid: z
      .string()
      .uuid()
      .describe(
        '**[READ-ONLY]** Unique system identifier for the availability slot. Auto-generated by the system.'
      )
      .readonly()
      .optional(),
    instructor_uuid: z
      .string()
      .uuid()
      .describe('**[REQUIRED]** Reference to the instructor UUID for this availability slot.'),
    availability_type: zAvailabilityTypeEnum,
    day_of_week: z
      .number()
      .int()
      .gte(1)
      .lte(7)
      .describe(
        '**[CONDITIONAL]** Day of the week (1=Monday, 7=Sunday). Required for weekly availability type.'
      )
      .optional(),
    day_of_month: z
      .number()
      .int()
      .gte(1)
      .lte(31)
      .describe(
        '**[CONDITIONAL]** Day of the month (1-31). Required for monthly availability type.'
      )
      .optional(),
    specific_date: z
      .string()
      .date()
      .describe(
        '**[CONDITIONAL]** Specific date for one-time availability. Used with custom patterns.'
      )
      .optional(),
    start_time: zLocalTime,
    end_time: zLocalTime,
    custom_pattern: z
      .string()
      .max(255)
      .describe(
        '**[CONDITIONAL]** Custom pattern expression for complex availability rules. Required for custom availability type.'
      )
      .optional(),
    is_available: z
      .boolean()
      .describe(
        '**[OPTIONAL]** Whether this slot represents availability (true) or blocked time (false).'
      )
      .optional(),
    recurrence_interval: z
      .number()
      .int()
      .gte(1)
      .lte(52)
      .describe(
        '**[OPTIONAL]** Interval for recurrence. For example, 2 means every 2 weeks for weekly type.'
      )
      .optional(),
    effective_start_date: z
      .string()
      .date()
      .describe('**[OPTIONAL]** Date when this availability pattern becomes effective.')
      .optional(),
    effective_end_date: z
      .string()
      .date()
      .describe('**[OPTIONAL]** Date when this availability pattern expires.')
      .optional(),
    color_code: z
      .string()
      .regex(/^#[0-9A-Fa-f]{6}$/)
      .describe(
        '**[OPTIONAL]** Hex color code for blocked time visualization (e.g., for categorizing different types of blocked times).'
      )
      .optional(),
    created_date: z
      .string()
      .datetime()
      .describe(
        '**[READ-ONLY]** Timestamp when the availability slot was first created. Automatically set by the system.'
      )
      .readonly()
      .optional(),
    updated_date: z
      .string()
      .datetime()
      .describe(
        '**[READ-ONLY]** Timestamp when the availability slot was last modified. Automatically updated by the system.'
      )
      .readonly()
      .optional(),
    created_by: z
      .string()
      .describe('**[READ-ONLY]** Email or username of the user who created this availability slot.')
      .readonly()
      .optional(),
    updated_by: z
      .string()
      .describe(
        '**[READ-ONLY]** Email or username of the user who last modified this availability slot.'
      )
      .readonly()
      .optional(),
    duration_minutes: z.coerce
      .bigint()
      .describe('**[READ-ONLY]** Duration of the availability slot in minutes.')
      .readonly()
      .optional(),
    duration_formatted: z
      .string()
      .describe('**[READ-ONLY]** Human-readable formatted duration.')
      .readonly()
      .optional(),
    time_range: z
      .string()
      .describe('**[READ-ONLY]** Human-readable time range.')
      .readonly()
      .optional(),
    is_currently_active: z
      .boolean()
      .describe(
        '**[READ-ONLY]** Indicates if the availability slot is currently active based on effective dates.'
      )
      .readonly()
      .optional(),
    availability_description: z
      .string()
      .describe('**[READ-ONLY]** Human-readable description of the availability pattern.')
      .readonly()
      .optional(),
  })
  .describe(
    'Instructor availability slot that defines when an instructor is available for teaching'
  );

export const zApiResponseAvailabilitySlot = z.object({
  success: z.boolean().optional(),
  data: zAvailabilitySlot.optional(),
  message: z.string().optional(),
  error: z.record(z.unknown()).optional(),
});

/**
 * **[REQUIRED]** Resource category.
 */
export const zRequirementTypeEnum2 = z
  .enum(['material', 'equipment', 'facility', 'other'])
  .describe('**[REQUIRED]** Resource category.');

/**
 * **[OPTIONAL]** Party responsible for providing this requirement.
 */
export const zProvidedByEnum = z
  .enum(['course_creator', 'instructor', 'organisation', 'student'])
  .describe('**[OPTIONAL]** Party responsible for providing this requirement.');

/**
 * Operational resources that must be available when delivering the course (materials, equipment, facilities).
 */
export const zCourseTrainingRequirement = z
  .object({
    uuid: z
      .string()
      .uuid()
      .describe('**[READ-ONLY]** Identifier for this training requirement.')
      .readonly()
      .optional(),
    course_uuid: z
      .string()
      .uuid()
      .describe('**[REQUIRED]** Course identifier this requirement belongs to.'),
    requirement_type: zRequirementTypeEnum2,
    name: z
      .string()
      .min(0)
      .max(255)
      .describe('**[REQUIRED]** Concise label for the resource or material.'),
    description: z
      .string()
      .min(0)
      .max(2000)
      .describe('**[OPTIONAL]** Extra details or specifications for the resource.')
      .optional(),
    quantity: z
      .number()
      .int()
      .gte(1)
      .describe('**[OPTIONAL]** Quantity needed for each class session.')
      .optional(),
    unit: z
      .string()
      .min(0)
      .max(50)
      .describe('**[OPTIONAL]** Unit that the quantity refers to.')
      .optional(),
    provided_by: zProvidedByEnum.optional(),
    is_mandatory: z
      .boolean()
      .describe('**[OPTIONAL]** Indicates if the requirement is mandatory.')
      .optional(),
    created_date: z
      .string()
      .datetime()
      .describe('**[READ-ONLY]** Timestamp when the requirement was created.')
      .readonly()
      .optional(),
    created_by: z
      .string()
      .describe('**[READ-ONLY]** User who created the requirement.')
      .readonly()
      .optional(),
    updated_date: z
      .string()
      .datetime()
      .describe('**[READ-ONLY]** Timestamp when the requirement was last updated.')
      .readonly()
      .optional(),
    updated_by: z
      .string()
      .describe('**[READ-ONLY]** User who last updated the requirement.')
      .readonly()
      .optional(),
  })
  .describe(
    'Operational resources that must be available when delivering the course (materials, equipment, facilities).'
  );

/**
 * Complete course with metadata, content organization, and publication status supporting multiple categories
 */
export const zCourse = z
  .object({
    uuid: z
      .string()
      .uuid()
      .describe(
        '**[READ-ONLY]** Unique system identifier for the course. Auto-generated by the system.'
      )
      .readonly()
      .optional(),
    name: z
      .string()
      .min(0)
      .max(255)
      .describe(
        '**[REQUIRED]** Course title. Should be descriptive and engaging for potential students.'
      ),
    course_creator_uuid: z
      .string()
      .uuid()
      .describe(
        "**[REQUIRED]** Reference to the course creator's UUID who created and owns this course."
      ),
    category_uuids: z
      .array(z.string().uuid())
      .describe(
        '**[OPTIONAL]** List of category UUIDs for organizing the course. A course can belong to multiple categories.'
      )
      .optional(),
    difficulty_uuid: z
      .string()
      .uuid()
      .describe(
        '**[OPTIONAL]** Reference to the difficulty level UUID indicating course complexity.'
      )
      .optional(),
    description: z
      .string()
      .min(0)
      .max(2000)
      .describe(
        '**[OPTIONAL]** Detailed course description explaining content, approach, and outcomes.'
      )
      .optional(),
    objectives: z
      .string()
      .min(0)
      .max(1000)
      .describe(
        '**[OPTIONAL]** Learning objectives and goals students will achieve upon completion.'
      )
      .optional(),
    prerequisites: z
      .string()
      .min(0)
      .max(1000)
      .describe(
        '**[OPTIONAL]** Required knowledge and skills students should have before taking this course.'
      )
      .optional(),
    duration_hours: z.number().int().gte(0).describe('**[REQUIRED]** Course duration in hours.'),
    duration_minutes: z
      .number()
      .int()
      .gte(0)
      .lte(59)
      .describe('**[REQUIRED]** Additional course duration in minutes (0-59).'),
    class_limit: z
      .number()
      .int()
      .gte(1)
      .describe('**[OPTIONAL]** Maximum number of students that can enroll in the course.')
      .optional(),
    price: z
      .number()
      .gte(0)
      .describe(
        '**[OPTIONAL]** Legacy course list price. Leave blank while pricing workflows are under review.'
      )
      .optional(),
    minimum_training_fee: z
      .number()
      .gte(0)
      .describe(
        '**[OPTIONAL]** Minimum training fee that any instructor-led class for this course must meet or exceed.'
      )
      .optional(),
    creator_share_percentage: z
      .number()
      .gte(0)
      .lte(100)
      .describe(
        '**[REQUIRED]** Percentage of training revenue allocated to the course creator. Must work with instructor share to total 100%.'
      ),
    instructor_share_percentage: z
      .number()
      .gte(0)
      .lte(100)
      .describe(
        '**[REQUIRED]** Percentage of training revenue allocated to instructors. Must work with creator share to total 100%.'
      ),
    revenue_share_notes: z
      .string()
      .min(0)
      .max(1000)
      .describe(
        '**[OPTIONAL]** Additional context explaining how revenue is allocated between course creator and instructors.'
      )
      .optional(),
    age_lower_limit: z
      .number()
      .int()
      .gte(1)
      .lte(120)
      .describe('**[OPTIONAL]** Minimum age requirement for course enrollment.')
      .optional(),
    age_upper_limit: z
      .number()
      .int()
      .gte(1)
      .lte(120)
      .describe('**[OPTIONAL]** Maximum age requirement for course enrollment.')
      .optional(),
    thumbnail_url: z
      .string()
      .url()
      .min(0)
      .max(500)
      .describe('**[OPTIONAL]** URL to course thumbnail image for course listings and previews.')
      .optional(),
    intro_video_url: z
      .string()
      .url()
      .min(0)
      .max(500)
      .describe(
        '**[OPTIONAL]** URL to course introduction video for marketing and preview purposes.'
      )
      .optional(),
    banner_url: z
      .string()
      .url()
      .min(0)
      .max(500)
      .describe('**[OPTIONAL]** URL to course banner image for detailed course pages.')
      .optional(),
    status: zSchemaEnum,
    active: z
      .boolean()
      .describe(
        '**[OPTIONAL]** Indicates if the course is actively available to students. Can only be true for published courses.'
      )
      .optional(),
    training_requirements: z
      .array(zCourseTrainingRequirement)
      .describe(
        '**[READ-ONLY]** Structured resources required to deliver this course during instructor-led training sessions.'
      )
      .readonly()
      .optional(),
    category_names: z
      .array(z.string())
      .describe(
        '**[READ-ONLY]** List of category names this course belongs to. Computed from category mappings.'
      )
      .readonly()
      .optional(),
    created_date: z
      .string()
      .datetime()
      .describe(
        '**[READ-ONLY]** Timestamp when the course was created. Automatically set by the system.'
      )
      .readonly()
      .optional(),
    created_by: z
      .string()
      .describe(
        '**[READ-ONLY]** Email or username of the user who created this course. Used for audit trails.'
      )
      .readonly()
      .optional(),
    updated_date: z
      .string()
      .datetime()
      .describe(
        '**[READ-ONLY]** Timestamp when the course was last modified. Automatically updated by the system.'
      )
      .readonly()
      .optional(),
    updated_by: z
      .string()
      .describe(
        '**[READ-ONLY]** Email or username of the user who last modified this course. Used for audit trails.'
      )
      .readonly()
      .optional(),
    is_free: z
      .boolean()
      .describe('**[READ-ONLY]** Indicates if the course is offered for free.')
      .readonly()
      .optional(),
    accepts_new_enrollments: z
      .boolean()
      .describe(
        '**[READ-ONLY]** Indicates if the course is currently accepting new student enrollments.'
      )
      .readonly()
      .optional(),
    is_published: z
      .boolean()
      .describe('**[READ-ONLY]** Indicates if the course is published and discoverable.')
      .readonly()
      .optional(),
    is_draft: z
      .boolean()
      .describe('**[READ-ONLY]** Indicates if the course is still in draft mode.')
      .readonly()
      .optional(),
    is_archived: z
      .boolean()
      .describe('**[READ-ONLY]** Indicates if the course is archived and no longer available.')
      .readonly()
      .optional(),
    is_in_review: z
      .boolean()
      .describe('**[READ-ONLY]** Indicates if the course is currently under review.')
      .readonly()
      .optional(),
    total_duration_display: z
      .string()
      .describe('**[READ-ONLY]** Human-readable format of total course duration.')
      .readonly()
      .optional(),
    has_multiple_categories: z
      .boolean()
      .describe('**[READ-ONLY]** Indicates if the course belongs to multiple categories.')
      .readonly()
      .optional(),
    category_count: z
      .number()
      .int()
      .describe('**[READ-ONLY]** Number of categories this course belongs to.')
      .readonly()
      .optional(),
    lifecycle_stage: z
      .string()
      .describe(
        "**[READ-ONLY]** Human-readable description of the course's current lifecycle stage."
      )
      .readonly()
      .optional(),
  })
  .describe(
    'Complete course with metadata, content organization, and publication status supporting multiple categories'
  );

export const zApiResponseCourse = z.object({
  success: z.boolean().optional(),
  data: zCourse.optional(),
  message: z.string().optional(),
  error: z.record(z.unknown()).optional(),
});

export const zApiResponseCourseTrainingRequirement = z.object({
  success: z.boolean().optional(),
  data: zCourseTrainingRequirement.optional(),
  message: z.string().optional(),
  error: z.record(z.unknown()).optional(),
});

/**
 * Association between a course and a rubric for assessment purposes
 */
export const zCourseRubricAssociation = z
  .object({
    uuid: z
      .string()
      .uuid()
      .describe('**[READ-ONLY]** Unique identifier for this association')
      .readonly()
      .optional(),
    course_uuid: z
      .string()
      .uuid()
      .describe('**[REQUIRED]** UUID of the course that will use this rubric'),
    rubric_uuid: z
      .string()
      .uuid()
      .describe('**[REQUIRED]** UUID of the rubric to be associated with the course'),
    associated_by: z
      .string()
      .uuid()
      .describe('**[REQUIRED]** UUID of the instructor who created this association'),
    is_primary_rubric: z
      .boolean()
      .describe('**[OPTIONAL]** Whether this is the primary rubric for the course')
      .optional(),
    usage_context: z
      .string()
      .min(0)
      .max(100)
      .describe('**[OPTIONAL]** Context of rubric usage (e.g., midterm, final, assignment)')
      .optional(),
    association_date: z
      .string()
      .datetime()
      .describe('**[READ-ONLY]** Timestamp when this association was created')
      .readonly()
      .optional(),
    created_date: z
      .string()
      .datetime()
      .describe('**[READ-ONLY]** Timestamp when the association was created')
      .readonly()
      .optional(),
    created_by: z
      .string()
      .describe('**[READ-ONLY]** User who created this association')
      .readonly()
      .optional(),
    updated_date: z
      .string()
      .datetime()
      .describe('**[READ-ONLY]** Timestamp when the association was last updated')
      .readonly()
      .optional(),
    updated_by: z
      .string()
      .describe('**[READ-ONLY]** User who last updated this association')
      .readonly()
      .optional(),
  })
  .describe('Association between a course and a rubric for assessment purposes');

export const zApiResponseCourseRubricAssociation = z.object({
  success: z.boolean().optional(),
  data: zCourseRubricAssociation.optional(),
  message: z.string().optional(),
  error: z.record(z.unknown()).optional(),
});

/**
 * Course prerequisites and participation requirements
 */
export const zCourseRequirement = z
  .object({
    uuid: z
      .string()
      .uuid()
      .describe(
        '**[READ-ONLY]** Unique system identifier for the course requirement. Auto-generated by the system.'
      )
      .readonly()
      .optional(),
    course_uuid: z
      .string()
      .uuid()
      .describe('**[REQUIRED]** Reference to the course UUID that this requirement applies to.'),
    requirement_type: zRequirementTypeEnum,
    requirement_text: z
      .string()
      .min(0)
      .max(1000)
      .describe('**[REQUIRED]** Detailed description of the specific requirement or prerequisite.'),
    is_mandatory: z
      .boolean()
      .describe(
        '**[OPTIONAL]** Indicates if this requirement is mandatory or optional for course participation.'
      )
      .optional(),
    created_date: z
      .string()
      .datetime()
      .describe(
        '**[READ-ONLY]** Timestamp when the requirement was created. Automatically set by the system.'
      )
      .readonly()
      .optional(),
    created_by: z
      .string()
      .describe(
        '**[READ-ONLY]** Email or username of the user who created this requirement. Used for audit trails.'
      )
      .readonly()
      .optional(),
    updated_date: z
      .string()
      .datetime()
      .describe(
        '**[READ-ONLY]** Timestamp when the requirement was last modified. Automatically updated by the system.'
      )
      .readonly()
      .optional(),
    updated_by: z
      .string()
      .describe(
        '**[READ-ONLY]** Email or username of the user who last modified this requirement. Used for audit trails.'
      )
      .readonly()
      .optional(),
  })
  .describe('Course prerequisites and participation requirements');

export const zApiResponseCourseRequirement = z.object({
  success: z.boolean().optional(),
  data: zCourseRequirement.optional(),
  message: z.string().optional(),
  error: z.record(z.unknown()).optional(),
});

/**
 * Individual lesson within a course containing structured learning content
 */
export const zLesson = z
  .object({
    uuid: z
      .string()
      .uuid()
      .describe(
        '**[READ-ONLY]** Unique system identifier for the lesson. Auto-generated by the system.'
      )
      .readonly()
      .optional(),
    course_uuid: z
      .string()
      .uuid()
      .describe('**[REQUIRED]** Reference to the parent course UUID that contains this lesson.'),
    lesson_number: z
      .number()
      .int()
      .gte(1)
      .describe(
        '**[REQUIRED]** Sequential number of the lesson within the course. Must be unique per course.'
      ),
    title: z
      .string()
      .min(0)
      .max(255)
      .describe(
        '**[REQUIRED]** Descriptive title of the lesson that clearly indicates the learning content.'
      ),
    duration_hours: z
      .number()
      .int()
      .gte(0)
      .describe('**[REQUIRED]** Estimated lesson duration in hours.'),
    duration_minutes: z
      .number()
      .int()
      .gte(0)
      .lte(59)
      .describe('**[REQUIRED]** Additional lesson duration in minutes (0-59).'),
    description: z
      .string()
      .min(0)
      .max(1000)
      .describe(
        '**[OPTIONAL]** Detailed description of the lesson content and what students will learn.'
      )
      .optional(),
    learning_objectives: z
      .string()
      .min(0)
      .max(500)
      .describe('**[OPTIONAL]** Specific learning objectives and outcomes for this lesson.')
      .optional(),
    status: zStatusEnum,
    active: z
      .boolean()
      .describe(
        '**[OPTIONAL]** Indicates if the lesson is actively available to students. Can only be true for published lessons.'
      )
      .optional(),
    created_date: z
      .string()
      .datetime()
      .describe(
        '**[READ-ONLY]** Timestamp when the lesson was created. Automatically set by the system.'
      )
      .readonly()
      .optional(),
    created_by: z
      .string()
      .describe(
        '**[READ-ONLY]** Email or username of the user who created this lesson. Used for audit trails.'
      )
      .readonly()
      .optional(),
    updated_date: z
      .string()
      .datetime()
      .describe(
        '**[READ-ONLY]** Timestamp when the lesson was last modified. Automatically updated by the system.'
      )
      .readonly()
      .optional(),
    updated_by: z
      .string()
      .describe(
        '**[READ-ONLY]** Email or username of the user who last modified this lesson. Used for audit trails.'
      )
      .readonly()
      .optional(),
    is_published: z
      .boolean()
      .describe('**[READ-ONLY]** Indicates if the lesson is published and accessible to students.')
      .readonly()
      .optional(),
    duration_display: z
      .string()
      .describe('**[READ-ONLY]** Human-readable format of lesson duration.')
      .readonly()
      .optional(),
    lesson_sequence: z
      .string()
      .describe('**[READ-ONLY]** Formatted lesson sequence for display purposes.')
      .readonly()
      .optional(),
  })
  .describe('Individual lesson within a course containing structured learning content');

export const zApiResponseLesson = z.object({
  success: z.boolean().optional(),
  data: zLesson.optional(),
  message: z.string().optional(),
  error: z.record(z.unknown()).optional(),
});

/**
 * Individual content item within a lesson supporting various media types
 */
export const zLessonContent = z
  .object({
    uuid: z
      .string()
      .uuid()
      .describe(
        '**[READ-ONLY]** Unique system identifier for the lesson content. Auto-generated by the system.'
      )
      .readonly()
      .optional(),
    lesson_uuid: z
      .string()
      .uuid()
      .describe('**[REQUIRED]** Reference to the lesson UUID that contains this content.'),
    content_type_uuid: z
      .string()
      .uuid()
      .describe(
        '**[REQUIRED]** Reference to the content type UUID defining the format and restrictions.'
      ),
    title: z
      .string()
      .min(0)
      .max(255)
      .describe('**[REQUIRED]** Descriptive title of the content item for student navigation.'),
    description: z
      .string()
      .min(0)
      .max(1000)
      .describe('**[OPTIONAL]** Detailed description of the content and its learning purpose.')
      .optional(),
    content_text: z
      .string()
      .describe(
        '**[OPTIONAL]** Text content for text-based content types. Null for file-based content.'
      )
      .optional(),
    file_url: z
      .string()
      .url()
      .min(0)
      .max(500)
      .describe('**[OPTIONAL]** URL to the uploaded content file. Null for text-based content.')
      .optional(),
    display_order: z
      .number()
      .int()
      .gte(1)
      .describe(
        '**[REQUIRED]** Display order of content within the lesson for sequential presentation.'
      ),
    is_required: z
      .boolean()
      .describe('**[OPTIONAL]** Indicates if this content is required for lesson completion.')
      .optional(),
    file_size_bytes: z.coerce
      .bigint()
      .gte(BigInt(0))
      .describe('**[READ-ONLY]** Size of the uploaded file in bytes. Null for text content.')
      .readonly()
      .optional(),
    mime_type: z
      .string()
      .describe(
        '**[READ-ONLY]** MIME type of the uploaded file. Automatically detected during upload.'
      )
      .readonly()
      .optional(),
    created_date: z
      .string()
      .datetime()
      .describe(
        '**[READ-ONLY]** Timestamp when the content was created. Automatically set by the system.'
      )
      .readonly()
      .optional(),
    created_by: z
      .string()
      .describe(
        '**[READ-ONLY]** Email or username of the user who created this content. Used for audit trails.'
      )
      .readonly()
      .optional(),
    updated_date: z
      .string()
      .datetime()
      .describe(
        '**[READ-ONLY]** Timestamp when the content was last modified. Automatically updated by the system.'
      )
      .readonly()
      .optional(),
    updated_by: z
      .string()
      .describe(
        '**[READ-ONLY]** Email or username of the user who last modified this content. Used for audit trails.'
      )
      .readonly()
      .optional(),
    content_category: z
      .string()
      .describe('**[READ-ONLY]** Category of content based on its type and format.')
      .readonly()
      .optional(),
    file_size_display: z
      .string()
      .describe('**[READ-ONLY]** Human-readable format of file size.')
      .readonly()
      .optional(),
  })
  .describe('Individual content item within a lesson supporting various media types');

export const zApiResponseLessonContent = z.object({
  success: z.boolean().optional(),
  data: zLessonContent.optional(),
  message: z.string().optional(),
  error: z.record(z.unknown()).optional(),
});

/**
 * Course-level assessment component with weighting for final grade calculation
 */
export const zCourseAssessment = z
  .object({
    uuid: z
      .string()
      .uuid()
      .describe(
        '**[READ-ONLY]** Unique system identifier for the course assessment. Auto-generated by the system.'
      )
      .readonly()
      .optional(),
    course_uuid: z
      .string()
      .uuid()
      .describe('**[REQUIRED]** Reference to the course UUID that this assessment belongs to.'),
    assessment_type: z
      .string()
      .min(0)
      .max(50)
      .describe('**[REQUIRED]** Type of assessment component for categorization and processing.'),
    title: z
      .string()
      .min(0)
      .max(255)
      .describe(
        '**[REQUIRED]** Title of the assessment component that clearly describes its purpose.'
      ),
    description: z
      .string()
      .min(0)
      .max(1000)
      .describe('**[OPTIONAL]** Detailed description of the assessment criteria and expectations.')
      .optional(),
    weight_percentage: z
      .number()
      .gte(0)
      .lte(100)
      .describe(
        '**[REQUIRED]** Percentage weight of this assessment in the final grade calculation.'
      ),
    rubric_uuid: z
      .string()
      .uuid()
      .describe('**[OPTIONAL]** Reference to assessment rubric UUID for detailed grading criteria.')
      .optional(),
    is_required: z
      .boolean()
      .describe('**[OPTIONAL]** Indicates if this assessment is required for course completion.')
      .optional(),
    created_date: z
      .string()
      .datetime()
      .describe(
        '**[READ-ONLY]** Timestamp when the assessment was created. Automatically set by the system.'
      )
      .readonly()
      .optional(),
    created_by: z
      .string()
      .describe(
        '**[READ-ONLY]** Email or username of the user who created this assessment. Used for audit trails.'
      )
      .readonly()
      .optional(),
    updated_date: z
      .string()
      .datetime()
      .describe(
        '**[READ-ONLY]** Timestamp when the assessment was last modified. Automatically updated by the system.'
      )
      .readonly()
      .optional(),
    updated_by: z
      .string()
      .describe(
        '**[READ-ONLY]** Email or username of the user who last modified this assessment. Used for audit trails.'
      )
      .readonly()
      .optional(),
    assessment_category: z
      .string()
      .describe('**[READ-ONLY]** Category classification of the assessment type.')
      .readonly()
      .optional(),
    weight_display: z
      .string()
      .describe('**[READ-ONLY]** Human-readable format of the weight percentage.')
      .readonly()
      .optional(),
    is_major_assessment: z
      .boolean()
      .describe('**[READ-ONLY]** Indicates if this is a major assessment component.')
      .readonly()
      .optional(),
    contribution_level: z
      .string()
      .describe('**[READ-ONLY]** Level of contribution to final grade based on weight.')
      .readonly()
      .optional(),
  })
  .describe('Course-level assessment component with weighting for final grade calculation');

export const zApiResponseCourseAssessment = z.object({
  success: z.boolean().optional(),
  data: zCourseAssessment.optional(),
  message: z.string().optional(),
  error: z.record(z.unknown()).optional(),
});

/**
 * Course creator profile for users dedicated to educational content creation
 */
export const zCourseCreator = z
  .object({
    uuid: z
      .string()
      .uuid()
      .describe(
        '**[READ-ONLY]** Unique system identifier for the course creator profile. Auto-generated by the system.'
      )
      .readonly()
      .optional(),
    user_uuid: z
      .string()
      .uuid()
      .describe(
        '**[REQUIRED]** Reference to the base user account UUID. Links course creator profile to user authentication and personal details.'
      ),
    full_name: z
      .string()
      .min(1)
      .max(255)
      .describe(
        '**[REQUIRED]** Complete name of the course creator. Used in course authorship and creator profiles.'
      ),
    bio: z
      .string()
      .min(0)
      .max(2000)
      .describe(
        "**[OPTIONAL]** Professional biography describing course creator's background, expertise, and content creation philosophy. Used in creator profiles and course descriptions."
      )
      .optional(),
    professional_headline: z
      .string()
      .min(0)
      .max(500)
      .describe(
        "**[OPTIONAL]** Professional headline or title that summarizes course creator's expertise and role. Used in search results and creator listings."
      )
      .optional(),
    website: z
      .string()
      .url()
      .min(0)
      .max(500)
      .describe(
        "**[OPTIONAL]** Professional website or portfolio URL. Used to showcase course creator's work and additional credentials."
      )
      .optional(),
    admin_verified: z
      .boolean()
      .describe(
        '**[READ-ONLY]** Indicates whether the course creator has been verified by an administrator. True if verified, false if not verified.'
      )
      .readonly()
      .optional(),
    created_date: z
      .string()
      .datetime()
      .describe(
        '**[READ-ONLY]** Timestamp when the course creator profile was first created. Automatically set by the system.'
      )
      .readonly()
      .optional(),
    created_by: z
      .string()
      .describe(
        '**[READ-ONLY]** Email or username of the user who created this course creator profile. Used for audit trails and administrative purposes.'
      )
      .readonly()
      .optional(),
    updated_date: z
      .string()
      .datetime()
      .describe(
        '**[READ-ONLY]** Timestamp when the course creator profile was last modified. Automatically updated by the system on any changes.'
      )
      .readonly()
      .optional(),
    updated_by: z
      .string()
      .describe(
        '**[READ-ONLY]** Email or username of the user who last modified this course creator profile. Used for audit trails and administrative purposes.'
      )
      .readonly()
      .optional(),
    is_profile_complete: z
      .boolean()
      .describe(
        '**[READ-ONLY]** Indicates if the course creator profile is considered complete. Requires bio and professional headline.'
      )
      .readonly()
      .optional(),
  })
  .describe('Course creator profile for users dedicated to educational content creation');

/**
 * Grading scale level with points and ordering for assessments
 */
export const zGradingLevel = z
  .object({
    uuid: z
      .string()
      .uuid()
      .describe(
        '**[READ-ONLY]** Unique system identifier for the grading level. Auto-generated by the system.'
      )
      .readonly()
      .optional(),
    name: z
      .string()
      .min(0)
      .max(50)
      .describe(
        '**[REQUIRED]** Name of the grading level. Must be unique across all grading levels.'
      ),
    points: z
      .number()
      .int()
      .gte(1)
      .lte(10)
      .describe(
        '**[REQUIRED]** Point value assigned to this grading level for scoring calculations.'
      ),
    level_order: z
      .number()
      .int()
      .gte(1)
      .lte(10)
      .describe(
        '**[REQUIRED]** Numeric order defining the grade hierarchy. Lower numbers indicate higher grades.'
      ),
    created_date: z
      .string()
      .datetime()
      .describe(
        '**[READ-ONLY]** Timestamp when the grading level was created. Automatically set by the system.'
      )
      .readonly()
      .optional(),
    created_by: z
      .string()
      .describe(
        '**[READ-ONLY]** Email or username of the user who created this grading level. Used for audit trails.'
      )
      .readonly()
      .optional(),
    updated_date: z
      .string()
      .datetime()
      .describe(
        '**[READ-ONLY]** Timestamp when the grading level was last modified. Automatically updated by the system.'
      )
      .readonly()
      .optional(),
    updated_by: z
      .string()
      .describe(
        '**[READ-ONLY]** Email or username of the user who last modified this grading level. Used for audit trails.'
      )
      .readonly()
      .optional(),
    grade_display: z
      .string()
      .describe('**[READ-ONLY]** Formatted display of grade level with complete information.')
      .readonly()
      .optional(),
  })
  .describe('Grading scale level with points and ordering for assessments');

export const zApiResponseGradingLevel = z.object({
  success: z.boolean().optional(),
  data: zGradingLevel.optional(),
  message: z.string().optional(),
  error: z.record(z.unknown()).optional(),
});

/**
 * Course difficulty level defining learning progression stages
 */
export const zDifficultyLevel = z
  .object({
    uuid: z
      .string()
      .uuid()
      .describe(
        '**[READ-ONLY]** Unique system identifier for the difficulty level. Auto-generated by the system.'
      )
      .readonly()
      .optional(),
    name: z
      .string()
      .min(0)
      .max(50)
      .describe(
        '**[REQUIRED]** Name of the difficulty level. Must be unique across all difficulty levels.'
      ),
    level_order: z
      .number()
      .int()
      .gte(1)
      .lte(10)
      .describe(
        '**[REQUIRED]** Numeric order defining the progression sequence. Lower numbers indicate easier levels.'
      ),
    description: z
      .string()
      .min(0)
      .max(500)
      .describe('**[OPTIONAL]** Detailed description of the difficulty level and target audience.')
      .optional(),
    created_date: z
      .string()
      .datetime()
      .describe(
        '**[READ-ONLY]** Timestamp when the difficulty level was created. Automatically set by the system.'
      )
      .readonly()
      .optional(),
    created_by: z
      .string()
      .describe(
        '**[READ-ONLY]** Email or username of the user who created this difficulty level. Used for audit trails.'
      )
      .readonly()
      .optional(),
    updated_date: z
      .string()
      .datetime()
      .describe(
        '**[READ-ONLY]** Timestamp when the difficulty level was last modified. Automatically updated by the system.'
      )
      .readonly()
      .optional(),
    updated_by: z
      .string()
      .describe(
        '**[READ-ONLY]** Email or username of the user who last modified this difficulty level. Used for audit trails.'
      )
      .readonly()
      .optional(),
    display_name: z
      .string()
      .describe('**[READ-ONLY]** Formatted display name including level order for UI presentation.')
      .readonly()
      .optional(),
    is_entry_level: z
      .boolean()
      .describe('**[READ-ONLY]** Indicates if this is the entry-level difficulty for beginners.')
      .readonly()
      .optional(),
  })
  .describe('Course difficulty level defining learning progression stages');

export const zApiResponseDifficultyLevel = z.object({
  success: z.boolean().optional(),
  data: zDifficultyLevel.optional(),
  message: z.string().optional(),
  error: z.record(z.unknown()).optional(),
});

/**
 * Supported content type with file format specifications and size limits
 */
export const zContentType = z
  .object({
    uuid: z
      .string()
      .uuid()
      .describe(
        '**[READ-ONLY]** Unique system identifier for the content type. Auto-generated by the system.'
      )
      .readonly()
      .optional(),
    name: z
      .string()
      .min(0)
      .max(50)
      .describe(
        '**[REQUIRED]** Name of the content type. Must be unique across all content types.'
      ),
    mime_types: z
      .array(z.string())
      .min(1)
      .max(2147483647)
      .describe('**[REQUIRED]** Array of supported MIME types for this content type.'),
    max_file_size_mb: z
      .number()
      .int()
      .gte(1)
      .describe('**[OPTIONAL]** Maximum file size allowed in megabytes. Null means no size limit.')
      .optional(),
    created_date: z
      .string()
      .datetime()
      .describe(
        '**[READ-ONLY]** Timestamp when the content type was created. Automatically set by the system.'
      )
      .readonly()
      .optional(),
    created_by: z
      .string()
      .describe(
        '**[READ-ONLY]** Email or username of the user who created this content type. Used for audit trails.'
      )
      .readonly()
      .optional(),
    updated_date: z
      .string()
      .datetime()
      .describe(
        '**[READ-ONLY]** Timestamp when the content type was last modified. Automatically updated by the system.'
      )
      .readonly()
      .optional(),
    updated_by: z
      .string()
      .describe(
        '**[READ-ONLY]** Email or username of the user who last modified this content type. Used for audit trails.'
      )
      .readonly()
      .optional(),
    upload_category: z
      .string()
      .describe('**[READ-ONLY]** Category for organizing uploads in the user interface.')
      .readonly()
      .optional(),
    is_media_type: z
      .boolean()
      .describe('**[READ-ONLY]** Indicates if this content type is for media files.')
      .readonly()
      .optional(),
    supported_formats: z
      .string()
      .describe('**[READ-ONLY]** Human-readable list of supported file formats.')
      .readonly()
      .optional(),
    size_limit_display: z
      .string()
      .describe('**[READ-ONLY]** Human-readable format of maximum file size.')
      .readonly()
      .optional(),
  })
  .describe('Supported content type with file format specifications and size limits');

export const zApiResponseContentType = z.object({
  success: z.boolean().optional(),
  data: zContentType.optional(),
  message: z.string().optional(),
  error: z.record(z.unknown()).optional(),
});

/**
 * Course category supporting hierarchical organization
 */
export const zCategory = z
  .object({
    uuid: z
      .string()
      .uuid()
      .describe(
        '**[READ-ONLY]** Unique system identifier for the category. Auto-generated by the system.'
      )
      .readonly()
      .optional(),
    name: z
      .string()
      .min(0)
      .max(100)
      .describe('**[REQUIRED]** Category name. Must be unique within the same parent category.'),
    description: z
      .string()
      .min(0)
      .max(500)
      .describe('**[OPTIONAL]** Detailed description of the category and its scope.')
      .optional(),
    parent_uuid: z
      .string()
      .uuid()
      .describe(
        '**[OPTIONAL]** Reference to parent category UUID for hierarchical organization. Null for root categories.'
      )
      .optional(),
    is_active: z
      .boolean()
      .describe(
        '**[OPTIONAL]** Indicates if the category is active and available for course assignment.'
      )
      .optional(),
    created_date: z
      .string()
      .datetime()
      .describe(
        '**[READ-ONLY]** Timestamp when the category was created. Automatically set by the system.'
      )
      .readonly()
      .optional(),
    created_by: z
      .string()
      .describe(
        '**[READ-ONLY]** Email or username of the user who created this category. Used for audit trails.'
      )
      .readonly()
      .optional(),
    updated_date: z
      .string()
      .datetime()
      .describe(
        '**[READ-ONLY]** Timestamp when the category was last modified. Automatically updated by the system.'
      )
      .readonly()
      .optional(),
    updated_by: z
      .string()
      .describe(
        '**[READ-ONLY]** Email or username of the user who last modified this category. Used for audit trails.'
      )
      .readonly()
      .optional(),
    is_root_category: z
      .boolean()
      .describe('**[READ-ONLY]** Indicates if this is a root category with no parent.')
      .readonly()
      .optional(),
    category_path: z
      .string()
      .describe(
        '**[READ-ONLY]** Hierarchical path showing category position in the tree structure.'
      )
      .readonly()
      .optional(),
  })
  .describe('Course category supporting hierarchical organization');

export const zApiResponseCategory = z.object({
  success: z.boolean().optional(),
  data: zCategory.optional(),
  message: z.string().optional(),
  error: z.record(z.unknown()).optional(),
});

/**
 * Payload for creating or updating catalog mappings
 */
export const zCommerceCatalogItemUpsertRequest = z
  .object({
    course_uuid: z.string().uuid().describe('Course UUID to associate').optional(),
    class_definition_uuid: z
      .string()
      .uuid()
      .describe('Class definition UUID to associate')
      .optional(),
    medusa_product_id: z.string().describe('Medusa product identifier'),
    medusa_variant_id: z.string().describe('Medusa variant identifier'),
    currency_code: z.string().describe('Currency code for the variant').optional(),
    active: z.boolean().describe('Active flag').optional(),
  })
  .describe('Payload for creating or updating catalog mappings');

/**
 * Mapping between Elimika courses/classes and Medusa catalog variants
 */
export const zCommerceCatalogItem = z
  .object({
    uuid: z.string().uuid().describe('Catalog item UUID').optional(),
    course_uuid: z
      .string()
      .uuid()
      .describe('Associated course UUID if mapping is course level')
      .optional(),
    class_definition_uuid: z
      .string()
      .uuid()
      .describe('Associated class definition UUID if mapping is class specific')
      .optional(),
    medusa_product_id: z.string().describe('Medusa product identifier').optional(),
    medusa_variant_id: z.string().describe('Medusa variant identifier').optional(),
    currency_code: z.string().describe('Currency code configured for the variant').optional(),
    active: z.boolean().describe('Whether this mapping is active').optional(),
    created_date: z.string().datetime().describe('Created timestamp').optional(),
    updated_date: z.string().datetime().describe('Last updated timestamp').optional(),
  })
  .describe('Mapping between Elimika courses/classes and Medusa catalog variants');

export const zApiResponseCommerceCatalogItem = z.object({
  success: z.boolean().optional(),
  data: zCommerceCatalogItem.optional(),
  message: z.string().optional(),
  error: z.record(z.unknown()).optional(),
});

/**
 * **[REQUIRED]** Default delivery format for the class.
 */
export const zLocationTypeEnum = z
  .enum(['ONLINE', 'IN_PERSON', 'HYBRID'])
  .describe('**[REQUIRED]** Default delivery format for the class.');

/**
 * Class definition template that defines what a class is, independent of scheduling
 */
export const zClassDefinition = z
  .object({
    uuid: z
      .string()
      .uuid()
      .describe(
        '**[READ-ONLY]** Unique system identifier for the class definition. Auto-generated by the system.'
      )
      .readonly()
      .optional(),
    title: z
      .string()
      .min(0)
      .max(255)
      .describe(
        '**[REQUIRED]** Title of the class definition. Used for identification and display.'
      ),
    description: z
      .string()
      .min(0)
      .max(2000)
      .describe(
        '**[OPTIONAL]** Detailed description of the class content, objectives, and what students will learn.'
      )
      .optional(),
    default_instructor_uuid: z
      .string()
      .uuid()
      .describe(
        '**[REQUIRED]** Reference to the default instructor UUID for this class definition.'
      ),
    organisation_uuid: z
      .string()
      .uuid()
      .describe(
        '**[OPTIONAL]** Reference to the organization UUID that owns this class definition.'
      )
      .optional(),
    course_uuid: z
      .string()
      .uuid()
      .describe(
        '**[OPTIONAL]** Reference to the course UUID if this class is part of a structured course.'
      )
      .optional(),
    training_fee: z
      .number()
      .gte(0)
      .describe(
        '**[OPTIONAL]** Training fee charged for sessions created from this class definition. Must meet the course minimum training fee when a course is linked.'
      )
      .optional(),
    default_start_time: zLocalTime,
    default_end_time: zLocalTime,
    location_type: zLocationTypeEnum,
    max_participants: z
      .number()
      .int()
      .gte(1)
      .lte(1000)
      .describe('**[OPTIONAL]** Maximum number of participants allowed in the class.')
      .optional(),
    allow_waitlist: z
      .boolean()
      .describe('**[OPTIONAL]** Whether to allow waitlisting when maximum capacity is reached.')
      .optional(),
    recurrence_pattern_uuid: z
      .string()
      .uuid()
      .describe('**[OPTIONAL]** Reference to the recurrence pattern UUID for repeating classes.')
      .optional(),
    is_active: z
      .boolean()
      .describe(
        '**[OPTIONAL]** Whether this class definition is currently active and available for scheduling.'
      )
      .optional(),
    created_date: z
      .string()
      .datetime()
      .describe(
        '**[READ-ONLY]** Timestamp when the class definition was first created. Automatically set by the system.'
      )
      .readonly()
      .optional(),
    updated_date: z
      .string()
      .datetime()
      .describe(
        '**[READ-ONLY]** Timestamp when the class definition was last modified. Automatically updated by the system.'
      )
      .readonly()
      .optional(),
    created_by: z
      .string()
      .describe('**[READ-ONLY]** Email or username of the user who created this class definition.')
      .readonly()
      .optional(),
    updated_by: z
      .string()
      .describe(
        '**[READ-ONLY]** Email or username of the user who last modified this class definition.'
      )
      .readonly()
      .optional(),
    is_standalone: z
      .boolean()
      .describe(
        '**[READ-ONLY]** Indicates if this is a standalone class not associated with any course.'
      )
      .readonly()
      .optional(),
    duration_minutes: z.coerce
      .bigint()
      .describe(
        '**[READ-ONLY]** Computed duration of the class in minutes based on start and end times.'
      )
      .readonly()
      .optional(),
    duration_formatted: z
      .string()
      .describe('**[READ-ONLY]** Human-readable formatted duration.')
      .readonly()
      .optional(),
    has_recurrence: z
      .boolean()
      .describe(
        '**[READ-ONLY]** Indicates if the class definition has a recurrence pattern configured.'
      )
      .readonly()
      .optional(),
    capacity_info: z
      .string()
      .describe(
        '**[READ-ONLY]** Human-readable capacity information including waitlist availability.'
      )
      .readonly()
      .optional(),
  })
  .describe('Class definition template that defines what a class is, independent of scheduling');

export const zApiResponseClassDefinition = z.object({
  success: z.boolean().optional(),
  data: zClassDefinition.optional(),
  message: z.string().optional(),
  error: z.record(z.unknown()).optional(),
});

/**
 * **[OPTIONAL]** Current status of the scheduled instance.
 */
export const zStatusEnum3 = z
  .enum(['SCHEDULED', 'ONGOING', 'COMPLETED', 'CANCELLED'])
  .describe('**[OPTIONAL]** Current status of the scheduled instance.');

/**
 * A scheduled class instance that represents a concrete class occurrence placed on the calendar
 */
export const zScheduledInstance = z
  .object({
    uuid: z
      .string()
      .uuid()
      .describe(
        '**[READ-ONLY]** Unique system identifier for the scheduled instance. Auto-generated by the system.'
      )
      .readonly()
      .optional(),
    class_definition_uuid: z
      .string()
      .uuid()
      .describe(
        '**[REQUIRED]** Reference to the class definition UUID that this instance is based on.'
      ),
    instructor_uuid: z
      .string()
      .uuid()
      .describe('**[REQUIRED]** Reference to the instructor UUID who will conduct this session.'),
    start_time: z
      .string()
      .datetime()
      .describe('**[REQUIRED]** Start date and time of the scheduled class session.'),
    end_time: z
      .string()
      .datetime()
      .describe('**[REQUIRED]** End date and time of the scheduled class session.'),
    timezone: z.string().describe('**[REQUIRED]** Timezone for the scheduled session.'),
    title: z
      .string()
      .describe(
        '**[REQUIRED]** Title of the class (cached from class definition for performance).'
      ),
    location_type: zLocationTypeEnum,
    max_participants: z
      .number()
      .int()
      .gte(1)
      .describe(
        '**[REQUIRED]** Maximum number of participants for this session (cached from class definition).'
      ),
    status: zStatusEnum3.optional(),
    cancellation_reason: z
      .string()
      .describe('**[OPTIONAL]** Reason for cancellation if status is CANCELLED.')
      .optional(),
    created_date: z
      .string()
      .datetime()
      .describe(
        '**[READ-ONLY]** Timestamp when the scheduled instance was first created. Automatically set by the system.'
      )
      .readonly()
      .optional(),
    updated_date: z
      .string()
      .datetime()
      .describe(
        '**[READ-ONLY]** Timestamp when the scheduled instance was last modified. Automatically updated by the system.'
      )
      .readonly()
      .optional(),
    created_by: z
      .string()
      .describe(
        '**[READ-ONLY]** Email or username of the user who created this scheduled instance.'
      )
      .readonly()
      .optional(),
    updated_by: z
      .string()
      .describe(
        '**[READ-ONLY]** Email or username of the user who last modified this scheduled instance.'
      )
      .readonly()
      .optional(),
    duration_minutes: z.coerce
      .bigint()
      .describe('**[READ-ONLY]** Duration of the scheduled instance in minutes.')
      .readonly()
      .optional(),
    duration_formatted: z
      .string()
      .describe('**[READ-ONLY]** Human-readable formatted duration.')
      .readonly()
      .optional(),
    time_range: z
      .string()
      .describe('**[READ-ONLY]** Human-readable date and time range.')
      .readonly()
      .optional(),
    is_currently_active: z
      .boolean()
      .describe(
        '**[READ-ONLY]** Indicates if the scheduled instance is currently active (ongoing).'
      )
      .readonly()
      .optional(),
    can_be_cancelled: z
      .boolean()
      .describe('**[READ-ONLY]** Indicates if the scheduled instance can be cancelled.')
      .readonly()
      .optional(),
  })
  .describe(
    'A scheduled class instance that represents a concrete class occurrence placed on the calendar'
  );

export const zApiResponseListScheduledInstance = z.object({
  success: z.boolean().optional(),
  data: z.array(zScheduledInstance).optional(),
  message: z.string().optional(),
  error: z.record(z.unknown()).optional(),
});

/**
 * **[REQUIRED]** Type of recurrence pattern. Defines the base frequency of repetition.
 */
export const zRecurrenceTypeEnum = z
  .enum(['DAILY', 'WEEKLY', 'MONTHLY'])
  .describe('**[REQUIRED]** Type of recurrence pattern. Defines the base frequency of repetition.');

/**
 * Recurrence pattern configuration for class scheduling with support for daily, weekly, and monthly patterns
 */
export const zRecurrencePattern = z
  .object({
    uuid: z
      .string()
      .uuid()
      .describe(
        '**[READ-ONLY]** Unique system identifier for the recurrence pattern. Auto-generated by the system.'
      )
      .readonly()
      .optional(),
    recurrence_type: zRecurrenceTypeEnum,
    interval_value: z
      .number()
      .int()
      .gte(1)
      .lte(365)
      .describe(
        '**[OPTIONAL]** Interval value for recurrence. For example, 2 means every 2 weeks for WEEKLY pattern.'
      )
      .optional(),
    days_of_week: z
      .string()
      .max(100)
      .describe(
        '**[OPTIONAL]** Comma-separated list of days for WEEKLY recurrence. Valid values: MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY.'
      )
      .optional(),
    day_of_month: z
      .number()
      .int()
      .gte(1)
      .lte(31)
      .describe(
        '**[OPTIONAL]** Specific day of month for MONTHLY recurrence. Must be between 1 and 31.'
      )
      .optional(),
    end_date: z
      .string()
      .date()
      .describe(
        '**[OPTIONAL]** End date for the recurrence pattern. If null, pattern continues indefinitely unless limited by occurrence count.'
      )
      .optional(),
    occurrence_count: z
      .number()
      .int()
      .gte(1)
      .describe(
        '**[OPTIONAL]** Maximum number of occurrences for this pattern. If null, pattern continues until end date or indefinitely.'
      )
      .optional(),
    is_active: z
      .boolean()
      .describe(
        '**[READ-ONLY]** Indicates if the recurrence pattern is currently active based on end date.'
      )
      .readonly()
      .optional(),
    is_indefinite: z
      .boolean()
      .describe(
        '**[READ-ONLY]** Indicates if the pattern continues indefinitely (no end date or occurrence limit).'
      )
      .readonly()
      .optional(),
    pattern_description: z
      .string()
      .describe('**[READ-ONLY]** Human-readable description of the recurrence pattern.')
      .readonly()
      .optional(),
  })
  .describe(
    'Recurrence pattern configuration for class scheduling with support for daily, weekly, and monthly patterns'
  );

export const zApiResponseRecurrencePattern = z.object({
  success: z.boolean().optional(),
  data: zRecurrencePattern.optional(),
  message: z.string().optional(),
  error: z.record(z.unknown()).optional(),
});

/**
 * Issued certificate documenting course or program completion
 */
export const zCertificate = z
  .object({
    uuid: z
      .string()
      .uuid()
      .describe(
        '**[READ-ONLY]** Unique system identifier for the certificate. Auto-generated by the system.'
      )
      .readonly()
      .optional(),
    student_uuid: z
      .string()
      .uuid()
      .describe('**[REQUIRED]** Reference to the student UUID who earned this certificate.'),
    course_uuid: z
      .string()
      .uuid()
      .describe(
        '**[OPTIONAL]** Reference to the course UUID if this is a course completion certificate. Mutually exclusive with program_uuid.'
      )
      .optional(),
    program_uuid: z
      .string()
      .uuid()
      .describe(
        '**[OPTIONAL]** Reference to the program UUID if this is a program completion certificate. Mutually exclusive with course_uuid.'
      )
      .optional(),
    template_uuid: z
      .string()
      .uuid()
      .describe(
        '**[REQUIRED]** Reference to the certificate template UUID used for generating this certificate.'
      ),
    completion_date: z
      .string()
      .datetime()
      .describe('**[REQUIRED]** Date when the course or program was completed by the student.'),
    final_grade: z
      .number()
      .gte(0)
      .lte(100)
      .describe('**[OPTIONAL]** Final grade percentage achieved by the student.')
      .optional(),
    is_valid: z
      .boolean()
      .describe('**[OPTIONAL]** Indicates if the certificate is valid and has not been revoked.')
      .optional(),
    certificate_number: z
      .string()
      .describe(
        '**[READ-ONLY]** Unique certificate number for verification and reference purposes.'
      )
      .readonly()
      .optional(),
    issued_date: z
      .string()
      .datetime()
      .describe(
        '**[READ-ONLY]** Timestamp when the certificate was issued. Automatically set by the system.'
      )
      .readonly()
      .optional(),
    certificate_url: z
      .string()
      .url()
      .describe('**[READ-ONLY]** URL to the generated certificate PDF file for download.')
      .readonly()
      .optional(),
    revoked_at: z
      .string()
      .datetime()
      .describe('**[READ-ONLY]** Timestamp when the certificate was revoked, if applicable.')
      .readonly()
      .optional(),
    revoked_reason: z
      .string()
      .describe('**[READ-ONLY]** Reason for certificate revocation, if applicable.')
      .readonly()
      .optional(),
    created_date: z
      .string()
      .datetime()
      .describe(
        '**[READ-ONLY]** Timestamp when the certificate record was created. Automatically set by the system.'
      )
      .readonly()
      .optional(),
    created_by: z
      .string()
      .describe(
        '**[READ-ONLY]** Email or username of the user who created this certificate. Used for audit trails.'
      )
      .readonly()
      .optional(),
    updated_date: z
      .string()
      .datetime()
      .describe(
        '**[READ-ONLY]** Timestamp when the certificate was last modified. Automatically updated by the system.'
      )
      .readonly()
      .optional(),
    updated_by: z
      .string()
      .describe(
        '**[READ-ONLY]** Email or username of the user who last modified this certificate. Used for audit trails.'
      )
      .readonly()
      .optional(),
    certificate_type: z
      .string()
      .describe('**[READ-ONLY]** Type of certificate based on completion achievement.')
      .readonly()
      .optional(),
    is_downloadable: z
      .boolean()
      .describe('**[READ-ONLY]** Indicates if the certificate can be downloaded by the student.')
      .readonly()
      .optional(),
    grade_letter: z
      .string()
      .describe('**[READ-ONLY]** Letter grade representation of the final grade.')
      .readonly()
      .optional(),
    validity_status: z
      .string()
      .describe('**[READ-ONLY]** Current validity status of the certificate.')
      .readonly()
      .optional(),
  })
  .describe('Issued certificate documenting course or program completion');

export const zApiResponseCertificate = z.object({
  success: z.boolean().optional(),
  data: zCertificate.optional(),
  message: z.string().optional(),
  error: z.record(z.unknown()).optional(),
});

/**
 * **[REQUIRED]** Type of certificate this template is designed for.
 */
export const zTemplateTypeEnum = z
  .enum(['COURSE_COMPLETION', 'PARTICIPATION', 'ACHIEVEMENT', 'CUSTOM'])
  .describe('**[REQUIRED]** Type of certificate this template is designed for.');

/**
 * Certificate template with design elements and layout configuration
 */
export const zCertificateTemplate = z
  .object({
    uuid: z
      .string()
      .uuid()
      .describe(
        '**[READ-ONLY]** Unique system identifier for the certificate template. Auto-generated by the system.'
      )
      .readonly()
      .optional(),
    name: z
      .string()
      .min(0)
      .max(255)
      .describe(
        '**[REQUIRED]** Name of the certificate template that clearly describes its purpose.'
      ),
    template_type: zTemplateTypeEnum,
    template_html: z
      .string()
      .min(0)
      .max(20000)
      .describe('**[OPTIONAL]** HTML content defining the certificate layout and structure.')
      .optional(),
    template_css: z
      .string()
      .min(0)
      .max(50000)
      .describe('**[OPTIONAL]** CSS styles for the certificate template design.')
      .optional(),
    background_image_url: z
      .string()
      .min(0)
      .max(500)
      .describe('**[OPTIONAL]** URL to the background image for the certificate.')
      .optional(),
    active: z
      .boolean()
      .describe(
        '**[OPTIONAL]** Indicates if the template is actively available for use. Can only be true for published templates.'
      )
      .optional(),
    created_date: z
      .string()
      .datetime()
      .describe(
        '**[READ-ONLY]** Timestamp when the template was created. Automatically set by the system.'
      )
      .readonly()
      .optional(),
    created_by: z
      .string()
      .describe(
        '**[READ-ONLY]** Email or username of the user who created this template. Used for audit trails.'
      )
      .readonly()
      .optional(),
    updated_date: z
      .string()
      .datetime()
      .describe(
        '**[READ-ONLY]** Timestamp when the template was last modified. Automatically updated by the system.'
      )
      .readonly()
      .optional(),
    updated_by: z
      .string()
      .describe(
        '**[READ-ONLY]** Email or username of the user who last modified this template. Used for audit trails.'
      )
      .readonly()
      .optional(),
    design_complexity: z
      .string()
      .describe(
        "**[READ-ONLY]** Assessment of the template's design complexity based on HTML and CSS content."
      )
      .readonly()
      .optional(),
  })
  .describe('Certificate template with design elements and layout configuration');

export const zApiResponseCertificateTemplate = z.object({
  success: z.boolean().optional(),
  data: zCertificateTemplate.optional(),
  message: z.string().optional(),
  error: z.record(z.unknown()).optional(),
});

/**
 * Assignment with learning activities and assessment criteria
 */
export const zAssignment = z
  .object({
    uuid: z
      .string()
      .uuid()
      .describe(
        '**[READ-ONLY]** Unique system identifier for the assignment. Auto-generated by the system.'
      )
      .readonly()
      .optional(),
    lesson_uuid: z
      .string()
      .uuid()
      .describe('**[REQUIRED]** Reference to the lesson UUID this assignment belongs to.'),
    title: z
      .string()
      .min(0)
      .max(255)
      .describe('**[REQUIRED]** Title of the assignment that clearly describes its purpose.'),
    description: z
      .string()
      .min(0)
      .max(2000)
      .describe("**[OPTIONAL]** Detailed description of the assignment's objectives and scope.")
      .optional(),
    instructions: z
      .string()
      .min(0)
      .max(5000)
      .describe('**[OPTIONAL]** Detailed instructions for completing the assignment.')
      .optional(),
    due_date: z
      .string()
      .datetime()
      .describe('**[OPTIONAL]** Due date and time for assignment submission.')
      .optional(),
    max_points: z
      .number()
      .gte(0)
      .describe('**[OPTIONAL]** Maximum points that can be earned for this assignment.')
      .optional(),
    rubric_uuid: z
      .string()
      .uuid()
      .describe('**[OPTIONAL]** Reference to the rubric UUID used for grading this assignment.')
      .optional(),
    submission_types: z
      .array(z.string())
      .describe('**[OPTIONAL]** Array of accepted submission types for this assignment.')
      .optional(),
    is_published: z
      .boolean()
      .describe(
        '**[OPTIONAL]** Indicates if the assignment is actively available for students. Can only be true for published assignments.'
      )
      .optional(),
    created_date: z
      .string()
      .datetime()
      .describe(
        '**[READ-ONLY]** Timestamp when the assignment was created. Automatically set by the system.'
      )
      .readonly()
      .optional(),
    created_by: z
      .string()
      .describe(
        '**[READ-ONLY]** Email or username of the user who created this assignment. Used for audit trails.'
      )
      .readonly()
      .optional(),
    updated_date: z
      .string()
      .datetime()
      .describe(
        '**[READ-ONLY]** Timestamp when the assignment was last modified. Automatically updated by the system.'
      )
      .readonly()
      .optional(),
    updated_by: z
      .string()
      .describe(
        '**[READ-ONLY]** Email or username of the user who last modified this assignment. Used for audit trails.'
      )
      .readonly()
      .optional(),
    assignment_category: z
      .string()
      .describe(
        '**[READ-ONLY]** Formatted category of the assignment based on its characteristics.'
      )
      .readonly()
      .optional(),
    points_display: z
      .string()
      .describe('**[READ-ONLY]** Formatted display of the maximum points for this assignment.')
      .readonly()
      .optional(),
    assignment_scope: z
      .string()
      .describe('**[READ-ONLY]** Scope of the assignment - lesson-specific or standalone.')
      .readonly()
      .optional(),
    submission_summary: z
      .string()
      .describe('**[READ-ONLY]** Summary of accepted submission types for this assignment.')
      .readonly()
      .optional(),
  })
  .describe('Assignment with learning activities and assessment criteria');

export const zApiResponseAssignment = z.object({
  success: z.boolean().optional(),
  data: zAssignment.optional(),
  message: z.string().optional(),
  error: z.record(z.unknown()).optional(),
});

export const zApiResponseVoid = z.object({
  success: z.boolean().optional(),
  data: z.record(z.unknown()).optional(),
  message: z.string().optional(),
  error: z.record(z.unknown()).optional(),
});

/**
 * Request to schedule a new class instance
 */
export const zScheduleRequest = z
  .object({
    class_definition_uuid: z
      .string()
      .uuid()
      .describe('**[REQUIRED]** Reference to the class definition UUID to schedule.'),
    instructor_uuid: z
      .string()
      .uuid()
      .describe('**[REQUIRED]** Reference to the instructor UUID who will conduct the session.'),
    start_time: z
      .string()
      .datetime()
      .describe('**[REQUIRED]** Start date and time for the scheduled session.'),
    end_time: z
      .string()
      .datetime()
      .describe('**[REQUIRED]** End date and time for the scheduled session.'),
    timezone: z
      .string()
      .describe('**[OPTIONAL]** Timezone for the scheduled session. Defaults to UTC.')
      .optional(),
  })
  .describe('Request to schedule a new class instance');

export const zApiResponseBoolean = z.object({
  success: z.boolean().optional(),
  data: z.boolean().optional(),
  message: z.string().optional(),
  error: z.record(z.unknown()).optional(),
});

export const zApiResponseScheduledInstance = z.object({
  success: z.boolean().optional(),
  data: zScheduledInstance.optional(),
  message: z.string().optional(),
  error: z.record(z.unknown()).optional(),
});

export const zApiResponseStudent = z.object({
  success: z.boolean().optional(),
  data: zStudent.optional(),
  message: z.string().optional(),
  error: z.record(z.unknown()).optional(),
});

export const zApiResponseListRubricScoringLevel = z.object({
  success: z.boolean().optional(),
  data: z.array(zRubricScoringLevel).optional(),
  message: z.string().optional(),
  error: z.record(z.unknown()).optional(),
});

export const zApiResponseObject = z.object({
  success: z.boolean().optional(),
  data: z.record(z.unknown()).optional(),
  message: z.string().optional(),
  error: z.record(z.unknown()).optional(),
});

export const zApiResponseString = z.object({
  success: z.boolean().optional(),
  data: z.string().optional(),
  message: z.string().optional(),
  error: z.record(z.unknown()).optional(),
});

/**
 * **[REQUIRED]** Role/domain name being offered to the recipient. Determines the permissions and access level the user will have upon accepting the invitation.
 */
export const zDomainNameEnum = z
  .enum(['student', 'instructor', 'admin', 'organisation_user', 'course_creator'])
  .describe(
    '**[REQUIRED]** Role/domain name being offered to the recipient. Determines the permissions and access level the user will have upon accepting the invitation.'
  );

/**
 * Request body for creating new organization or branch invitations with recipient details and role assignment
 */
export const zInvitationRequest = z
  .object({
    recipient_email: z
      .string()
      .email()
      .min(0)
      .max(100)
      .describe(
        '**[REQUIRED]** Email address of the invitation recipient. Must be a valid email format and will be used to send the invitation email with accept/decline links.'
      ),
    recipient_name: z
      .string()
      .min(0)
      .max(150)
      .describe(
        '**[REQUIRED]** Full name of the invitation recipient. Used in email templates, invitation records, and for display purposes throughout the invitation process.'
      ),
    domain_name: zDomainNameEnum,
    inviter_uuid: z
      .string()
      .uuid()
      .describe(
        '**[REQUIRED]** UUID of the user who is sending this invitation. Must be an existing user with appropriate permissions to invite users to the target organization/branch.'
      ),
    notes: z
      .string()
      .min(0)
      .max(500)
      .describe(
        '**[OPTIONAL]** Optional personal message or notes to include with the invitation email. Will be displayed in the invitation email template and can contain welcoming text, instructions, or context.'
      )
      .optional(),
  })
  .describe(
    'Request body for creating new organization or branch invitations with recipient details and role assignment'
  );

/**
 * **[READ-ONLY]** Current status of the invitation in its lifecycle. Automatically managed by the system based on user actions and expiration rules.
 */
export const zStatusEnum4 = z
  .enum(['PENDING', 'ACCEPTED', 'DECLINED', 'EXPIRED', 'CANCELLED'])
  .describe(
    '**[READ-ONLY]** Current status of the invitation in its lifecycle. Automatically managed by the system based on user actions and expiration rules.'
  );

/**
 * Complete invitation information including recipient details, organization/branch assignment, invitation status, and lifecycle tracking
 */
export const zInvitation = z
  .object({
    uuid: z
      .string()
      .uuid()
      .describe(
        '**[READ-ONLY]** Unique system identifier for the invitation. Auto-generated by the system and cannot be modified.'
      )
      .readonly()
      .optional(),
    token: z
      .string()
      .length(64)
      .describe(
        '**[READ-ONLY]** Unique token used for invitation acceptance and decline links. Generated by the system and used in email URLs for secure invitation processing.'
      )
      .readonly()
      .optional(),
    recipient_email: z
      .string()
      .email()
      .min(0)
      .max(100)
      .describe(
        '**[REQUIRED]** Email address of the invitation recipient. Must be a valid email format and will be used to send invitation emails.'
      ),
    recipient_name: z
      .string()
      .min(0)
      .max(150)
      .describe(
        '**[REQUIRED]** Full name of the invitation recipient. Used in email templates and for display purposes throughout the invitation process.'
      ),
    organisation_uuid: z
      .string()
      .uuid()
      .describe(
        '**[REQUIRED]** UUID of the organization the user is being invited to join. References the target organization for this invitation.'
      ),
    branch_uuid: z
      .string()
      .uuid()
      .describe(
        '**[OPTIONAL]** UUID of the training branch for branch-specific invitations. When provided, the invitation is for a specific branch within the organization.'
      )
      .optional(),
    domain_uuid: z
      .string()
      .uuid()
      .describe(
        '**[REQUIRED]** UUID of the user domain/role being offered to the recipient. Determines what permissions and access the user will have upon acceptance.'
      ),
    inviter_uuid: z
      .string()
      .uuid()
      .describe(
        '**[REQUIRED]** UUID of the user who sent the invitation. References the user who initiated this invitation process.'
      ),
    status: zStatusEnum4.optional(),
    notes: z
      .string()
      .min(0)
      .max(500)
      .describe(
        '**[OPTIONAL]** Optional notes or message included with the invitation. Can contain welcoming text, instructions, or other relevant information for the recipient.'
      )
      .optional(),
    organisation_name: z
      .string()
      .describe(
        '**[READ-ONLY]** Name of the organization for display purposes. Populated by the system based on the organisation_uuid and cannot be directly modified.'
      )
      .readonly()
      .optional(),
    branch_name: z
      .string()
      .describe(
        '**[READ-ONLY]** Name of the training branch for display purposes. Populated by the system based on the branch_uuid and cannot be directly modified.'
      )
      .readonly()
      .optional(),
    domain_name: zDomainNameEnum.optional(),
    inviter_name: z
      .string()
      .max(150)
      .describe(
        '**[READ-ONLY]** Full name of the user who sent the invitation. Cached for performance and email template purposes, automatically populated by the system.'
      )
      .readonly()
      .optional(),
    expires_at: z
      .string()
      .datetime()
      .describe(
        '**[READ-ONLY]** Date and time when the invitation expires in ISO 8601 format. After this time, the invitation cannot be accepted and will be marked as expired.'
      )
      .readonly()
      .optional(),
    accepted_at: z
      .string()
      .datetime()
      .describe(
        '**[READ-ONLY]** Date and time when the invitation was accepted in ISO 8601 format. Only populated when the invitation status is ACCEPTED.'
      )
      .readonly()
      .optional(),
    declined_at: z
      .string()
      .datetime()
      .describe(
        '**[READ-ONLY]** Date and time when the invitation was declined in ISO 8601 format. Only populated when the invitation status is DECLINED.'
      )
      .readonly()
      .optional(),
    user_uuid: z
      .string()
      .uuid()
      .describe(
        '**[READ-ONLY]** UUID of the user who accepted the invitation. Only populated when the invitation status is ACCEPTED, linking to the actual user account.'
      )
      .readonly()
      .optional(),
    created_date: z
      .string()
      .datetime()
      .describe(
        '**[READ-ONLY]** Timestamp when the invitation was first created in ISO 8601 format. Automatically set by the system and cannot be modified.'
      )
      .readonly()
      .optional(),
    updated_date: z
      .string()
      .datetime()
      .describe(
        '**[READ-ONLY]** Timestamp when the invitation was last modified in ISO 8601 format. Automatically updated by the system on any changes and cannot be directly modified.'
      )
      .readonly()
      .optional(),
    created_by: z
      .string()
      .max(50)
      .describe(
        '**[READ-ONLY]** Email or identifier of who created the invitation. Used for audit trail purposes and automatically populated by the system.'
      )
      .readonly()
      .optional(),
    updated_by: z
      .string()
      .max(50)
      .describe(
        '**[READ-ONLY]** Email or identifier of who last modified the invitation. Used for audit trail purposes and automatically updated by the system on changes.'
      )
      .readonly()
      .optional(),
  })
  .describe(
    'Complete invitation information including recipient details, organization/branch assignment, invitation status, and lifecycle tracking'
  );

export const zApiResponseInvitation = z.object({
  success: z.boolean().optional(),
  data: zInvitation.optional(),
  message: z.string().optional(),
  error: z.record(z.unknown()).optional(),
});

export const zApiResponseListInvitation = z.object({
  success: z.boolean().optional(),
  data: z.array(zInvitation).optional(),
  message: z.string().optional(),
  error: z.record(z.unknown()).optional(),
});

export const zApiResponseInteger = z.object({
  success: z.boolean().optional(),
  data: z.number().int().optional(),
  message: z.string().optional(),
  error: z.record(z.unknown()).optional(),
});

export const zApiResponseInstructor = z.object({
  success: z.boolean().optional(),
  data: zInstructor.optional(),
  message: z.string().optional(),
  error: z.record(z.unknown()).optional(),
});

/**
 * Request to enroll a student in a scheduled class instance
 */
export const zEnrollmentRequest = z
  .object({
    scheduled_instance_uuid: z
      .string()
      .uuid()
      .describe('**[REQUIRED]** Reference to the scheduled instance UUID to enroll in.'),
    student_uuid: z
      .string()
      .uuid()
      .describe('**[REQUIRED]** Reference to the student UUID who is enrolling.'),
  })
  .describe('Request to enroll a student in a scheduled class instance');

/**
 * **[OPTIONAL]** Current enrollment and attendance status.
 */
export const zStatusEnum5 = z
  .enum(['ENROLLED', 'ATTENDED', 'ABSENT', 'CANCELLED'])
  .describe('**[OPTIONAL]** Current enrollment and attendance status.');

/**
 * A student enrollment in a scheduled class instance with attendance tracking
 */
export const zEnrollment = z
  .object({
    uuid: z
      .string()
      .uuid()
      .describe(
        '**[READ-ONLY]** Unique system identifier for the enrollment. Auto-generated by the system.'
      )
      .readonly()
      .optional(),
    scheduled_instance_uuid: z
      .string()
      .uuid()
      .describe(
        '**[REQUIRED]** Reference to the scheduled instance UUID that the student is enrolling in.'
      ),
    student_uuid: z
      .string()
      .uuid()
      .describe('**[REQUIRED]** Reference to the student UUID who is enrolling.'),
    status: zStatusEnum5.optional(),
    attendance_marked_at: z
      .string()
      .datetime()
      .describe('**[OPTIONAL]** Timestamp when attendance was marked for this enrollment.')
      .optional(),
    created_date: z
      .string()
      .datetime()
      .describe(
        '**[READ-ONLY]** Timestamp when the enrollment was first created. Automatically set by the system.'
      )
      .readonly()
      .optional(),
    updated_date: z
      .string()
      .datetime()
      .describe(
        '**[READ-ONLY]** Timestamp when the enrollment was last modified. Automatically updated by the system.'
      )
      .readonly()
      .optional(),
    created_by: z
      .string()
      .describe('**[READ-ONLY]** Email or username of the user who created this enrollment.')
      .readonly()
      .optional(),
    updated_by: z
      .string()
      .describe('**[READ-ONLY]** Email or username of the user who last modified this enrollment.')
      .readonly()
      .optional(),
    is_active: z
      .boolean()
      .describe('**[READ-ONLY]** Indicates if the enrollment is still active (not cancelled).')
      .readonly()
      .optional(),
    is_attendance_marked: z
      .boolean()
      .describe('**[READ-ONLY]** Indicates if attendance has been marked for this enrollment.')
      .readonly()
      .optional(),
    did_attend: z
      .boolean()
      .describe('**[READ-ONLY]** Indicates if the student attended the class.')
      .readonly()
      .optional(),
    status_description: z
      .string()
      .describe('**[READ-ONLY]** Human-readable description of the enrollment status.')
      .readonly()
      .optional(),
    can_be_cancelled: z
      .boolean()
      .describe('**[READ-ONLY]** Indicates if the enrollment can be cancelled.')
      .readonly()
      .optional(),
  })
  .describe('A student enrollment in a scheduled class instance with attendance tracking');

export const zApiResponseEnrollment = z.object({
  success: z.boolean().optional(),
  data: zEnrollment.optional(),
  message: z.string().optional(),
  error: z.record(z.unknown()).optional(),
});

export const zApiResponse = z.object({
  success: z.boolean().optional(),
  data: z.record(z.unknown()).optional(),
  message: z.string().optional(),
  error: z.record(z.unknown()).optional(),
});

export const zApiResponseCourseCreator = z.object({
  success: z.boolean().optional(),
  data: zCourseCreator.optional(),
  message: z.string().optional(),
  error: z.record(z.unknown()).optional(),
});

/**
 * A single line item attached to a cart
 */
export const zCartItemResponse = z
  .object({
    id: z.string().describe('Unique identifier of the line item').optional(),
    title: z.string().describe('Human friendly name of the product').optional(),
    quantity: z.number().int().describe('Quantity of the product variant').optional(),
    variant_id: z.string().describe('Medusa variant identifier').optional(),
    metadata: z
      .record(z.record(z.unknown()))
      .describe('Custom metadata captured for the line item')
      .optional(),
  })
  .describe('A single line item attached to a cart');

/**
 * Order information synchronised from Medusa
 */
export const zOrderResponse = z
  .object({
    id: z.string().describe('Unique Medusa identifier of the order').optional(),
    display_id: z.string().describe('Human friendly order number').optional(),
    payment_status: z.string().describe('Payment status reported by Medusa').optional(),
    created_at: z.string().datetime().describe('Timestamp when the order was created').optional(),
    items: z.array(zCartItemResponse).optional(),
  })
  .describe('Order information synchronised from Medusa');

/**
 * Checkout payload that orchestrates Medusa cart completion
 */
export const zCheckoutRequest = z
  .object({
    cart_id: z.string().describe('Identifier of the cart being checked out'),
    customer_email: z.string().describe('Email address of the purchasing customer'),
    shipping_address_id: z
      .string()
      .describe('Optional shipping address identifier to attach to the order')
      .optional(),
    billing_address_id: z.string().describe('Optional billing address identifier').optional(),
    payment_provider_id: z.string().describe('Payment provider identifier to use for the checkout'),
  })
  .describe('Checkout payload that orchestrates Medusa cart completion');

/**
 * Cart summary returned to clients consuming the commerce APIs
 */
export const zCartResponse = z
  .object({
    id: z.string().describe('Unique Medusa identifier of the cart').optional(),
    region_id: z.string().describe('Region identifier the cart is scoped to').optional(),
    customer_id: z.string().describe('Associated Medusa customer identifier').optional(),
    created_at: z.string().datetime().describe('Timestamp when the cart was created').optional(),
    updated_at: z
      .string()
      .datetime()
      .describe('Timestamp when the cart was last updated')
      .optional(),
    items: z.array(zCartItemResponse).optional(),
  })
  .describe('Cart summary returned to clients consuming the commerce APIs');

/**
 * Line item definition used when creating or updating a cart
 */
export const zCartLineItemRequest = z
  .object({
    variant_id: z.string().describe('Identifier of the Medusa product variant to add to the cart'),
    quantity: z.number().int().gte(1).describe('Quantity of the variant to add to the cart'),
    metadata: z
      .record(z.record(z.unknown()))
      .describe('Optional metadata forwarded to Medusa and persisted with the line item')
      .optional(),
  })
  .describe('Line item definition used when creating or updating a cart');

/**
 * Request body for creating a new cart that synchronises with Medusa
 */
export const zCreateCartRequest = z
  .object({
    region_id: z.string().describe('Identifier of the Medusa region the cart belongs to'),
    customer_id: z
      .string()
      .describe('Medusa customer identifier to associate with the cart')
      .optional(),
    sales_channel_id: z
      .string()
      .describe('Sales channel identifier configured in Medusa')
      .optional(),
    metadata: z
      .record(z.record(z.unknown()))
      .describe('Arbitrary metadata forwarded to Medusa')
      .optional(),
    items: z.array(zCartLineItemRequest).optional(),
  })
  .describe('Request body for creating a new cart that synchronises with Medusa');

/**
 * Specifies the payment provider to use for a cart
 */
export const zSelectPaymentSessionRequest = z
  .object({
    provider_id: z
      .string()
      .describe("Identifier of the Medusa payment provider (e.g. 'manual', 'stripe')"),
  })
  .describe('Specifies the payment provider to use for a cart');

/**
 * **[REQUIRED]** Current status of the submission in the grading workflow.
 */
export const zStatusEnum6 = z
  .enum(['DRAFT', 'SUBMITTED', 'IN_REVIEW', 'GRADED', 'RETURNED'])
  .describe('**[REQUIRED]** Current status of the submission in the grading workflow.');

/**
 * Student submission for an assignment with grading and feedback information
 */
export const zAssignmentSubmission = z
  .object({
    uuid: z
      .string()
      .uuid()
      .describe(
        '**[READ-ONLY]** Unique system identifier for the assignment submission. Auto-generated by the system.'
      )
      .readonly()
      .optional(),
    enrollment_uuid: z
      .string()
      .uuid()
      .describe(
        '**[REQUIRED]** Reference to the enrollment UUID of the student making this submission.'
      ),
    assignment_uuid: z
      .string()
      .uuid()
      .describe('**[REQUIRED]** Reference to the assignment UUID this submission is for.'),
    submission_text: z
      .string()
      .min(0)
      .max(10000)
      .describe("**[OPTIONAL]** Text content of the student's submission.")
      .optional(),
    file_urls: z
      .array(z.string())
      .describe('**[OPTIONAL]** Array of file URLs attached to this submission.')
      .optional(),
    submitted_at: z
      .string()
      .datetime()
      .describe('**[OPTIONAL]** Timestamp when the submission was made by the student.')
      .optional(),
    status: zStatusEnum6,
    score: z
      .number()
      .gte(0)
      .describe('**[OPTIONAL]** Score awarded to this submission by the instructor.')
      .optional(),
    max_score: z
      .number()
      .gte(0)
      .describe('**[OPTIONAL]** Maximum possible score for this submission.')
      .optional(),
    percentage: z
      .number()
      .gte(0)
      .lte(100)
      .describe('**[OPTIONAL]** Percentage score calculated from score and max_score.')
      .optional(),
    instructor_comments: z
      .string()
      .min(0)
      .max(5000)
      .describe("**[OPTIONAL]** Instructor's feedback and comments on the submission.")
      .optional(),
    graded_at: z
      .string()
      .datetime()
      .describe('**[OPTIONAL]** Timestamp when the submission was graded by the instructor.')
      .optional(),
    graded_by_uuid: z
      .string()
      .uuid()
      .describe('**[OPTIONAL]** Reference to the instructor UUID who graded this submission.')
      .optional(),
    created_date: z
      .string()
      .datetime()
      .describe(
        '**[READ-ONLY]** Timestamp when the submission was created. Automatically set by the system.'
      )
      .readonly()
      .optional(),
    created_by: z
      .string()
      .describe(
        '**[READ-ONLY]** Email or username of the student who created this submission. Used for audit trails.'
      )
      .readonly()
      .optional(),
    updated_date: z
      .string()
      .datetime()
      .describe(
        '**[READ-ONLY]** Timestamp when the submission was last modified. Automatically updated by the system.'
      )
      .readonly()
      .optional(),
    updated_by: z
      .string()
      .describe(
        '**[READ-ONLY]** Email or username of the user who last modified this submission. Used for audit trails.'
      )
      .readonly()
      .optional(),
    is_graded: z
      .boolean()
      .describe('**[READ-ONLY]** Indicates if the submission has been graded by an instructor.')
      .readonly()
      .optional(),
    submission_category: z
      .string()
      .describe('**[READ-ONLY]** Formatted category of the submission based on its content type.')
      .readonly()
      .optional(),
    grade_display: z
      .string()
      .describe('**[READ-ONLY]** Formatted display of the grade information.')
      .readonly()
      .optional(),
    submission_status_display: z
      .string()
      .describe(
        '**[READ-ONLY]** Comprehensive status indicating submission state and availability of feedback.'
      )
      .readonly()
      .optional(),
    file_count_display: z
      .string()
      .describe('**[READ-ONLY]** Summary of files attached to this submission.')
      .readonly()
      .optional(),
  })
  .describe('Student submission for an assignment with grading and feedback information');

export const zApiResponseAssignmentSubmission = z.object({
  success: z.boolean().optional(),
  data: zAssignmentSubmission.optional(),
  message: z.string().optional(),
  error: z.record(z.unknown()).optional(),
});

export const zSchemaEnum2 = z.enum(['admin', 'organisation_user']);

/**
 * Type of assignment - global or organization-specific
 */
export const zAssignmentTypeEnum = z
  .enum(['global', 'organization'])
  .describe('Type of assignment - global or organization-specific');

/**
 * Admin domain assignment request containing domain type, reason, and effective date
 */
export const zAdminDomainAssignmentRequest = z
  .object({
    domain_name: zSchemaEnum2,
    assignment_type: zAssignmentTypeEnum,
    reason: z.string().min(0).max(500).describe('Reason for assigning admin privileges').optional(),
    effective_date: z
      .string()
      .date()
      .describe('Effective date for the admin assignment')
      .optional(),
  })
  .describe('Admin domain assignment request containing domain type, reason, and effective date');

/**
 * Fields that can be patched on an existing cart
 */
export const zUpdateCartRequest = z
  .object({
    email: z.string().describe('Email address of the customer').optional(),
    customer_id: z
      .string()
      .describe('Medusa customer identifier to associate with the cart')
      .optional(),
    shipping_address_id: z.string().describe('Medusa shipping address identifier').optional(),
    billing_address_id: z.string().describe('Medusa billing address identifier').optional(),
    metadata: z
      .record(z.record(z.unknown()))
      .describe('Optional metadata map forwarded to Medusa')
      .optional(),
  })
  .describe('Fields that can be patched on an existing cart');

export const zPageable = z.object({
  page: z.number().int().gte(0).optional(),
  size: z.number().int().gte(1).optional(),
  sort: z.array(z.string()).optional(),
});

export const zPageMetadata = z.object({
  pageNumber: z.number().int().optional(),
  pageSize: z.number().int().optional(),
  totalElements: z.coerce.bigint().optional(),
  totalPages: z.number().int().optional(),
  hasNext: z.boolean().optional(),
  hasPrevious: z.boolean().optional(),
  first: z.boolean().optional(),
  last: z.boolean().optional(),
});

export const zPageLinks = z.object({
  first: z.string().optional(),
  previous: z.string().optional(),
  self: z.string().optional(),
  next: z.string().optional(),
  last: z.string().optional(),
});

export const zPagedDtoUser = z.object({
  content: z.array(zUser).optional(),
  metadata: zPageMetadata.optional(),
  links: zPageLinks.optional(),
});

export const zApiResponsePagedDtoUser = z.object({
  success: z.boolean().optional(),
  data: zPagedDtoUser.optional(),
  message: z.string().optional(),
  error: z.record(z.unknown()).optional(),
});

export const zPagedDtoTrainingBranch = z.object({
  content: z.array(zTrainingBranch).optional(),
  metadata: zPageMetadata.optional(),
  links: zPageLinks.optional(),
});

export const zApiResponsePagedDtoTrainingBranch = z.object({
  success: z.boolean().optional(),
  data: zPagedDtoTrainingBranch.optional(),
  message: z.string().optional(),
  error: z.record(z.unknown()).optional(),
});

export const zPagedDtoStudent = z.object({
  content: z.array(zStudent).optional(),
  metadata: zPageMetadata.optional(),
  links: zPageLinks.optional(),
});

export const zApiResponsePagedDtoStudent = z.object({
  success: z.boolean().optional(),
  data: zPagedDtoStudent.optional(),
  message: z.string().optional(),
  error: z.record(z.unknown()).optional(),
});

export const zSortObject = z.object({
  sorted: z.boolean().optional(),
  empty: z.boolean().optional(),
  unsorted: z.boolean().optional(),
});

export const zPageableObject = z.object({
  paged: z.boolean().optional(),
  pageNumber: z.number().int().optional(),
  pageSize: z.number().int().optional(),
  offset: z.coerce.bigint().optional(),
  sort: zSortObject.optional(),
  unpaged: z.boolean().optional(),
});

export const zPage = z.object({
  totalElements: z.coerce.bigint().optional(),
  totalPages: z.number().int().optional(),
  first: z.boolean().optional(),
  last: z.boolean().optional(),
  pageable: zPageableObject.optional(),
  size: z.number().int().optional(),
  content: z.array(z.record(z.unknown())).optional(),
  number: z.number().int().optional(),
  sort: zSortObject.optional(),
  numberOfElements: z.number().int().optional(),
  empty: z.boolean().optional(),
});

export const zPagedDtoAssessmentRubric = z.object({
  content: z.array(zAssessmentRubric).optional(),
  metadata: zPageMetadata.optional(),
  links: zPageLinks.optional(),
});

export const zApiResponsePagedDtoAssessmentRubric = z.object({
  success: z.boolean().optional(),
  data: zPagedDtoAssessmentRubric.optional(),
  message: z.string().optional(),
  error: z.record(z.unknown()).optional(),
});

export const zMatrixValidationResult = z.object({
  isValid: z.boolean().optional(),
  message: z.string().optional(),
  totalCells: z.number().int().optional(),
  completedCells: z.number().int().optional(),
  completionPercentage: z.number().optional(),
  weightsValid: z.boolean().optional(),
  scoresCalculated: z.boolean().optional(),
});

export const zApiResponseMatrixValidationResult = z.object({
  success: z.boolean().optional(),
  data: zMatrixValidationResult.optional(),
  message: z.string().optional(),
  error: z.record(z.unknown()).optional(),
});

export const zPagedDtoRubricScoringLevel = z.object({
  content: z.array(zRubricScoringLevel).optional(),
  metadata: zPageMetadata.optional(),
  links: zPageLinks.optional(),
});

export const zApiResponsePagedDtoRubricScoringLevel = z.object({
  success: z.boolean().optional(),
  data: zPagedDtoRubricScoringLevel.optional(),
  message: z.string().optional(),
  error: z.record(z.unknown()).optional(),
});

export const zApiResponseMatrixStatistics = z.object({
  success: z.boolean().optional(),
  data: zMatrixStatistics.optional(),
  message: z.string().optional(),
  error: z.record(z.unknown()).optional(),
});

export const zApiResponseMapStringObject = z.object({
  success: z.boolean().optional(),
  data: z.record(z.record(z.unknown())).optional(),
  message: z.string().optional(),
  error: z.record(z.unknown()).optional(),
});

export const zPagedDtoRubricCriteria = z.object({
  content: z.array(zRubricCriteria).optional(),
  metadata: zPageMetadata.optional(),
  links: zPageLinks.optional(),
});

export const zApiResponsePagedDtoRubricCriteria = z.object({
  success: z.boolean().optional(),
  data: zPagedDtoRubricCriteria.optional(),
  message: z.string().optional(),
  error: z.record(z.unknown()).optional(),
});

export const zPagedDtoRubricScoring = z.object({
  content: z.array(zRubricScoring).optional(),
  metadata: zPageMetadata.optional(),
  links: zPageLinks.optional(),
});

export const zApiResponsePagedDtoRubricScoring = z.object({
  success: z.boolean().optional(),
  data: zPagedDtoRubricScoring.optional(),
  message: z.string().optional(),
  error: z.record(z.unknown()).optional(),
});

export const zApiResponseMapStringLong = z.object({
  success: z.boolean().optional(),
  data: z.record(z.coerce.bigint()).optional(),
  message: z.string().optional(),
  error: z.record(z.unknown()).optional(),
});

export const zPagedDtoQuiz = z.object({
  content: z.array(zQuiz).optional(),
  metadata: zPageMetadata.optional(),
  links: zPageLinks.optional(),
});

export const zApiResponsePagedDtoQuiz = z.object({
  success: z.boolean().optional(),
  data: zPagedDtoQuiz.optional(),
  message: z.string().optional(),
  error: z.record(z.unknown()).optional(),
});

export const zApiResponseBigDecimal = z.object({
  success: z.boolean().optional(),
  data: z.number().optional(),
  message: z.string().optional(),
  error: z.record(z.unknown()).optional(),
});

export const zApiResponseListQuizQuestion = z.object({
  success: z.boolean().optional(),
  data: z.array(zQuizQuestion).optional(),
  message: z.string().optional(),
  error: z.record(z.unknown()).optional(),
});

export const zPagedDtoQuizQuestionOption = z.object({
  content: z.array(zQuizQuestionOption).optional(),
  metadata: zPageMetadata.optional(),
  links: zPageLinks.optional(),
});

export const zApiResponsePagedDtoQuizQuestionOption = z.object({
  success: z.boolean().optional(),
  data: zPagedDtoQuizQuestionOption.optional(),
  message: z.string().optional(),
  error: z.record(z.unknown()).optional(),
});

/**
 * **[REQUIRED]** Current status of the quiz attempt.
 */
export const zStatusEnum7 = z
  .enum(['IN_PROGRESS', 'SUBMITTED', 'GRADED'])
  .describe('**[REQUIRED]** Current status of the quiz attempt.');

/**
 * Student quiz attempt with timing, scoring, and completion tracking
 */
export const zQuizAttempt = z
  .object({
    uuid: z
      .string()
      .uuid()
      .describe(
        '**[READ-ONLY]** Unique system identifier for the quiz attempt. Auto-generated by the system.'
      )
      .readonly()
      .optional(),
    enrollment_uuid: z
      .string()
      .uuid()
      .describe('**[REQUIRED]** Reference to the enrollment UUID of the student taking the quiz.'),
    quiz_uuid: z
      .string()
      .uuid()
      .describe('**[REQUIRED]** Reference to the quiz UUID being attempted.'),
    attempt_number: z
      .number()
      .int()
      .gte(1)
      .describe(
        '**[OPTIONAL]** Sequential number of this attempt for the same quiz by the same student.'
      )
      .optional(),
    started_at: z
      .string()
      .datetime()
      .describe('**[OPTIONAL]** Timestamp when the student started the quiz attempt.')
      .optional(),
    submitted_at: z
      .string()
      .datetime()
      .describe('**[OPTIONAL]** Timestamp when the student submitted the quiz attempt.')
      .optional(),
    time_taken_minutes: z
      .number()
      .int()
      .gte(0)
      .describe('**[OPTIONAL]** Total time taken to complete the quiz in minutes.')
      .optional(),
    score: z
      .number()
      .gte(0)
      .describe('**[OPTIONAL]** Score achieved by the student on this quiz attempt.')
      .optional(),
    max_score: z
      .number()
      .gte(0)
      .describe('**[OPTIONAL]** Maximum possible score for this quiz.')
      .optional(),
    percentage: z
      .number()
      .gte(0)
      .lte(100)
      .describe('**[OPTIONAL]** Percentage score calculated from score and max_score.')
      .optional(),
    is_passed: z
      .boolean()
      .describe(
        '**[OPTIONAL]** Indicates if the student passed the quiz based on passing criteria.'
      )
      .optional(),
    status: zStatusEnum7,
    created_date: z
      .string()
      .datetime()
      .describe(
        '**[READ-ONLY]** Timestamp when the attempt was created. Automatically set by the system.'
      )
      .readonly()
      .optional(),
    created_by: z
      .string()
      .describe(
        '**[READ-ONLY]** Email or username of the user who created this attempt. Used for audit trails.'
      )
      .readonly()
      .optional(),
    updated_date: z
      .string()
      .datetime()
      .describe(
        '**[READ-ONLY]** Timestamp when the attempt was last modified. Automatically updated by the system.'
      )
      .readonly()
      .optional(),
    updated_by: z
      .string()
      .describe(
        '**[READ-ONLY]** Email or username of the user who last modified this attempt. Used for audit trails.'
      )
      .readonly()
      .optional(),
    is_completed: z
      .boolean()
      .describe(
        '**[READ-ONLY]** Indicates if the quiz attempt has been completed (submitted or graded).'
      )
      .readonly()
      .optional(),
    grade_display: z
      .string()
      .describe('**[READ-ONLY]** Formatted display of the grade information.')
      .readonly()
      .optional(),
    time_display: z
      .string()
      .describe('**[READ-ONLY]** Formatted display of the time taken to complete the quiz.')
      .readonly()
      .optional(),
    attempt_category: z
      .string()
      .describe('**[READ-ONLY]** Formatted category of the attempt based on outcome and status.')
      .readonly()
      .optional(),
    performance_summary: z
      .string()
      .describe('**[READ-ONLY]** Comprehensive summary of the quiz attempt performance.')
      .readonly()
      .optional(),
  })
  .describe('Student quiz attempt with timing, scoring, and completion tracking');

export const zPagedDtoQuizAttempt = z.object({
  content: z.array(zQuizAttempt).optional(),
  metadata: zPageMetadata.optional(),
  links: zPageLinks.optional(),
});

export const zApiResponsePagedDtoQuizAttempt = z.object({
  success: z.boolean().optional(),
  data: zPagedDtoQuizAttempt.optional(),
  message: z.string().optional(),
  error: z.record(z.unknown()).optional(),
});

export const zPagedDtoQuizQuestion = z.object({
  content: z.array(zQuizQuestion).optional(),
  metadata: zPageMetadata.optional(),
  links: zPageLinks.optional(),
});

export const zApiResponsePagedDtoQuizQuestion = z.object({
  success: z.boolean().optional(),
  data: zPagedDtoQuizQuestion.optional(),
  message: z.string().optional(),
  error: z.record(z.unknown()).optional(),
});

export const zPagedDtoTrainingProgram = z.object({
  content: z.array(zTrainingProgram).optional(),
  metadata: zPageMetadata.optional(),
  links: zPageLinks.optional(),
});

export const zApiResponsePagedDtoTrainingProgram = z.object({
  success: z.boolean().optional(),
  data: zPagedDtoTrainingProgram.optional(),
  message: z.string().optional(),
  error: z.record(z.unknown()).optional(),
});

export const zPagedDtoProgramRequirement = z.object({
  content: z.array(zProgramRequirement).optional(),
  metadata: zPageMetadata.optional(),
  links: zPageLinks.optional(),
});

export const zApiResponsePagedDtoProgramRequirement = z.object({
  success: z.boolean().optional(),
  data: zPagedDtoProgramRequirement.optional(),
  message: z.string().optional(),
  error: z.record(z.unknown()).optional(),
});

/**
 * **[REQUIRED]** Current status of the student's enrollment in the program.
 */
export const zStatusEnum8 = z
  .enum(['ACTIVE', 'COMPLETED', 'DROPPED', 'SUSPENDED'])
  .describe("**[REQUIRED]** Current status of the student's enrollment in the program.");

/**
 * Student enrollment in an educational program with progress tracking and completion details
 */
export const zProgramEnrollment = z
  .object({
    uuid: z
      .string()
      .uuid()
      .describe(
        '**[READ-ONLY]** Unique system identifier for the program enrollment. Auto-generated by the system.'
      )
      .readonly()
      .optional(),
    student_uuid: z
      .string()
      .uuid()
      .describe('**[REQUIRED]** Reference to the student UUID who is enrolled in the program.'),
    program_uuid: z
      .string()
      .uuid()
      .describe('**[REQUIRED]** Reference to the program UUID the student is enrolled in.'),
    enrollment_date: z
      .string()
      .datetime()
      .describe('**[OPTIONAL]** Timestamp when the student enrolled in the program.')
      .optional(),
    completion_date: z
      .string()
      .datetime()
      .describe(
        '**[OPTIONAL]** Timestamp when the student completed the program. Null if not yet completed.'
      )
      .optional(),
    status: zStatusEnum8,
    progress_percentage: z
      .number()
      .gte(0)
      .lte(100)
      .describe('**[OPTIONAL]** Percentage of program content completed by the student.')
      .optional(),
    final_grade: z
      .number()
      .gte(0)
      .lte(100)
      .describe('**[OPTIONAL]** Final grade achieved by the student in the program.')
      .optional(),
    created_date: z
      .string()
      .datetime()
      .describe(
        '**[READ-ONLY]** Timestamp when the enrollment was created. Automatically set by the system.'
      )
      .readonly()
      .optional(),
    created_by: z
      .string()
      .describe(
        '**[READ-ONLY]** Email or username of the user who created this enrollment. Used for audit trails.'
      )
      .readonly()
      .optional(),
    updated_date: z
      .string()
      .datetime()
      .describe(
        '**[READ-ONLY]** Timestamp when the enrollment was last modified. Automatically updated by the system.'
      )
      .readonly()
      .optional(),
    updated_by: z
      .string()
      .describe(
        '**[READ-ONLY]** Email or username of the user who last modified this enrollment. Used for audit trails.'
      )
      .readonly()
      .optional(),
    is_active: z
      .boolean()
      .describe('**[READ-ONLY]** Indicates if the enrollment is currently active and ongoing.')
      .readonly()
      .optional(),
    progress_display: z
      .string()
      .describe("**[READ-ONLY]** Formatted display of the student's progress in the program.")
      .readonly()
      .optional(),
    enrollment_category: z
      .string()
      .describe('**[READ-ONLY]** Formatted category of the enrollment based on current status.')
      .readonly()
      .optional(),
    enrollment_duration: z
      .string()
      .describe(
        '**[READ-ONLY]** Duration of the enrollment from start to completion or current date.'
      )
      .readonly()
      .optional(),
    status_summary: z
      .string()
      .describe(
        '**[READ-ONLY]** Comprehensive summary of the enrollment status with relevant details.'
      )
      .readonly()
      .optional(),
  })
  .describe(
    'Student enrollment in an educational program with progress tracking and completion details'
  );

export const zPagedDtoProgramEnrollment = z.object({
  content: z.array(zProgramEnrollment).optional(),
  metadata: zPageMetadata.optional(),
  links: zPageLinks.optional(),
});

export const zApiResponsePagedDtoProgramEnrollment = z.object({
  success: z.boolean().optional(),
  data: zPagedDtoProgramEnrollment.optional(),
  message: z.string().optional(),
  error: z.record(z.unknown()).optional(),
});

export const zApiResponseListCourse = z.object({
  success: z.boolean().optional(),
  data: z.array(zCourse).optional(),
  message: z.string().optional(),
  error: z.record(z.unknown()).optional(),
});

export const zApiResponseDouble = z.object({
  success: z.boolean().optional(),
  data: z.number().optional(),
  message: z.string().optional(),
  error: z.record(z.unknown()).optional(),
});

export const zPagedDtoCertificate = z.object({
  content: z.array(zCertificate).optional(),
  metadata: zPageMetadata.optional(),
  links: zPageLinks.optional(),
});

export const zApiResponsePagedDtoCertificate = z.object({
  success: z.boolean().optional(),
  data: zPagedDtoCertificate.optional(),
  message: z.string().optional(),
  error: z.record(z.unknown()).optional(),
});

export const zPagedDtoProgramCourse = z.object({
  content: z.array(zProgramCourse).optional(),
  metadata: zPageMetadata.optional(),
  links: zPageLinks.optional(),
});

export const zApiResponsePagedDtoProgramCourse = z.object({
  success: z.boolean().optional(),
  data: zPagedDtoProgramCourse.optional(),
  message: z.string().optional(),
  error: z.record(z.unknown()).optional(),
});

export const zPagedDtoOrganisation = z.object({
  content: z.array(zOrganisation).optional(),
  metadata: zPageMetadata.optional(),
  links: zPageLinks.optional(),
});

export const zApiResponsePagedDtoOrganisation = z.object({
  success: z.boolean().optional(),
  data: zPagedDtoOrganisation.optional(),
  message: z.string().optional(),
  error: z.record(z.unknown()).optional(),
});

export const zApiResponseListUser = z.object({
  success: z.boolean().optional(),
  data: z.array(zUser).optional(),
  message: z.string().optional(),
  error: z.record(z.unknown()).optional(),
});

/**
 * Display name of the role/domain being offered
 */
export const zRoleNameEnum = z
  .enum(['Student', 'Instructor', 'Administrator', 'Organization Member'])
  .describe('Display name of the role/domain being offered');

/**
 * Public-safe invitation details shown to users before authentication
 */
export const zInvitationPreview = z
  .object({
    recipient_name: z.string().describe('Full name of the person being invited'),
    organisation_name: z.string().describe('Name of the organization extending the invitation'),
    branch_name: z
      .string()
      .describe('Name of the specific training branch (if applicable)')
      .optional(),
    role_name: zRoleNameEnum,
    role_description: z
      .string()
      .describe("Detailed description of the role's responsibilities and permissions"),
    inviter_name: z.string().describe('Full name of the person who sent the invitation'),
    expires_at: z
      .string()
      .datetime()
      .describe('Date and time when the invitation expires in ISO 8601 format'),
    notes: z
      .string()
      .describe('Optional personal message or notes included with the invitation')
      .optional(),
    is_expired: z
      .boolean()
      .describe('Indicates whether the invitation has expired and can no longer be accepted'),
    requires_registration: z
      .boolean()
      .describe(
        'Indicates whether the recipient needs to register an account before accepting. True for student/instructor/course_creator roles, false for admin/organisation_user roles.'
      ),
  })
  .describe('Public-safe invitation details shown to users before authentication');

export const zApiResponseInvitationPreview = z.object({
  success: z.boolean().optional(),
  data: zInvitationPreview.optional(),
  message: z.string().optional(),
  error: z.record(z.unknown()).optional(),
});

export const zPagedDtoInstructor = z.object({
  content: z.array(zInstructor).optional(),
  metadata: zPageMetadata.optional(),
  links: zPageLinks.optional(),
});

export const zApiResponsePagedDtoInstructor = z.object({
  success: z.boolean().optional(),
  data: zPagedDtoInstructor.optional(),
  message: z.string().optional(),
  error: z.record(z.unknown()).optional(),
});

export const zPagedDtoInstructorSkill = z.object({
  content: z.array(zInstructorSkill).optional(),
  metadata: zPageMetadata.optional(),
  links: zPageLinks.optional(),
});

export const zApiResponsePagedDtoInstructorSkill = z.object({
  success: z.boolean().optional(),
  data: zPagedDtoInstructorSkill.optional(),
  message: z.string().optional(),
  error: z.record(z.unknown()).optional(),
});

export const zPagedDtoInstructorProfessionalMembership = z.object({
  content: z.array(zInstructorProfessionalMembership).optional(),
  metadata: zPageMetadata.optional(),
  links: zPageLinks.optional(),
});

export const zApiResponsePagedDtoInstructorProfessionalMembership = z.object({
  success: z.boolean().optional(),
  data: zPagedDtoInstructorProfessionalMembership.optional(),
  message: z.string().optional(),
  error: z.record(z.unknown()).optional(),
});

export const zPagedDtoInstructorExperience = z.object({
  content: z.array(zInstructorExperience).optional(),
  metadata: zPageMetadata.optional(),
  links: zPageLinks.optional(),
});

export const zApiResponsePagedDtoInstructorExperience = z.object({
  success: z.boolean().optional(),
  data: zPagedDtoInstructorExperience.optional(),
  message: z.string().optional(),
  error: z.record(z.unknown()).optional(),
});

export const zApiResponseListInstructorEducation = z.object({
  success: z.boolean().optional(),
  data: z.array(zInstructorEducation).optional(),
  message: z.string().optional(),
  error: z.record(z.unknown()).optional(),
});

export const zApiResponseListInstructorDocument = z.object({
  success: z.boolean().optional(),
  data: z.array(zInstructorDocument).optional(),
  message: z.string().optional(),
  error: z.record(z.unknown()).optional(),
});

export const zApiResponseListAvailabilitySlot = z.object({
  success: z.boolean().optional(),
  data: z.array(zAvailabilitySlot).optional(),
  message: z.string().optional(),
  error: z.record(z.unknown()).optional(),
});

export const zPagedDtoInstructorEducation = z.object({
  content: z.array(zInstructorEducation).optional(),
  metadata: zPageMetadata.optional(),
  links: zPageLinks.optional(),
});

export const zApiResponsePagedDtoInstructorEducation = z.object({
  success: z.boolean().optional(),
  data: zPagedDtoInstructorEducation.optional(),
  message: z.string().optional(),
  error: z.record(z.unknown()).optional(),
});

export const zPagedDtoInstructorDocument = z.object({
  content: z.array(zInstructorDocument).optional(),
  metadata: zPageMetadata.optional(),
  links: zPageLinks.optional(),
});

export const zApiResponsePagedDtoInstructorDocument = z.object({
  success: z.boolean().optional(),
  data: zPagedDtoInstructorDocument.optional(),
  message: z.string().optional(),
  error: z.record(z.unknown()).optional(),
});

/**
 * A student's view of their scheduled classes with enrollment information
 */
export const zStudentSchedule = z
  .object({
    enrollment_uuid: z
      .string()
      .uuid()
      .describe('**[READ-ONLY]** Unique system identifier for the enrollment.')
      .readonly()
      .optional(),
    scheduled_instance_uuid: z
      .string()
      .uuid()
      .describe('**[READ-ONLY]** Reference to the scheduled instance.')
      .readonly()
      .optional(),
    class_definition_uuid: z
      .string()
      .uuid()
      .describe('**[READ-ONLY]** Reference to the class definition.')
      .readonly()
      .optional(),
    instructor_uuid: z
      .string()
      .uuid()
      .describe('**[READ-ONLY]** Reference to the instructor.')
      .readonly()
      .optional(),
    title: z
      .string()
      .describe('**[READ-ONLY]** Title of the scheduled class.')
      .readonly()
      .optional(),
    start_time: z
      .string()
      .datetime()
      .describe('**[READ-ONLY]** Start date and time of the scheduled class.')
      .readonly()
      .optional(),
    end_time: z
      .string()
      .datetime()
      .describe('**[READ-ONLY]** End date and time of the scheduled class.')
      .readonly()
      .optional(),
    timezone: z
      .string()
      .describe('**[READ-ONLY]** Timezone for the scheduled class.')
      .readonly()
      .optional(),
    location_type: zLocationTypeEnum.optional(),
    scheduling_status: zStatusEnum3.optional(),
    enrollment_status: zStatusEnum5.optional(),
    attendance_marked_at: z
      .string()
      .datetime()
      .describe('**[READ-ONLY]** Timestamp when attendance was marked (if applicable).')
      .readonly()
      .optional(),
    duration_minutes: z.coerce
      .bigint()
      .describe('**[READ-ONLY]** Duration of the scheduled class in minutes.')
      .readonly()
      .optional(),
    did_attend: z
      .boolean()
      .describe('**[READ-ONLY]** Indicates if the student attended this class.')
      .readonly()
      .optional(),
    is_upcoming: z
      .boolean()
      .describe('**[READ-ONLY]** Indicates if this class is upcoming.')
      .readonly()
      .optional(),
  })
  .describe("A student's view of their scheduled classes with enrollment information");

export const zApiResponseListStudentSchedule = z.object({
  success: z.boolean().optional(),
  data: z.array(zStudentSchedule).optional(),
  message: z.string().optional(),
  error: z.record(z.unknown()).optional(),
});

export const zApiResponseListEnrollment = z.object({
  success: z.boolean().optional(),
  data: z.array(zEnrollment).optional(),
  message: z.string().optional(),
  error: z.record(z.unknown()).optional(),
});

export const zApiResponseLong = z.object({
  success: z.boolean().optional(),
  data: z.coerce.bigint().optional(),
  message: z.string().optional(),
  error: z.record(z.unknown()).optional(),
});

export const zPagedDtoCourse = z.object({
  content: z.array(zCourse).optional(),
  metadata: zPageMetadata.optional(),
  links: zPageLinks.optional(),
});

export const zApiResponsePagedDtoCourse = z.object({
  success: z.boolean().optional(),
  data: zPagedDtoCourse.optional(),
  message: z.string().optional(),
  error: z.record(z.unknown()).optional(),
});

export const zApiResponseListContentStatus = z.object({
  success: z.boolean().optional(),
  data: z.array(zSchemaEnum).optional(),
  message: z.string().optional(),
  error: z.record(z.unknown()).optional(),
});

export const zPagedDtoCourseTrainingRequirement = z.object({
  content: z.array(zCourseTrainingRequirement).optional(),
  metadata: zPageMetadata.optional(),
  links: zPageLinks.optional(),
});

export const zApiResponsePagedDtoCourseTrainingRequirement = z.object({
  success: z.boolean().optional(),
  data: zPagedDtoCourseTrainingRequirement.optional(),
  message: z.string().optional(),
  error: z.record(z.unknown()).optional(),
});

export const zPagedDtoCourseRubricAssociation = z.object({
  content: z.array(zCourseRubricAssociation).optional(),
  metadata: zPageMetadata.optional(),
  links: zPageLinks.optional(),
});

export const zApiResponsePagedDtoCourseRubricAssociation = z.object({
  success: z.boolean().optional(),
  data: zPagedDtoCourseRubricAssociation.optional(),
  message: z.string().optional(),
  error: z.record(z.unknown()).optional(),
});

export const zPagedDtoCourseRequirement = z.object({
  content: z.array(zCourseRequirement).optional(),
  metadata: zPageMetadata.optional(),
  links: zPageLinks.optional(),
});

export const zApiResponsePagedDtoCourseRequirement = z.object({
  success: z.boolean().optional(),
  data: zPagedDtoCourseRequirement.optional(),
  message: z.string().optional(),
  error: z.record(z.unknown()).optional(),
});

export const zPagedDtoLesson = z.object({
  content: z.array(zLesson).optional(),
  metadata: zPageMetadata.optional(),
  links: zPageLinks.optional(),
});

export const zApiResponsePagedDtoLesson = z.object({
  success: z.boolean().optional(),
  data: zPagedDtoLesson.optional(),
  message: z.string().optional(),
  error: z.record(z.unknown()).optional(),
});

export const zApiResponseListLessonContent = z.object({
  success: z.boolean().optional(),
  data: z.array(zLessonContent).optional(),
  message: z.string().optional(),
  error: z.record(z.unknown()).optional(),
});

/**
 * Student enrollment in a course with progress tracking and completion details
 */
export const zCourseEnrollment = z
  .object({
    uuid: z
      .string()
      .uuid()
      .describe(
        '**[READ-ONLY]** Unique system identifier for the course enrollment. Auto-generated by the system.'
      )
      .readonly()
      .optional(),
    student_uuid: z
      .string()
      .uuid()
      .describe('**[REQUIRED]** Reference to the student UUID who is enrolled in the course.'),
    course_uuid: z
      .string()
      .uuid()
      .describe('**[REQUIRED]** Reference to the course UUID the student is enrolled in.'),
    enrollment_date: z
      .string()
      .datetime()
      .describe('**[OPTIONAL]** Timestamp when the student enrolled in the course.')
      .optional(),
    completion_date: z
      .string()
      .datetime()
      .describe(
        '**[OPTIONAL]** Timestamp when the student completed the course. Null if not yet completed.'
      )
      .optional(),
    status: zStatusEnum8,
    progress_percentage: z
      .number()
      .gte(0)
      .lte(100)
      .describe('**[OPTIONAL]** Percentage of course content completed by the student.')
      .optional(),
    final_grade: z
      .number()
      .gte(0)
      .lte(100)
      .describe('**[OPTIONAL]** Final grade achieved by the student in the course.')
      .optional(),
    created_date: z
      .string()
      .datetime()
      .describe(
        '**[READ-ONLY]** Timestamp when the enrollment was created. Automatically set by the system.'
      )
      .readonly()
      .optional(),
    created_by: z
      .string()
      .describe(
        '**[READ-ONLY]** Email or username of the user who created this enrollment. Used for audit trails.'
      )
      .readonly()
      .optional(),
    updated_date: z
      .string()
      .datetime()
      .describe(
        '**[READ-ONLY]** Timestamp when the enrollment was last modified. Automatically updated by the system.'
      )
      .readonly()
      .optional(),
    updated_by: z
      .string()
      .describe(
        '**[READ-ONLY]** Email or username of the user who last modified this enrollment. Used for audit trails.'
      )
      .readonly()
      .optional(),
    is_active: z
      .boolean()
      .describe('**[READ-ONLY]** Indicates if the enrollment is currently active and ongoing.')
      .readonly()
      .optional(),
    progress_display: z
      .string()
      .describe("**[READ-ONLY]** Formatted display of the student's progress in the course.")
      .readonly()
      .optional(),
    enrollment_category: z
      .string()
      .describe('**[READ-ONLY]** Formatted category of the enrollment based on current status.')
      .readonly()
      .optional(),
    enrollment_duration: z
      .string()
      .describe(
        '**[READ-ONLY]** Duration of the enrollment from start to completion or current date.'
      )
      .readonly()
      .optional(),
    status_summary: z
      .string()
      .describe(
        '**[READ-ONLY]** Comprehensive summary of the enrollment status with relevant details.'
      )
      .readonly()
      .optional(),
  })
  .describe('Student enrollment in a course with progress tracking and completion details');

export const zPagedDtoCourseEnrollment = z.object({
  content: z.array(zCourseEnrollment).optional(),
  metadata: zPageMetadata.optional(),
  links: zPageLinks.optional(),
});

export const zApiResponsePagedDtoCourseEnrollment = z.object({
  success: z.boolean().optional(),
  data: zPagedDtoCourseEnrollment.optional(),
  message: z.string().optional(),
  error: z.record(z.unknown()).optional(),
});

/**
 * Represents the many-to-many relationship between courses and categories
 */
export const zCourseCategoryMapping = z
  .object({
    uuid: z
      .string()
      .uuid()
      .describe(
        '**[READ-ONLY]** Unique system identifier for the mapping. Auto-generated by the system.'
      )
      .readonly()
      .optional(),
    course_uuid: z
      .string()
      .uuid()
      .describe('**[REQUIRED]** Reference to the course UUID in this mapping.'),
    category_uuid: z
      .string()
      .uuid()
      .describe('**[REQUIRED]** Reference to the category UUID in this mapping.'),
    course_name: z
      .string()
      .describe(
        '**[READ-ONLY]** Name of the course for display purposes. Fetched from the course entity.'
      )
      .readonly()
      .optional(),
    category_name: z
      .string()
      .describe(
        '**[READ-ONLY]** Name of the category for display purposes. Fetched from the category entity.'
      )
      .readonly()
      .optional(),
    created_date: z
      .string()
      .datetime()
      .describe(
        '**[READ-ONLY]** Timestamp when the mapping was created. Automatically set by the system.'
      )
      .readonly()
      .optional(),
    created_by: z
      .string()
      .describe(
        '**[READ-ONLY]** Email or username of the user who created this mapping. Used for audit trails.'
      )
      .readonly()
      .optional(),
    updated_date: z
      .string()
      .datetime()
      .describe(
        '**[READ-ONLY]** Timestamp when the mapping was last modified. Automatically updated by the system.'
      )
      .readonly()
      .optional(),
    updated_by: z
      .string()
      .describe(
        '**[READ-ONLY]** Email or username of the user who last modified this mapping. Used for audit trails.'
      )
      .readonly()
      .optional(),
    has_names: z
      .boolean()
      .describe('**[READ-ONLY]** Indicates if both course and category names are populated.')
      .readonly()
      .optional(),
    display_text: z
      .string()
      .describe(
        '**[READ-ONLY]** Human-readable text representing this course-category relationship.'
      )
      .readonly()
      .optional(),
  })
  .describe('Represents the many-to-many relationship between courses and categories');

export const zApiResponseListCourseCategoryMapping = z.object({
  success: z.boolean().optional(),
  data: z.array(zCourseCategoryMapping).optional(),
  message: z.string().optional(),
  error: z.record(z.unknown()).optional(),
});

export const zPagedDtoCourseAssessment = z.object({
  content: z.array(zCourseAssessment).optional(),
  metadata: zPageMetadata.optional(),
  links: zPageLinks.optional(),
});

export const zApiResponsePagedDtoCourseAssessment = z.object({
  success: z.boolean().optional(),
  data: zPagedDtoCourseAssessment.optional(),
  message: z.string().optional(),
  error: z.record(z.unknown()).optional(),
});

export const zPagedDtoLessonContent = z.object({
  content: z.array(zLessonContent).optional(),
  metadata: zPageMetadata.optional(),
  links: zPageLinks.optional(),
});

export const zApiResponsePagedDtoLessonContent = z.object({
  success: z.boolean().optional(),
  data: zPagedDtoLessonContent.optional(),
  message: z.string().optional(),
  error: z.record(z.unknown()).optional(),
});

export const zPagedDtoCourseCategoryMapping = z.object({
  content: z.array(zCourseCategoryMapping).optional(),
  metadata: zPageMetadata.optional(),
  links: zPageLinks.optional(),
});

export const zApiResponsePagedDtoCourseCategoryMapping = z.object({
  success: z.boolean().optional(),
  data: zPagedDtoCourseCategoryMapping.optional(),
  message: z.string().optional(),
  error: z.record(z.unknown()).optional(),
});

export const zPagedDtoCourseCreator = z.object({
  content: z.array(zCourseCreator).optional(),
  metadata: zPageMetadata.optional(),
  links: zPageLinks.optional(),
});

export const zApiResponsePagedDtoCourseCreator = z.object({
  success: z.boolean().optional(),
  data: zPagedDtoCourseCreator.optional(),
  message: z.string().optional(),
  error: z.record(z.unknown()).optional(),
});

export const zPagedDtoGradingLevel = z.object({
  content: z.array(zGradingLevel).optional(),
  metadata: zPageMetadata.optional(),
  links: zPageLinks.optional(),
});

export const zApiResponsePagedDtoGradingLevel = z.object({
  success: z.boolean().optional(),
  data: zPagedDtoGradingLevel.optional(),
  message: z.string().optional(),
  error: z.record(z.unknown()).optional(),
});

export const zApiResponseListDifficultyLevel = z.object({
  success: z.boolean().optional(),
  data: z.array(zDifficultyLevel).optional(),
  message: z.string().optional(),
  error: z.record(z.unknown()).optional(),
});

export const zPagedDtoContentType = z.object({
  content: z.array(zContentType).optional(),
  metadata: zPageMetadata.optional(),
  links: zPageLinks.optional(),
});

export const zApiResponsePagedDtoContentType = z.object({
  success: z.boolean().optional(),
  data: zPagedDtoContentType.optional(),
  message: z.string().optional(),
  error: z.record(z.unknown()).optional(),
});

export const zApiResponseListContentType = z.object({
  success: z.boolean().optional(),
  data: z.array(zContentType).optional(),
  message: z.string().optional(),
  error: z.record(z.unknown()).optional(),
});

export const zPagedDtoCategory = z.object({
  content: z.array(zCategory).optional(),
  metadata: zPageMetadata.optional(),
  links: zPageLinks.optional(),
});

export const zApiResponsePagedDtoCategory = z.object({
  success: z.boolean().optional(),
  data: zPagedDtoCategory.optional(),
  message: z.string().optional(),
  error: z.record(z.unknown()).optional(),
});

export const zApiResponseListCategory = z.object({
  success: z.boolean().optional(),
  data: z.array(zCategory).optional(),
  message: z.string().optional(),
  error: z.record(z.unknown()).optional(),
});

export const zApiResponseListCommerceCatalogItem = z.object({
  success: z.boolean().optional(),
  data: z.array(zCommerceCatalogItem).optional(),
  message: z.string().optional(),
  error: z.record(z.unknown()).optional(),
});

export const zApiResponseListClassDefinition = z.object({
  success: z.boolean().optional(),
  data: z.array(zClassDefinition).optional(),
  message: z.string().optional(),
  error: z.record(z.unknown()).optional(),
});

export const zPagedDtoCertificateTemplate = z.object({
  content: z.array(zCertificateTemplate).optional(),
  metadata: zPageMetadata.optional(),
  links: zPageLinks.optional(),
});

export const zApiResponsePagedDtoCertificateTemplate = z.object({
  success: z.boolean().optional(),
  data: zPagedDtoCertificateTemplate.optional(),
  message: z.string().optional(),
  error: z.record(z.unknown()).optional(),
});

export const zApiResponseListCertificate = z.object({
  success: z.boolean().optional(),
  data: z.array(zCertificate).optional(),
  message: z.string().optional(),
  error: z.record(z.unknown()).optional(),
});

export const zPagedDtoAssignment = z.object({
  content: z.array(zAssignment).optional(),
  metadata: zPageMetadata.optional(),
  links: zPageLinks.optional(),
});

export const zApiResponsePagedDtoAssignment = z.object({
  success: z.boolean().optional(),
  data: zPagedDtoAssignment.optional(),
  message: z.string().optional(),
  error: z.record(z.unknown()).optional(),
});

export const zApiResponseListAssignmentSubmission = z.object({
  success: z.boolean().optional(),
  data: z.array(zAssignmentSubmission).optional(),
  message: z.string().optional(),
  error: z.record(z.unknown()).optional(),
});

export const zPagedDtoAssignmentSubmission = z.object({
  content: z.array(zAssignmentSubmission).optional(),
  metadata: zPageMetadata.optional(),
  links: zPageLinks.optional(),
});

export const zApiResponsePagedDtoAssignmentSubmission = z.object({
  success: z.boolean().optional(),
  data: zPagedDtoAssignmentSubmission.optional(),
  message: z.string().optional(),
  error: z.record(z.unknown()).optional(),
});

/**
 * User metrics for dashboard
 */
export const zUserMetrics = z
  .object({
    total_users: z.coerce.bigint().optional(),
    active_users_24h: z.coerce.bigint().optional(),
    new_registrations_7d: z.coerce.bigint().optional(),
    suspended_accounts: z.coerce.bigint().optional(),
  })
  .describe('User metrics for dashboard');

/**
 * Organization metrics for dashboard
 */
export const zOrganizationMetrics = z
  .object({
    total_organizations: z.coerce.bigint().optional(),
    pending_approvals: z.coerce.bigint().optional(),
    active_organizations: z.coerce.bigint().optional(),
    suspended_organizations: z.coerce.bigint().optional(),
  })
  .describe('Organization metrics for dashboard');

/**
 * Content metrics for dashboard
 */
export const zContentMetrics = z
  .object({
    total_courses: z.coerce.bigint().optional(),
    pending_moderation: z.coerce.bigint().optional(),
    reported_content: z.coerce.bigint().optional(),
    average_quality_score: z.number().optional(),
  })
  .describe('Content metrics for dashboard');

/**
 * System performance metrics
 */
export const zSystemPerformance = z
  .object({
    server_uptime: z.string().optional(),
    average_response_time: z.string().optional(),
    error_rate: z.string().optional(),
    storage_usage: z.string().optional(),
  })
  .describe('System performance metrics');

/**
 * Admin-specific metrics
 */
export const zAdminMetrics = z
  .object({
    total_admins: z.coerce.bigint().optional(),
    active_admin_sessions: z.coerce.bigint().optional(),
    admin_actions_today: z.coerce.bigint().optional(),
    system_admins: z.coerce.bigint().optional(),
    organization_admins: z.coerce.bigint().optional(),
  })
  .describe('Admin-specific metrics');

/**
 * Comprehensive statistics for the admin dashboard
 */
export const zAdminDashboardStats = z
  .object({
    timestamp: z
      .string()
      .datetime()
      .describe('Timestamp when statistics were generated')
      .optional(),
    overall_health: z.string().describe('Overall system health status').optional(),
    user_metrics: zUserMetrics.optional(),
    organization_metrics: zOrganizationMetrics.optional(),
    content_metrics: zContentMetrics.optional(),
    system_performance: zSystemPerformance.optional(),
    admin_metrics: zAdminMetrics.optional(),
  })
  .describe('Comprehensive statistics for the admin dashboard');

export const zApiResponseAdminDashboardStats = z.object({
  success: z.boolean().optional(),
  data: zAdminDashboardStats.optional(),
  message: z.string().optional(),
  error: z.record(z.unknown()).optional(),
});

/**
 * Valid African phone number in international or local format
 */
export const zAfricanPhoneNumber = z
  .unknown()
  .describe('Valid African phone number in international or local format');

/**
 * Valid Kenyan mobile phone number (Safaricom, Airtel formats)
 */
export const zKenyanPhoneNumber = z
  .unknown()
  .describe('Valid Kenyan mobile phone number (Safaricom, Airtel formats)');

/**
 * Valid Nigerian mobile phone number (MTN, Glo, Airtel, 9mobile formats)
 */
export const zNigerianPhoneNumber = z
  .unknown()
  .describe('Valid Nigerian mobile phone number (MTN, Glo, Airtel, 9mobile formats)');

/**
 * Valid East African phone number (Kenya, Uganda, Tanzania, Rwanda, Burundi, South Sudan)
 */
export const zEastAfricanPhoneNumber = z
  .unknown()
  .describe(
    'Valid East African phone number (Kenya, Uganda, Tanzania, Rwanda, Burundi, South Sudan)'
  );

/**
 * Valid West African phone number (Nigeria, Ghana, Senegal, Mali, etc.)
 */
export const zWestAfricanPhoneNumber = z
  .unknown()
  .describe('Valid West African phone number (Nigeria, Ghana, Senegal, Mali, etc.)');

/**
 * Valid Southern African phone number (South Africa, Zimbabwe, Zambia, Botswana, etc.)
 */
export const zSouthernAfricanPhoneNumber = z
  .unknown()
  .describe('Valid Southern African phone number (South Africa, Zimbabwe, Zambia, Botswana, etc.)');

/**
 * Valid international phone number in E.164 format
 */
export const zInternationalPhoneNumber = z
  .unknown()
  .describe('Valid international phone number in E.164 format');

/**
 * A valid URL with HTTP or HTTPS protocol
 */
export const zValidUrl = z.unknown().describe('A valid URL with HTTP or HTTPS protocol');

/**
 * A valid website URL for personal or business websites
 */
export const zWebsiteUrl = z
  .unknown()
  .describe('A valid website URL for personal or business websites');

/**
 * A secure HTTPS URL for API endpoints
 */
export const zApiUrl = z.unknown().describe('A secure HTTPS URL for API endpoints');

/**
 * A valid URL pointing to an image file
 */
export const zImageUrl = z.unknown().describe('A valid URL pointing to an image file');

/**
 * A valid URL pointing to a document file
 */
export const zDocumentUrl = z.unknown().describe('A valid URL pointing to a document file');

/**
 * A valid social media profile URL
 */
export const zSocialMediaUrl = z.unknown().describe('A valid social media profile URL');

export const zDeleteUserData = z.object({
  body: z.never().optional(),
  path: z.object({
    uuid: z
      .string()
      .uuid()
      .describe(
        'UUID of the user to delete. This will remove the user and all their organization relationships.'
      ),
  }),
  query: z.never().optional(),
});

/**
 * User deleted successfully
 */
export const zDeleteUserResponse = zApiResponseVoid;

export const zGetUserByUuidData = z.object({
  body: z.never().optional(),
  path: z.object({
    uuid: z
      .string()
      .uuid()
      .describe('UUID of the user to retrieve. Must be an existing user identifier.'),
  }),
  query: z.never().optional(),
});

/**
 * User retrieved successfully
 */
export const zGetUserByUuidResponse = zApiResponseUser;

export const zUpdateUserData = z.object({
  body: zUser,
  path: z.object({
    uuid: z
      .string()
      .uuid()
      .describe('UUID of the user to update. Must be an existing user identifier.'),
  }),
  query: z.never().optional(),
});

/**
 * User updated successfully
 */
export const zUpdateUserResponse = zApiResponseUser;

export const zDeleteTrainingBranchData = z.object({
  body: z.never().optional(),
  path: z.object({
    uuid: z.string().uuid(),
  }),
  query: z.never().optional(),
});

/**
 * Training branch deleted successfully
 */
export const zDeleteTrainingBranchResponse = zApiResponseVoid;

export const zGetTrainingBranchByUuidData = z.object({
  body: z.never().optional(),
  path: z.object({
    uuid: z.string().uuid(),
  }),
  query: z.never().optional(),
});

/**
 * Training branch retrieved successfully
 */
export const zGetTrainingBranchByUuidResponse = zApiResponseTrainingBranch;

export const zUpdateTrainingBranchData = z.object({
  body: zTrainingBranch,
  path: z.object({
    uuid: z.string().uuid(),
  }),
  query: z.never().optional(),
});

/**
 * Training branch updated successfully
 */
export const zUpdateTrainingBranchResponse = zApiResponseTrainingBranch;

export const zDeleteStudentData = z.object({
  body: z.never().optional(),
  path: z.object({
    uuid: z.string().uuid(),
  }),
  query: z.never().optional(),
});

/**
 * Student deleted successfully
 */
export const zDeleteStudentResponse = zApiResponseVoid;

export const zGetStudentByIdData = z.object({
  body: z.never().optional(),
  path: z.object({
    uuid: z.string().uuid(),
  }),
  query: z.never().optional(),
});

/**
 * Student found
 */
export const zGetStudentByIdResponse = zStudent;

export const zUpdateStudentData = z.object({
  body: zStudent,
  path: z.object({
    uuid: z.string().uuid(),
  }),
  query: z.never().optional(),
});

/**
 * Student updated successfully
 */
export const zUpdateStudentResponse = zStudent;

export const zDeleteAssessmentRubricData = z.object({
  body: z.never().optional(),
  path: z.object({
    uuid: z.string().uuid(),
  }),
  query: z.never().optional(),
});

export const zGetAssessmentRubricByUuidData = z.object({
  body: z.never().optional(),
  path: z.object({
    uuid: z.string().uuid(),
  }),
  query: z.never().optional(),
});

/**
 * OK
 */
export const zGetAssessmentRubricByUuidResponse = zApiResponseAssessmentRubric;

export const zUpdateAssessmentRubricData = z.object({
  body: zAssessmentRubric,
  path: z.object({
    uuid: z.string().uuid(),
  }),
  query: z.never().optional(),
});

/**
 * OK
 */
export const zUpdateAssessmentRubricResponse = zApiResponseAssessmentRubric;

export const zDeleteScoringLevelData = z.object({
  body: z.never().optional(),
  path: z.object({
    rubricUuid: z.string().uuid().describe('UUID of the rubric'),
    levelUuid: z.string().uuid().describe('UUID of the scoring level'),
  }),
  query: z.never().optional(),
});

/**
 * OK
 */
export const zDeleteScoringLevelResponse = zApiResponseVoid;

export const zGetScoringLevelData = z.object({
  body: z.never().optional(),
  path: z.object({
    rubricUuid: z.string().uuid().describe('UUID of the rubric'),
    levelUuid: z.string().uuid().describe('UUID of the scoring level'),
  }),
  query: z.never().optional(),
});

/**
 * OK
 */
export const zGetScoringLevelResponse = zApiResponseRubricScoringLevel;

export const zUpdateScoringLevelData = z.object({
  body: zRubricScoringLevel,
  path: z.object({
    rubricUuid: z.string().uuid().describe('UUID of the rubric'),
    levelUuid: z.string().uuid().describe('UUID of the scoring level'),
  }),
  query: z.never().optional(),
});

/**
 * OK
 */
export const zUpdateScoringLevelResponse = zApiResponseRubricScoringLevel;

export const zUpdateMatrixCellData = z.object({
  body: zRubricMatrixCell,
  path: z.object({
    rubricUuid: z.string().uuid().describe('UUID of the rubric'),
  }),
  query: z.never().optional(),
});

/**
 * OK
 */
export const zUpdateMatrixCellResponse = zApiResponseRubricMatrix;

export const zDeleteRubricCriterionData = z.object({
  body: z.never().optional(),
  path: z.object({
    rubricUuid: z.string().uuid(),
    criteriaUuid: z.string().uuid(),
  }),
  query: z.never().optional(),
});

export const zUpdateRubricCriterionData = z.object({
  body: zRubricCriteria,
  path: z.object({
    rubricUuid: z.string().uuid(),
    criteriaUuid: z.string().uuid(),
  }),
  query: z.never().optional(),
});

/**
 * OK
 */
export const zUpdateRubricCriterionResponse = zApiResponseRubricCriteria;

export const zDeleteRubricScoringData = z.object({
  body: z.never().optional(),
  path: z.object({
    rubricUuid: z.string().uuid(),
    criteriaUuid: z.string().uuid(),
    scoringUuid: z.string().uuid(),
  }),
  query: z.never().optional(),
});

export const zUpdateRubricScoringData = z.object({
  body: zRubricScoring,
  path: z.object({
    rubricUuid: z.string().uuid(),
    criteriaUuid: z.string().uuid(),
    scoringUuid: z.string().uuid(),
  }),
  query: z.never().optional(),
});

/**
 * OK
 */
export const zUpdateRubricScoringResponse = zApiResponseRubricScoring;

export const zDeleteQuizData = z.object({
  body: z.never().optional(),
  path: z.object({
    uuid: z.string().uuid(),
  }),
  query: z.never().optional(),
});

/**
 * Quiz deleted successfully
 */
export const zDeleteQuizResponse = z.void().describe('Quiz deleted successfully');

export const zGetQuizByUuidData = z.object({
  body: z.never().optional(),
  path: z.object({
    uuid: z.string().uuid(),
  }),
  query: z.never().optional(),
});

/**
 * Quiz found
 */
export const zGetQuizByUuidResponse = zApiResponseQuiz;

export const zUpdateQuizData = z.object({
  body: zQuiz,
  path: z.object({
    uuid: z.string().uuid(),
  }),
  query: z.never().optional(),
});

/**
 * Quiz updated successfully
 */
export const zUpdateQuizResponse = zApiResponseQuiz;

export const zDeleteQuizQuestionData = z.object({
  body: z.never().optional(),
  path: z.object({
    quizUuid: z.string().uuid(),
    questionUuid: z.string().uuid(),
  }),
  query: z.never().optional(),
});

export const zUpdateQuizQuestionData = z.object({
  body: zQuizQuestion,
  path: z.object({
    quizUuid: z.string().uuid(),
    questionUuid: z.string().uuid(),
  }),
  query: z.never().optional(),
});

/**
 * OK
 */
export const zUpdateQuizQuestionResponse = zApiResponseQuizQuestion;

export const zDeleteQuestionOptionData = z.object({
  body: z.never().optional(),
  path: z.object({
    quizUuid: z.string().uuid(),
    questionUuid: z.string().uuid(),
    optionUuid: z.string().uuid(),
  }),
  query: z.never().optional(),
});

export const zUpdateQuestionOptionData = z.object({
  body: zQuizQuestionOption,
  path: z.object({
    quizUuid: z.string().uuid(),
    questionUuid: z.string().uuid(),
    optionUuid: z.string().uuid(),
  }),
  query: z.never().optional(),
});

/**
 * OK
 */
export const zUpdateQuestionOptionResponse = zApiResponseQuizQuestionOption;

export const zDeleteTrainingProgramData = z.object({
  body: z.never().optional(),
  path: z.object({
    uuid: z.string().uuid(),
  }),
  query: z.never().optional(),
});

/**
 * Program deleted successfully
 */
export const zDeleteTrainingProgramResponse = zApiResponseVoid;

export const zGetTrainingProgramByUuidData = z.object({
  body: z.never().optional(),
  path: z.object({
    uuid: z.string().uuid(),
  }),
  query: z.never().optional(),
});

/**
 * Program found
 */
export const zGetTrainingProgramByUuidResponse = zApiResponseTrainingProgram;

export const zUpdateTrainingProgramData = z.object({
  body: zTrainingProgram,
  path: z.object({
    uuid: z.string().uuid(),
  }),
  query: z.never().optional(),
});

/**
 * Program updated successfully
 */
export const zUpdateTrainingProgramResponse = zApiResponseTrainingProgram;

export const zDeleteProgramRequirementData = z.object({
  body: z.never().optional(),
  path: z.object({
    programUuid: z.string().uuid(),
    requirementUuid: z.string().uuid(),
  }),
  query: z.never().optional(),
});

export const zUpdateProgramRequirementData = z.object({
  body: zProgramRequirement,
  path: z.object({
    programUuid: z.string().uuid(),
    requirementUuid: z.string().uuid(),
  }),
  query: z.never().optional(),
});

/**
 * OK
 */
export const zUpdateProgramRequirementResponse = zApiResponseProgramRequirement;

export const zRemoveProgramCourseData = z.object({
  body: z.never().optional(),
  path: z.object({
    programUuid: z.string().uuid(),
    courseUuid: z.string().uuid(),
  }),
  query: z.never().optional(),
});

export const zUpdateProgramCourseData = z.object({
  body: zProgramCourse,
  path: z.object({
    programUuid: z.string().uuid(),
    courseUuid: z.string().uuid(),
  }),
  query: z.never().optional(),
});

/**
 * OK
 */
export const zUpdateProgramCourseResponse = zApiResponseProgramCourse;

export const zDeleteOrganisationData = z.object({
  body: z.never().optional(),
  path: z.object({
    uuid: z
      .string()
      .uuid()
      .describe(
        'UUID of the organisation to delete. This will soft-delete the organisation and all user relationships.'
      ),
  }),
  query: z.never().optional(),
});

/**
 * Organisation deleted successfully
 */
export const zDeleteOrganisationResponse = zApiResponseVoid;

export const zGetOrganisationByUuidData = z.object({
  body: z.never().optional(),
  path: z.object({
    uuid: z
      .string()
      .uuid()
      .describe(
        'UUID of the organisation to retrieve. Must be an existing organisation identifier.'
      ),
  }),
  query: z.never().optional(),
});

/**
 * Organisation retrieved successfully
 */
export const zGetOrganisationByUuidResponse = zApiResponseOrganisation;

export const zUpdateOrganisationData = z.object({
  body: zOrganisation,
  path: z.object({
    uuid: z
      .string()
      .uuid()
      .describe('UUID of the organisation to update. Must be an existing organisation identifier.'),
  }),
  query: z.never().optional(),
});

/**
 * Organisation updated successfully
 */
export const zUpdateOrganisationResponse = zApiResponseOrganisation;

export const zDeleteTrainingBranch1Data = z.object({
  body: z.never().optional(),
  path: z.object({
    uuid: z
      .string()
      .uuid()
      .describe(
        'UUID of the organization that owns the training branch. Must be an existing organization.'
      ),
    branchUuid: z
      .string()
      .uuid()
      .describe(
        'UUID of the training branch to delete. This will soft-delete the branch and remove all user assignments.'
      ),
  }),
  query: z.never().optional(),
});

/**
 * Training branch deleted successfully
 */
export const zDeleteTrainingBranch1Response = zApiResponseVoid;

export const zGetTrainingBranchByUuid1Data = z.object({
  body: z.never().optional(),
  path: z.object({
    uuid: z
      .string()
      .uuid()
      .describe(
        'UUID of the organization that owns the training branch. Must be an existing organization.'
      ),
    branchUuid: z
      .string()
      .uuid()
      .describe(
        'UUID of the training branch to retrieve. Must be a branch within the specified organization.'
      ),
  }),
  query: z.never().optional(),
});

/**
 * Training branch retrieved successfully
 */
export const zGetTrainingBranchByUuid1Response = zApiResponseTrainingBranch;

export const zUpdateTrainingBranch1Data = z.object({
  body: zTrainingBranch,
  path: z.object({
    uuid: z
      .string()
      .uuid()
      .describe(
        'UUID of the organization that owns the training branch. Must be an existing organization.'
      ),
    branchUuid: z
      .string()
      .uuid()
      .describe(
        'UUID of the training branch to update. Must be a branch within the specified organization.'
      ),
  }),
  query: z.never().optional(),
});

/**
 * Training branch updated successfully
 */
export const zUpdateTrainingBranch1Response = zApiResponseTrainingBranch;

export const zDeleteInstructorData = z.object({
  body: z.never().optional(),
  path: z.object({
    uuid: z.string().uuid(),
  }),
  query: z.never().optional(),
});

/**
 * Instructor deleted successfully
 */
export const zDeleteInstructorResponse = z.void().describe('Instructor deleted successfully');

export const zGetInstructorByUuidData = z.object({
  body: z.never().optional(),
  path: z.object({
    uuid: z.string().uuid(),
  }),
  query: z.never().optional(),
});

/**
 * Instructor found
 */
export const zGetInstructorByUuidResponse = zInstructor;

export const zUpdateInstructorData = z.object({
  body: zInstructor,
  path: z.object({
    uuid: z.string().uuid(),
  }),
  query: z.never().optional(),
});

/**
 * Instructor updated successfully
 */
export const zUpdateInstructorResponse = zInstructor;

export const zDeleteInstructorSkillData = z.object({
  body: z.never().optional(),
  path: z.object({
    instructorUuid: z.string().uuid(),
    skillUuid: z.string().uuid(),
  }),
  query: z.never().optional(),
});

export const zUpdateInstructorSkillData = z.object({
  body: zInstructorSkill,
  path: z.object({
    instructorUuid: z.string().uuid(),
    skillUuid: z.string().uuid(),
  }),
  query: z.never().optional(),
});

/**
 * OK
 */
export const zUpdateInstructorSkillResponse = zApiResponseInstructorSkill;

export const zDeleteInstructorMembershipData = z.object({
  body: z.never().optional(),
  path: z.object({
    instructorUuid: z.string().uuid(),
    membershipUuid: z.string().uuid(),
  }),
  query: z.never().optional(),
});

export const zUpdateInstructorMembershipData = z.object({
  body: zInstructorProfessionalMembership,
  path: z.object({
    instructorUuid: z.string().uuid(),
    membershipUuid: z.string().uuid(),
  }),
  query: z.never().optional(),
});

/**
 * OK
 */
export const zUpdateInstructorMembershipResponse = zApiResponseInstructorProfessionalMembership;

export const zDeleteInstructorExperienceData = z.object({
  body: z.never().optional(),
  path: z.object({
    instructorUuid: z.string().uuid(),
    experienceUuid: z.string().uuid(),
  }),
  query: z.never().optional(),
});

export const zUpdateInstructorExperienceData = z.object({
  body: zInstructorExperience,
  path: z.object({
    instructorUuid: z.string().uuid(),
    experienceUuid: z.string().uuid(),
  }),
  query: z.never().optional(),
});

/**
 * OK
 */
export const zUpdateInstructorExperienceResponse = zApiResponseInstructorExperience;

export const zDeleteInstructorEducationData = z.object({
  body: z.never().optional(),
  path: z.object({
    instructorUuid: z.string().uuid(),
    educationUuid: z.string().uuid(),
  }),
  query: z.never().optional(),
});

export const zUpdateInstructorEducationData = z.object({
  body: zInstructorEducation,
  path: z.object({
    instructorUuid: z.string().uuid(),
    educationUuid: z.string().uuid(),
  }),
  query: z.never().optional(),
});

/**
 * OK
 */
export const zUpdateInstructorEducationResponse = zApiResponseInstructorEducation;

export const zDeleteInstructorDocumentData = z.object({
  body: z.never().optional(),
  path: z.object({
    instructorUuid: z.string().uuid(),
    documentUuid: z.string().uuid(),
  }),
  query: z.never().optional(),
});

export const zUpdateInstructorDocumentData = z.object({
  body: zInstructorDocument,
  path: z.object({
    instructorUuid: z.string().uuid(),
    documentUuid: z.string().uuid(),
  }),
  query: z.never().optional(),
});

/**
 * OK
 */
export const zUpdateInstructorDocumentResponse = zApiResponseInstructorDocument;

export const zDeleteAvailabilitySlotData = z.object({
  body: z.never().optional(),
  path: z.object({
    instructorUuid: z.string().uuid().describe('UUID of the instructor'),
    slotUuid: z.string().uuid().describe('UUID of the availability slot'),
  }),
  query: z.never().optional(),
});

/**
 * Availability slot deleted successfully
 */
export const zDeleteAvailabilitySlotResponse = zApiResponseVoid;

export const zGetAvailabilitySlotData = z.object({
  body: z.never().optional(),
  path: z.object({
    instructorUuid: z.string().uuid().describe('UUID of the instructor'),
    slotUuid: z.string().uuid().describe('UUID of the availability slot'),
  }),
  query: z.never().optional(),
});

/**
 * Availability slot retrieved successfully
 */
export const zGetAvailabilitySlotResponse = zApiResponseAvailabilitySlot;

export const zUpdateAvailabilitySlotData = z.object({
  body: zAvailabilitySlot,
  path: z.object({
    instructorUuid: z.string().uuid().describe('UUID of the instructor'),
    slotUuid: z.string().uuid().describe('UUID of the availability slot'),
  }),
  query: z.never().optional(),
});

/**
 * Availability slot updated successfully
 */
export const zUpdateAvailabilitySlotResponse = zApiResponseAvailabilitySlot;

export const zDeleteCourseData = z.object({
  body: z.never().optional(),
  path: z.object({
    uuid: z.string().uuid(),
  }),
  query: z.never().optional(),
});

/**
 * Course deleted successfully
 */
export const zDeleteCourseResponse = z.void().describe('Course deleted successfully');

export const zGetCourseByUuidData = z.object({
  body: z.never().optional(),
  path: z.object({
    uuid: z.string().uuid(),
  }),
  query: z.never().optional(),
});

/**
 * Course found
 */
export const zGetCourseByUuidResponse = zApiResponseCourse;

export const zUpdateCourseData = z.object({
  body: zCourse,
  path: z.object({
    uuid: z.string().uuid(),
  }),
  query: z.never().optional(),
});

/**
 * Course updated successfully
 */
export const zUpdateCourseResponse = zApiResponseCourse;

export const zDeleteCourseTrainingRequirementData = z.object({
  body: z.never().optional(),
  path: z.object({
    courseUuid: z.string().uuid(),
    requirementUuid: z.string().uuid(),
  }),
  query: z.never().optional(),
});

export const zUpdateCourseTrainingRequirementData = z.object({
  body: zCourseTrainingRequirement,
  path: z.object({
    courseUuid: z.string().uuid(),
    requirementUuid: z.string().uuid(),
  }),
  query: z.never().optional(),
});

/**
 * OK
 */
export const zUpdateCourseTrainingRequirementResponse = zApiResponseCourseTrainingRequirement;

export const zSetPrimaryRubricData = z.object({
  body: z.never().optional(),
  path: z.object({
    courseUuid: z.string().uuid().describe('UUID of the course'),
    rubricUuid: z.string().uuid().describe('UUID of the rubric to set as primary'),
  }),
  query: z.object({
    instructorUuid: z.string().uuid().describe('UUID of the instructor making the change'),
  }),
});

/**
 * OK
 */
export const zSetPrimaryRubricResponse = zApiResponseCourseRubricAssociation;

export const zUpdateAssociationData = z.object({
  body: zCourseRubricAssociation,
  path: z.object({
    courseUuid: z.string().uuid().describe('UUID of the course'),
    associationUuid: z.string().uuid().describe('UUID of the association to update'),
  }),
  query: z.never().optional(),
});

/**
 * OK
 */
export const zUpdateAssociationResponse = zApiResponseCourseRubricAssociation;

export const zDeleteCourseRequirementData = z.object({
  body: z.never().optional(),
  path: z.object({
    courseUuid: z.string().uuid(),
    requirementUuid: z.string().uuid(),
  }),
  query: z.never().optional(),
});

export const zUpdateCourseRequirementData = z.object({
  body: zCourseRequirement,
  path: z.object({
    courseUuid: z.string().uuid(),
    requirementUuid: z.string().uuid(),
  }),
  query: z.never().optional(),
});

/**
 * OK
 */
export const zUpdateCourseRequirementResponse = zApiResponseCourseRequirement;

export const zDeleteCourseLessonData = z.object({
  body: z.never().optional(),
  path: z.object({
    courseUuid: z.string().uuid(),
    lessonUuid: z.string().uuid(),
  }),
  query: z.never().optional(),
});

export const zGetCourseLessonData = z.object({
  body: z.never().optional(),
  path: z.object({
    courseUuid: z.string().uuid().describe('UUID of the course containing the lesson'),
    lessonUuid: z.string().uuid().describe('UUID of the lesson to retrieve'),
  }),
  query: z.never().optional(),
});

/**
 * Lesson retrieved successfully
 */
export const zGetCourseLessonResponse = zLesson;

export const zUpdateCourseLessonData = z.object({
  body: zLesson,
  path: z.object({
    courseUuid: z.string().uuid(),
    lessonUuid: z.string().uuid(),
  }),
  query: z.never().optional(),
});

/**
 * OK
 */
export const zUpdateCourseLessonResponse = zApiResponseLesson;

export const zDeleteLessonContentData = z.object({
  body: z.never().optional(),
  path: z.object({
    courseUuid: z.string().uuid(),
    lessonUuid: z.string().uuid(),
    contentUuid: z.string().uuid(),
  }),
  query: z.never().optional(),
});

export const zUpdateLessonContentData = z.object({
  body: zLessonContent,
  path: z.object({
    courseUuid: z.string().uuid(),
    lessonUuid: z.string().uuid(),
    contentUuid: z.string().uuid(),
  }),
  query: z.never().optional(),
});

/**
 * OK
 */
export const zUpdateLessonContentResponse = zApiResponseLessonContent;

export const zDeleteCourseAssessmentData = z.object({
  body: z.never().optional(),
  path: z.object({
    courseUuid: z.string().uuid(),
    assessmentUuid: z.string().uuid(),
  }),
  query: z.never().optional(),
});

export const zUpdateCourseAssessmentData = z.object({
  body: zCourseAssessment,
  path: z.object({
    courseUuid: z.string().uuid(),
    assessmentUuid: z.string().uuid(),
  }),
  query: z.never().optional(),
});

/**
 * OK
 */
export const zUpdateCourseAssessmentResponse = zApiResponseCourseAssessment;

export const zDeleteCourseCreatorData = z.object({
  body: z.never().optional(),
  path: z.object({
    uuid: z.string().uuid(),
  }),
  query: z.never().optional(),
});

/**
 * Course creator deleted successfully
 */
export const zDeleteCourseCreatorResponse = z
  .void()
  .describe('Course creator deleted successfully');

export const zGetCourseCreatorByUuidData = z.object({
  body: z.never().optional(),
  path: z.object({
    uuid: z.string().uuid(),
  }),
  query: z.never().optional(),
});

/**
 * Course creator found
 */
export const zGetCourseCreatorByUuidResponse = zCourseCreator;

export const zUpdateCourseCreatorData = z.object({
  body: zCourseCreator,
  path: z.object({
    uuid: z.string().uuid(),
  }),
  query: z.never().optional(),
});

/**
 * Course creator updated successfully
 */
export const zUpdateCourseCreatorResponse = zCourseCreator;

export const zDeleteGradingLevelData = z.object({
  body: z.never().optional(),
  path: z.object({
    uuid: z.string().uuid(),
  }),
  query: z.never().optional(),
});

export const zUpdateGradingLevelData = z.object({
  body: zGradingLevel,
  path: z.object({
    uuid: z.string().uuid(),
  }),
  query: z.never().optional(),
});

/**
 * OK
 */
export const zUpdateGradingLevelResponse = zApiResponseGradingLevel;

export const zDeleteDifficultyLevelData = z.object({
  body: z.never().optional(),
  path: z.object({
    uuid: z.string().uuid(),
  }),
  query: z.never().optional(),
});

/**
 * OK
 */
export const zDeleteDifficultyLevelResponse = zApiResponseString;

export const zUpdateDifficultyLevelData = z.object({
  body: zDifficultyLevel,
  path: z.object({
    uuid: z.string().uuid(),
  }),
  query: z.never().optional(),
});

/**
 * OK
 */
export const zUpdateDifficultyLevelResponse = zApiResponseDifficultyLevel;

export const zDeleteContentTypeData = z.object({
  body: z.never().optional(),
  path: z.object({
    uuid: z.string().uuid(),
  }),
  query: z.never().optional(),
});

/**
 * OK
 */
export const zDeleteContentTypeResponse = zApiResponseString;

export const zUpdateContentTypeData = z.object({
  body: zContentType,
  path: z.object({
    uuid: z.string().uuid(),
  }),
  query: z.never().optional(),
});

/**
 * OK
 */
export const zUpdateContentTypeResponse = zApiResponseContentType;

export const zDeleteCategoryData = z.object({
  body: z.never().optional(),
  path: z.object({
    uuid: z.string().uuid(),
  }),
  query: z.never().optional(),
});

/**
 * OK
 */
export const zDeleteCategoryResponse = zApiResponseString;

export const zGetCategoryByUuidData = z.object({
  body: z.never().optional(),
  path: z.object({
    uuid: z.string().uuid(),
  }),
  query: z.never().optional(),
});

/**
 * OK
 */
export const zGetCategoryByUuidResponse = zApiResponseCategory;

export const zUpdateCategoryData = z.object({
  body: zCategory,
  path: z.object({
    uuid: z.string().uuid(),
  }),
  query: z.never().optional(),
});

/**
 * OK
 */
export const zUpdateCategoryResponse = zApiResponseCategory;

export const zUpdateCatalogItemData = z.object({
  body: zCommerceCatalogItemUpsertRequest,
  path: z.object({
    catalogUuid: z.string().uuid(),
  }),
  query: z.never().optional(),
});

/**
 * OK
 */
export const zUpdateCatalogItemResponse = zApiResponseCommerceCatalogItem;

export const zDeactivateClassDefinitionData = z.object({
  body: z.never().optional(),
  path: z.object({
    uuid: z.string().uuid().describe('UUID of the class definition to deactivate'),
  }),
  query: z.never().optional(),
});

/**
 * Class definition deactivated successfully
 */
export const zDeactivateClassDefinitionResponse = zApiResponseVoid;

export const zGetClassDefinitionData = z.object({
  body: z.never().optional(),
  path: z.object({
    uuid: z.string().uuid().describe('UUID of the class definition to retrieve'),
  }),
  query: z.never().optional(),
});

/**
 * Class definition retrieved successfully
 */
export const zGetClassDefinitionResponse = zApiResponseClassDefinition;

export const zUpdateClassDefinitionData = z.object({
  body: zClassDefinition,
  path: z.object({
    uuid: z.string().uuid().describe('UUID of the class definition to update'),
  }),
  query: z.never().optional(),
});

/**
 * Class definition updated successfully
 */
export const zUpdateClassDefinitionResponse = zApiResponseClassDefinition;

export const zCancelRecurringClassScheduleData = z.object({
  body: z.never().optional(),
  path: z.object({
    uuid: z.string().uuid().describe('UUID of the class definition to cancel schedule for'),
  }),
  query: z.object({
    reason: z.string().describe('Reason for cancellation'),
  }),
});

/**
 * Recurring schedule cancelled successfully
 */
export const zCancelRecurringClassScheduleResponse = zApiResponseVoid;

export const zScheduleRecurringClassFromDefinitionData = z.object({
  body: z.never().optional(),
  path: z.object({
    uuid: z.string().uuid().describe('UUID of the class definition to schedule'),
  }),
  query: z.object({
    startDate: z.string().date().describe('Date to start scheduling from (YYYY-MM-DD)'),
    endDate: z
      .string()
      .date()
      .describe('Date to stop scheduling (optional, uses pattern end date if not provided)')
      .optional(),
  }),
});

/**
 * Recurring schedule created successfully
 */
export const zScheduleRecurringClassFromDefinitionResponse = zApiResponseListScheduledInstance;

export const zUpdateRecurringClassScheduleData = z.object({
  body: z.never().optional(),
  path: z.object({
    uuid: z.string().uuid().describe('UUID of the class definition to update schedule for'),
  }),
  query: z.never().optional(),
});

/**
 * Recurring schedule updated successfully
 */
export const zUpdateRecurringClassScheduleResponse = zApiResponseListScheduledInstance;

export const zDeleteClassRecurrencePatternData = z.object({
  body: z.never().optional(),
  path: z.object({
    uuid: z.string().uuid().describe('UUID of the recurrence pattern to delete'),
  }),
  query: z.never().optional(),
});

/**
 * Recurrence pattern deleted successfully
 */
export const zDeleteClassRecurrencePatternResponse = zApiResponseVoid;

export const zGetClassRecurrencePatternData = z.object({
  body: z.never().optional(),
  path: z.object({
    uuid: z.string().uuid().describe('UUID of the recurrence pattern to retrieve'),
  }),
  query: z.never().optional(),
});

/**
 * Recurrence pattern retrieved successfully
 */
export const zGetClassRecurrencePatternResponse = zApiResponseRecurrencePattern;

export const zUpdateClassRecurrencePatternData = z.object({
  body: zRecurrencePattern,
  path: z.object({
    uuid: z.string().uuid().describe('UUID of the recurrence pattern to update'),
  }),
  query: z.never().optional(),
});

/**
 * Recurrence pattern updated successfully
 */
export const zUpdateClassRecurrencePatternResponse = zApiResponseRecurrencePattern;

export const zDeleteCertificateData = z.object({
  body: z.never().optional(),
  path: z.object({
    uuid: z.string().uuid(),
  }),
  query: z.never().optional(),
});

/**
 * Certificate deleted successfully
 */
export const zDeleteCertificateResponse = z.void().describe('Certificate deleted successfully');

export const zGetCertificateByUuidData = z.object({
  body: z.never().optional(),
  path: z.object({
    uuid: z.string().uuid(),
  }),
  query: z.never().optional(),
});

/**
 * Certificate found
 */
export const zGetCertificateByUuidResponse = zApiResponseCertificate;

export const zUpdateCertificateData = z.object({
  body: zCertificate,
  path: z.object({
    uuid: z.string().uuid(),
  }),
  query: z.never().optional(),
});

/**
 * Certificate updated successfully
 */
export const zUpdateCertificateResponse = zApiResponseCertificate;

export const zDeleteCertificateTemplateData = z.object({
  body: z.never().optional(),
  path: z.object({
    templateUuid: z.string().uuid(),
  }),
  query: z.never().optional(),
});

export const zUpdateCertificateTemplateData = z.object({
  body: zCertificateTemplate,
  path: z.object({
    templateUuid: z.string().uuid(),
  }),
  query: z.never().optional(),
});

/**
 * OK
 */
export const zUpdateCertificateTemplateResponse = zApiResponseCertificateTemplate;

export const zDeleteAssignmentData = z.object({
  body: z.never().optional(),
  path: z.object({
    uuid: z.string().uuid(),
  }),
  query: z.never().optional(),
});

/**
 * Assignment deleted successfully
 */
export const zDeleteAssignmentResponse = z.void().describe('Assignment deleted successfully');

export const zGetAssignmentByUuidData = z.object({
  body: z.never().optional(),
  path: z.object({
    uuid: z.string().uuid(),
  }),
  query: z.never().optional(),
});

/**
 * Assignment found
 */
export const zGetAssignmentByUuidResponse = zApiResponseAssignment;

export const zUpdateAssignmentData = z.object({
  body: zAssignment,
  path: z.object({
    uuid: z.string().uuid(),
  }),
  query: z.never().optional(),
});

/**
 * Assignment updated successfully
 */
export const zUpdateAssignmentResponse = zApiResponseAssignment;

export const zDeclineInvitationData = z.object({
  body: z.never().optional(),
  path: z.object({
    uuid: z
      .string()
      .uuid()
      .describe(
        "UUID of the user who is declining the invitation. The user's email must match the invitation recipient email for security."
      ),
  }),
  query: z.object({
    token: z
      .string()
      .describe(
        'Unique invitation token from the invitation email URL. This is the 64-character token that identifies the specific invitation.'
      ),
  }),
});

/**
 * Invitation declined successfully, notifications sent to inviter
 */
export const zDeclineInvitationResponse = zApiResponseVoid;

export const zAcceptInvitationData = z.object({
  body: z.never().optional(),
  path: z.object({
    uuid: z
      .string()
      .uuid()
      .describe(
        "UUID of the user who is accepting the invitation. The user's email must match the invitation recipient email for security."
      ),
  }),
  query: z.object({
    token: z
      .string()
      .describe(
        'Unique invitation token from the invitation email URL. This is the 64-character token that identifies the specific invitation.'
      ),
  }),
});

/**
 * Invitation accepted successfully, user added to organization/branch with specified role
 */
export const zAcceptInvitationResponse = zApiResponseUser;

export const zUploadProfileImageData = z.object({
  body: z
    .object({
      profileImage: z.string().describe('Profile image file to upload'),
    })
    .optional(),
  path: z.object({
    userUuid: z.string().uuid().describe('UUID of the user'),
  }),
  query: z.never().optional(),
});

/**
 * Profile Image Uploaded successfully
 */
export const zUploadProfileImageResponse = zUser;

export const zGetAllTrainingBranchesData = z.object({
  body: z.never().optional(),
  path: z.never().optional(),
  query: z.object({
    pageable: zPageable,
  }),
});

/**
 * Training branches retrieved successfully
 */
export const zGetAllTrainingBranchesResponse = zApiResponsePagedDtoTrainingBranch;

export const zCreateTrainingBranchData = z.object({
  body: zTrainingBranch,
  path: z.never().optional(),
  query: z.never().optional(),
});

/**
 * Training branch created successfully
 */
export const zCreateTrainingBranchResponse = zApiResponseTrainingBranch;

export const zCheckStudentConflictData = z.object({
  body: zScheduleRequest,
  path: z.object({
    studentUuid: z.string().uuid().describe('UUID of the student'),
  }),
  query: z.never().optional(),
});

/**
 * Conflict check completed
 */
export const zCheckStudentConflictResponse = zApiResponseBoolean;

export const zScheduleClassData = z.object({
  body: zScheduleRequest,
  path: z.never().optional(),
  query: z.never().optional(),
});

/**
 * Class scheduled successfully
 */
export const zScheduleClassResponse = zApiResponseScheduledInstance;

export const zCheckInstructorConflictData = z.object({
  body: zScheduleRequest,
  path: z.object({
    instructorUuid: z.string().uuid().describe('UUID of the instructor'),
  }),
  query: z.never().optional(),
});

/**
 * Conflict check completed
 */
export const zCheckInstructorConflictResponse = zApiResponseBoolean;

export const zGetAllStudentsData = z.object({
  body: z.never().optional(),
  path: z.never().optional(),
  query: z.object({
    pageable: zPageable,
  }),
});

/**
 * OK
 */
export const zGetAllStudentsResponse = zApiResponsePagedDtoStudent;

export const zCreateStudentData = z.object({
  body: zStudent,
  path: z.never().optional(),
  query: z.never().optional(),
});

/**
 * Student created successfully
 */
export const zCreateStudentResponse = zStudent;

export const zGetAllAssessmentRubricsData = z.object({
  body: z.never().optional(),
  path: z.never().optional(),
  query: z.object({
    pageable: zPageable,
  }),
});

/**
 * OK
 */
export const zGetAllAssessmentRubricsResponse = zApiResponsePagedDtoAssessmentRubric;

export const zCreateAssessmentRubricData = z.object({
  body: zAssessmentRubric,
  path: z.never().optional(),
  query: z.never().optional(),
});

/**
 * OK
 */
export const zCreateAssessmentRubricResponse = zApiResponseAssessmentRubric;

export const zGetScoringLevelsByRubricData = z.object({
  body: z.never().optional(),
  path: z.object({
    rubricUuid: z.string().uuid().describe('UUID of the rubric'),
  }),
  query: z.object({
    pageable: zPageable,
  }),
});

/**
 * OK
 */
export const zGetScoringLevelsByRubricResponse = zApiResponsePagedDtoRubricScoringLevel;

export const zCreateRubricScoringLevelData = z.object({
  body: zRubricScoringLevel,
  path: z.object({
    rubricUuid: z.string().uuid().describe('UUID of the rubric'),
  }),
  query: z.never().optional(),
});

/**
 * OK
 */
export const zCreateRubricScoringLevelResponse = zApiResponseRubricScoringLevel;

export const zCreateRubricScoringLevelsBatchData = z.object({
  body: z.array(zRubricScoringLevel),
  path: z.object({
    rubricUuid: z.string().uuid().describe('UUID of the rubric'),
  }),
  query: z.never().optional(),
});

/**
 * OK
 */
export const zCreateRubricScoringLevelsBatchResponse = zApiResponseListRubricScoringLevel;

export const zRecalculateScoresData = z.object({
  body: z.never().optional(),
  path: z.object({
    rubricUuid: z.string().uuid().describe('UUID of the rubric'),
  }),
  query: z.never().optional(),
});

/**
 * OK
 */
export const zRecalculateScoresResponse = zApiResponseRubricMatrix;

export const zGetRubricCriteriaData = z.object({
  body: z.never().optional(),
  path: z.object({
    rubricUuid: z.string().uuid(),
  }),
  query: z.object({
    pageable: zPageable,
  }),
});

/**
 * OK
 */
export const zGetRubricCriteriaResponse = zApiResponsePagedDtoRubricCriteria;

export const zAddRubricCriterionData = z.object({
  body: zRubricCriteria,
  path: z.object({
    rubricUuid: z.string().uuid(),
  }),
  query: z.never().optional(),
});

/**
 * OK
 */
export const zAddRubricCriterionResponse = zApiResponseObject;

export const zGetRubricScoringData = z.object({
  body: z.never().optional(),
  path: z.object({
    rubricUuid: z.string().uuid(),
    criteriaUuid: z.string().uuid(),
  }),
  query: z.object({
    pageable: zPageable,
  }),
});

/**
 * OK
 */
export const zGetRubricScoringResponse = zApiResponsePagedDtoRubricScoring;

export const zAddRubricScoringData = z.object({
  body: zRubricScoring,
  path: z.object({
    rubricUuid: z.string().uuid(),
    criteriaUuid: z.string().uuid(),
  }),
  query: z.never().optional(),
});

/**
 * OK
 */
export const zAddRubricScoringResponse = zApiResponseRubricScoring;

export const zGetAllQuizzesData = z.object({
  body: z.never().optional(),
  path: z.never().optional(),
  query: z.object({
    pageable: zPageable,
  }),
});

/**
 * OK
 */
export const zGetAllQuizzesResponse = zApiResponsePagedDtoQuiz;

export const zCreateQuizData = z.object({
  body: zQuiz,
  path: z.never().optional(),
  query: z.never().optional(),
});

/**
 * Quiz created successfully
 */
export const zCreateQuizResponse = zQuiz;

export const zGetQuizQuestionsData = z.object({
  body: z.never().optional(),
  path: z.object({
    quizUuid: z.string().uuid(),
  }),
  query: z.never().optional(),
});

/**
 * OK
 */
export const zGetQuizQuestionsResponse = zApiResponseListQuizQuestion;

export const zAddQuizQuestionData = z.object({
  body: zQuizQuestion,
  path: z.object({
    quizUuid: z.string().uuid(),
  }),
  query: z.never().optional(),
});

/**
 * OK
 */
export const zAddQuizQuestionResponse = zApiResponseQuizQuestion;

export const zGetQuestionOptionsData = z.object({
  body: z.never().optional(),
  path: z.object({
    quizUuid: z.string().uuid(),
    questionUuid: z.string().uuid(),
  }),
  query: z.object({
    pageable: zPageable,
  }),
});

/**
 * OK
 */
export const zGetQuestionOptionsResponse = zApiResponsePagedDtoQuizQuestionOption;

export const zAddQuestionOptionData = z.object({
  body: zQuizQuestionOption,
  path: z.object({
    quizUuid: z.string().uuid(),
    questionUuid: z.string().uuid(),
  }),
  query: z.never().optional(),
});

/**
 * OK
 */
export const zAddQuestionOptionResponse = zApiResponseQuizQuestionOption;

export const zReorderQuizQuestionsData = z.object({
  body: z.array(z.string().uuid()),
  path: z.object({
    quizUuid: z.string().uuid(),
  }),
  query: z.never().optional(),
});

/**
 * OK
 */
export const zReorderQuizQuestionsResponse = zApiResponseString;

export const zGetAllTrainingProgramsData = z.object({
  body: z.never().optional(),
  path: z.never().optional(),
  query: z.object({
    pageable: zPageable,
  }),
});

/**
 * OK
 */
export const zGetAllTrainingProgramsResponse = zApiResponsePagedDtoTrainingProgram;

export const zCreateTrainingProgramData = z.object({
  body: zTrainingProgram,
  path: z.never().optional(),
  query: z.never().optional(),
});

/**
 * Program created successfully
 */
export const zCreateTrainingProgramResponse = zTrainingProgram;

export const zPublishProgramData = z.object({
  body: z.never().optional(),
  path: z.object({
    uuid: z.string().uuid(),
  }),
  query: z.never().optional(),
});

/**
 * Program published successfully
 */
export const zPublishProgramResponse = zApiResponseTrainingProgram;

export const zGetProgramRequirementsData = z.object({
  body: z.never().optional(),
  path: z.object({
    programUuid: z.string().uuid(),
  }),
  query: z.object({
    pageable: zPageable,
  }),
});

/**
 * OK
 */
export const zGetProgramRequirementsResponse = zApiResponsePagedDtoProgramRequirement;

export const zAddProgramRequirementData = z.object({
  body: zProgramRequirement,
  path: z.object({
    programUuid: z.string().uuid(),
  }),
  query: z.never().optional(),
});

/**
 * OK
 */
export const zAddProgramRequirementResponse = zApiResponseProgramRequirement;

export const zGetProgramCoursesData = z.object({
  body: z.never().optional(),
  path: z.object({
    programUuid: z.string().uuid(),
  }),
  query: z.never().optional(),
});

/**
 * OK
 */
export const zGetProgramCoursesResponse = zApiResponseListCourse;

export const zAddProgramCourseData = z.object({
  body: zProgramCourse,
  path: z.object({
    programUuid: z.string().uuid(),
  }),
  query: z.never().optional(),
});

/**
 * OK
 */
export const zAddProgramCourseResponse = zApiResponseProgramCourse;

export const zGetAllOrganisationsData = z.object({
  body: z.never().optional(),
  path: z.never().optional(),
  query: z.object({
    pageable: zPageable,
  }),
});

/**
 * Organisations retrieved successfully
 */
export const zGetAllOrganisationsResponse = zApiResponsePagedDtoOrganisation;

export const zCreateOrganisationData = z.object({
  body: zOrganisation,
  path: z.never().optional(),
  query: z.never().optional(),
});

/**
 * Organisation created successfully
 */
export const zCreateOrganisationResponse = zApiResponseOrganisation;

export const zGetTrainingBranchesByOrganisationData = z.object({
  body: z.never().optional(),
  path: z.object({
    uuid: z
      .string()
      .uuid()
      .describe(
        'UUID of the organisation to get training branches for. Must be an existing organisation identifier.'
      ),
  }),
  query: z.object({
    pageable: zPageable,
  }),
});

/**
 * Training branches retrieved successfully
 */
export const zGetTrainingBranchesByOrganisationResponse = zApiResponsePagedDtoTrainingBranch;

export const zCreateTrainingBranch1Data = z.object({
  body: zTrainingBranch,
  path: z.object({
    uuid: z
      .string()
      .uuid()
      .describe(
        'UUID of the organization to create the training branch in. Must be an existing organization.'
      ),
  }),
  query: z.never().optional(),
});

/**
 * Training branch created successfully
 */
export const zCreateTrainingBranch1Response = zApiResponseTrainingBranch;

export const zRemoveUserFromBranchData = z.object({
  body: z.never().optional(),
  path: z.object({
    uuid: z
      .string()
      .uuid()
      .describe(
        'UUID of the organization that owns the training branch. Must be an existing organization.'
      ),
    branchUuid: z
      .string()
      .uuid()
      .describe(
        'UUID of the training branch to remove the user from. Must be a branch within the specified organization.'
      ),
    userUuid: z
      .string()
      .uuid()
      .describe(
        'UUID of the user to remove from the training branch. Must be currently assigned to the branch.'
      ),
  }),
  query: z.never().optional(),
});

/**
 * User removed from branch successfully
 */
export const zRemoveUserFromBranchResponse = zApiResponseVoid;

export const zAssignUserToBranchData = z.object({
  body: z.never().optional(),
  path: z.object({
    uuid: z
      .string()
      .uuid()
      .describe(
        'UUID of the organization that owns the training branch. Must be an existing organization.'
      ),
    branchUuid: z
      .string()
      .uuid()
      .describe(
        'UUID of the training branch to assign the user to. Must be a branch within the specified organization.'
      ),
    userUuid: z
      .string()
      .uuid()
      .describe('UUID of the user to assign to the training branch. Must be an existing user.'),
  }),
  query: z.object({
    domain_name: z
      .string()
      .describe(
        "Role/domain name for the user in this branch. Valid values: 'student', 'instructor', 'admin', 'organisation_user'"
      ),
  }),
});

/**
 * User assigned to branch successfully
 */
export const zAssignUserToBranchResponse = zApiResponseVoid;

export const zGetBranchInvitationsData = z.object({
  body: z.never().optional(),
  path: z.object({
    uuid: z
      .string()
      .uuid()
      .describe(
        'UUID of the organization that owns the training branch. Must be an existing organization.'
      ),
    branchUuid: z
      .string()
      .uuid()
      .describe(
        'UUID of the training branch to retrieve invitations for. Must be a branch within the specified organization.'
      ),
  }),
  query: z.never().optional(),
});

/**
 * Branch invitations retrieved successfully (may be empty list)
 */
export const zGetBranchInvitationsResponse = zApiResponseListInvitation;

export const zCreateBranchInvitationData = z.object({
  body: zInvitationRequest,
  path: z.object({
    uuid: z
      .string()
      .uuid()
      .describe(
        'UUID of the organization that owns the training branch. Must be an existing organization.'
      ),
    branchUuid: z
      .string()
      .uuid()
      .describe(
        'UUID of the training branch the user is being invited to join. Must be a branch within the specified organization.'
      ),
  }),
  query: z.never().optional(),
});

/**
 * Branch invitation created and email sent successfully
 */
export const zCreateBranchInvitationResponse = zApiResponseInvitation;

export const zGetOrganizationInvitationsData = z.object({
  body: z.never().optional(),
  path: z.object({
    uuid: z
      .string()
      .uuid()
      .describe(
        'UUID of the organization to retrieve invitations for. Must be an existing organization.'
      ),
  }),
  query: z.never().optional(),
});

/**
 * Organization invitations retrieved successfully (may be empty list)
 */
export const zGetOrganizationInvitationsResponse = zApiResponseListInvitation;

export const zCreateOrganizationInvitationData = z.object({
  body: zInvitationRequest,
  path: z.object({
    uuid: z.string().uuid().describe('UUID of the organization the user is being invited to join.'),
  }),
  query: z.never().optional(),
});

/**
 * Organization-level invitation created and sent successfully
 */
export const zCreateOrganizationInvitationResponse = zApiResponseInvitation;

export const zResendInvitationData = z.object({
  body: z.never().optional(),
  path: z.object({
    uuid: z
      .string()
      .uuid()
      .describe(
        'UUID of the organization that owns the invitation. Must be an existing organization.'
      ),
    invitationUuid: z
      .string()
      .uuid()
      .describe(
        "UUID of the invitation to resend. Must be a pending invitation that hasn't been accepted, declined, or cancelled."
      ),
  }),
  query: z.object({
    resender_uuid: z
      .string()
      .uuid()
      .describe(
        'UUID of the user requesting to resend the invitation. Must be either the original inviter or an administrator of the organization.'
      ),
  }),
});

/**
 * Invitation email resent successfully with updated expiry date
 */
export const zResendInvitationResponse = zApiResponseVoid;

export const zProcessPendingInvitationsData = z.object({
  body: z.never().optional(),
  path: z.never().optional(),
  query: z.never().optional(),
});

/**
 * Pending invitations processed successfully (may be empty list)
 */
export const zProcessPendingInvitationsResponse = zApiResponseListInvitation;

export const zSendExpiryRemindersData = z.object({
  body: z.never().optional(),
  path: z.never().optional(),
  query: z
    .object({
      hoursBeforeExpiry: z
        .number()
        .int()
        .describe('Number of hours before expiry to send reminder. Default is 24 hours.')
        .optional()
        .default(24),
    })
    .optional(),
});

/**
 * Expiry reminders sent successfully
 */
export const zSendExpiryRemindersResponse = zApiResponseInteger;

export const zMarkExpiredInvitationsData = z.object({
  body: z.never().optional(),
  path: z.never().optional(),
  query: z.never().optional(),
});

/**
 * Expired invitations marked successfully
 */
export const zMarkExpiredInvitationsResponse = zApiResponseInteger;

export const zDeclineInvitation1Data = z.object({
  body: z.never().optional(),
  path: z.never().optional(),
  query: z.object({
    token: z
      .string()
      .describe('Invitation token from email link. Must match an active, non-expired invitation.'),
  }),
});

/**
 * Invitation declined successfully
 */
export const zDeclineInvitation1Response = zApiResponseVoid;

export const zAcceptInvitation1Data = z.object({
  body: z.never().optional(),
  path: z.never().optional(),
  query: z.object({
    token: z
      .string()
      .describe('Invitation token from email link. Must match an active, non-expired invitation.'),
  }),
});

/**
 * Invitation accepted successfully, user added to organization
 */
export const zAcceptInvitation1Response = zApiResponseUser;

export const zGetAllInstructorsData = z.object({
  body: z.never().optional(),
  path: z.never().optional(),
  query: z.object({
    pageable: zPageable,
  }),
});

/**
 * OK
 */
export const zGetAllInstructorsResponse = zApiResponsePagedDtoInstructor;

export const zCreateInstructorData = z.object({
  body: zInstructor,
  path: z.never().optional(),
  query: z.never().optional(),
});

/**
 * Instructor created successfully
 */
export const zCreateInstructorResponse = zInstructor;

export const zGetInstructorSkillsData = z.object({
  body: z.never().optional(),
  path: z.object({
    instructorUuid: z.string().uuid(),
  }),
  query: z.object({
    pageable: zPageable,
  }),
});

/**
 * OK
 */
export const zGetInstructorSkillsResponse = zApiResponsePagedDtoInstructorSkill;

export const zAddInstructorSkillData = z.object({
  body: zInstructorSkill,
  path: z.object({
    instructorUuid: z.string().uuid(),
  }),
  query: z.never().optional(),
});

/**
 * OK
 */
export const zAddInstructorSkillResponse = zApiResponseInstructorSkill;

export const zGetInstructorMembershipsData = z.object({
  body: z.never().optional(),
  path: z.object({
    instructorUuid: z.string().uuid(),
  }),
  query: z.object({
    pageable: zPageable,
  }),
});

/**
 * OK
 */
export const zGetInstructorMembershipsResponse =
  zApiResponsePagedDtoInstructorProfessionalMembership;

export const zAddInstructorMembershipData = z.object({
  body: zInstructorProfessionalMembership,
  path: z.object({
    instructorUuid: z.string().uuid(),
  }),
  query: z.never().optional(),
});

/**
 * OK
 */
export const zAddInstructorMembershipResponse = zApiResponseInstructorProfessionalMembership;

export const zGetInstructorExperienceData = z.object({
  body: z.never().optional(),
  path: z.object({
    instructorUuid: z.string().uuid(),
  }),
  query: z.object({
    pageable: zPageable,
  }),
});

/**
 * OK
 */
export const zGetInstructorExperienceResponse = zApiResponsePagedDtoInstructorExperience;

export const zAddInstructorExperienceData = z.object({
  body: zInstructorExperience,
  path: z.object({
    instructorUuid: z.string().uuid(),
  }),
  query: z.never().optional(),
});

/**
 * OK
 */
export const zAddInstructorExperienceResponse = zApiResponseInstructorExperience;

export const zGetInstructorEducationData = z.object({
  body: z.never().optional(),
  path: z.object({
    instructorUuid: z.string().uuid(),
  }),
  query: z.never().optional(),
});

/**
 * OK
 */
export const zGetInstructorEducationResponse = zApiResponseListInstructorEducation;

export const zAddInstructorEducationData = z.object({
  body: zInstructorEducation,
  path: z.object({
    instructorUuid: z.string().uuid(),
  }),
  query: z.never().optional(),
});

/**
 * OK
 */
export const zAddInstructorEducationResponse = zApiResponseInstructorEducation;

export const zGetInstructorDocumentsData = z.object({
  body: z.never().optional(),
  path: z.object({
    instructorUuid: z.string().uuid(),
  }),
  query: z.never().optional(),
});

/**
 * OK
 */
export const zGetInstructorDocumentsResponse = zApiResponseListInstructorDocument;

export const zAddInstructorDocumentData = z.object({
  body: zInstructorDocument,
  path: z.object({
    instructorUuid: z.string().uuid(),
  }),
  query: z.never().optional(),
});

/**
 * OK
 */
export const zAddInstructorDocumentResponse = zApiResponseInstructorDocument;

export const zVerifyDocumentData = z.object({
  body: z.never().optional(),
  path: z.object({
    instructorUuid: z.string().uuid(),
    documentUuid: z.string().uuid(),
  }),
  query: z.object({
    verifiedBy: z.string(),
    verificationNotes: z.string().optional(),
  }),
});

/**
 * OK
 */
export const zVerifyDocumentResponse = zApiResponseInstructorDocument;

export const zCreateAvailabilitySlotData = z.object({
  body: zAvailabilitySlot,
  path: z.object({
    instructorUuid: z.string().uuid().describe('UUID of the instructor'),
  }),
  query: z.never().optional(),
});

/**
 * Availability slot created successfully
 */
export const zCreateAvailabilitySlotResponse = zApiResponseAvailabilitySlot;

export const zSetAvailabilityPatternsData = z.object({
  body: z.record(z.unknown()),
  path: z.object({
    instructorUuid: z.string().uuid().describe('UUID of the instructor'),
  }),
  query: z.object({
    pattern_type: z.string().describe('Pattern type: weekly, daily, monthly, or custom'),
  }),
});

/**
 * Availability patterns set successfully
 */
export const zSetAvailabilityPatternsResponse = zApiResponseVoid;

export const zBlockTimeData = z.object({
  body: z.never().optional(),
  path: z.object({
    instructorUuid: z.string().uuid().describe('UUID of the instructor'),
  }),
  query: z.object({
    start: z
      .string()
      .datetime()
      .describe('Start date and time to block (ISO format: YYYY-MM-DDTHH:mm:ss)'),
    end: z
      .string()
      .datetime()
      .describe('End date and time to block (ISO format: YYYY-MM-DDTHH:mm:ss)'),
    color_code: z
      .string()
      .describe('Optional hex color code for UI visualization (e.g., #FF6B6B)')
      .optional(),
  }),
});

/**
 * Time blocked successfully
 */
export const zBlockTimeResponse = zApiResponseVoid;

export const zEnrollStudentData = z.object({
  body: zEnrollmentRequest,
  path: z.never().optional(),
  query: z.never().optional(),
});

/**
 * Student enrolled successfully
 */
export const zEnrollStudentResponse = zApiResponseEnrollment;

export const zGetAllCoursesData = z.object({
  body: z.never().optional(),
  path: z.never().optional(),
  query: z.object({
    pageable: zPageable,
  }),
});

/**
 * OK
 */
export const zGetAllCoursesResponse = zApiResponsePagedDtoCourse;

export const zCreateCourseData = z.object({
  body: zCourse,
  path: z.never().optional(),
  query: z.never().optional(),
});

/**
 * Course created successfully
 */
export const zCreateCourseResponse = zCourse;

export const zUnpublishCourseData = z.object({
  body: z.never().optional(),
  path: z.object({
    uuid: z.string().uuid(),
  }),
  query: z.never().optional(),
});

/**
 * Course unpublished successfully
 */
export const zUnpublishCourseResponse = zApiResponseCourse;

export const zUploadCourseThumbnailData = z.object({
  body: z
    .object({
      thumbnail: z
        .string()
        .describe(
          'Thumbnail image file to upload. Supported formats: JPG, PNG, GIF, WebP. Maximum size: 5MB.'
        ),
    })
    .optional(),
  path: z.object({
    uuid: z
      .string()
      .uuid()
      .describe(
        'UUID of the course to upload thumbnail for. Must be an existing course identifier.'
      ),
  }),
  query: z.never().optional(),
});

/**
 * Thumbnail uploaded successfully
 */
export const zUploadCourseThumbnailResponse = zCourse;

export const zPublishCourseData = z.object({
  body: z.never().optional(),
  path: z.object({
    uuid: z.string().uuid(),
  }),
  query: z.never().optional(),
});

/**
 * Course published successfully
 */
export const zPublishCourseResponse = zApiResponseCourse;

export const zUploadCourseIntroVideoData = z.object({
  body: z
    .object({
      intro_video: z
        .string()
        .describe(
          'Introduction video file to upload. Supported formats: MP4, WebM, MOV, AVI. Maximum size: 100MB.'
        ),
    })
    .optional(),
  path: z.object({
    uuid: z
      .string()
      .uuid()
      .describe(
        'UUID of the course to upload intro video for. Must be an existing course identifier.'
      ),
  }),
  query: z.never().optional(),
});

/**
 * Introduction video uploaded successfully
 */
export const zUploadCourseIntroVideoResponse = zCourse;

export const zUploadCourseBannerData = z.object({
  body: z
    .object({
      banner: z
        .string()
        .describe(
          'Banner image file to upload. Supported formats: JPG, PNG, GIF, WebP. Maximum size: 10MB.'
        ),
    })
    .optional(),
  path: z.object({
    uuid: z
      .string()
      .uuid()
      .describe('UUID of the course to upload banner for. Must be an existing course identifier.'),
  }),
  query: z.never().optional(),
});

/**
 * Banner uploaded successfully
 */
export const zUploadCourseBannerResponse = zCourse;

export const zArchiveCourseData = z.object({
  body: z.never().optional(),
  path: z.object({
    uuid: z.string().uuid(),
  }),
  query: z.never().optional(),
});

/**
 * Course archived successfully
 */
export const zArchiveCourseResponse = zApiResponseCourse;

export const zGetCourseTrainingRequirementsData = z.object({
  body: z.never().optional(),
  path: z.object({
    courseUuid: z.string().uuid(),
  }),
  query: z.object({
    pageable: zPageable,
  }),
});

/**
 * OK
 */
export const zGetCourseTrainingRequirementsResponse = zApiResponsePagedDtoCourseTrainingRequirement;

export const zAddCourseTrainingRequirementData = z.object({
  body: zCourseTrainingRequirement,
  path: z.object({
    courseUuid: z.string().uuid(),
  }),
  query: z.never().optional(),
});

/**
 * OK
 */
export const zAddCourseTrainingRequirementResponse = zApiResponseCourseTrainingRequirement;

export const zGetCourseRubricsData = z.object({
  body: z.never().optional(),
  path: z.object({
    courseUuid: z.string().uuid().describe('UUID of the course'),
  }),
  query: z.object({
    pageable: zPageable,
  }),
});

/**
 * OK
 */
export const zGetCourseRubricsResponse = zApiResponsePagedDtoCourseRubricAssociation;

export const zAssociateRubricData = z.object({
  body: zCourseRubricAssociation,
  path: z.object({
    courseUuid: z.string().uuid().describe('UUID of the course'),
  }),
  query: z.never().optional(),
});

/**
 * OK
 */
export const zAssociateRubricResponse = zApiResponseCourseRubricAssociation;

export const zGetCourseRequirementsData = z.object({
  body: z.never().optional(),
  path: z.object({
    courseUuid: z.string().uuid(),
  }),
  query: z.object({
    pageable: zPageable,
  }),
});

/**
 * OK
 */
export const zGetCourseRequirementsResponse = zApiResponsePagedDtoCourseRequirement;

export const zAddCourseRequirementData = z.object({
  body: zCourseRequirement,
  path: z.object({
    courseUuid: z.string().uuid(),
  }),
  query: z.never().optional(),
});

/**
 * OK
 */
export const zAddCourseRequirementResponse = zApiResponseCourseRequirement;

export const zGetCourseLessonsData = z.object({
  body: z.never().optional(),
  path: z.object({
    courseUuid: z.string().uuid(),
  }),
  query: z.object({
    pageable: zPageable,
  }),
});

/**
 * OK
 */
export const zGetCourseLessonsResponse = zApiResponsePagedDtoLesson;

export const zAddCourseLessonData = z.object({
  body: zLesson,
  path: z.object({
    courseUuid: z.string().uuid(),
  }),
  query: z.never().optional(),
});

/**
 * OK
 */
export const zAddCourseLessonResponse = zApiResponseLesson;

export const zGetLessonContentData = z.object({
  body: z.never().optional(),
  path: z.object({
    courseUuid: z.string().uuid(),
    lessonUuid: z.string().uuid(),
  }),
  query: z.never().optional(),
});

/**
 * OK
 */
export const zGetLessonContentResponse = zApiResponseListLessonContent;

export const zAddLessonContentData = z.object({
  body: zLessonContent,
  path: z.object({
    courseUuid: z.string().uuid(),
    lessonUuid: z.string().uuid(),
  }),
  query: z.never().optional(),
});

/**
 * OK
 */
export const zAddLessonContentResponse = zApiResponseLessonContent;

export const zReorderLessonContentData = z.object({
  body: z.array(z.string().uuid()),
  path: z.object({
    courseUuid: z.string().uuid(),
    lessonUuid: z.string().uuid(),
  }),
  query: z.never().optional(),
});

/**
 * OK
 */
export const zReorderLessonContentResponse = zApiResponseString;

export const zGetCourseAssessmentsData = z.object({
  body: z.never().optional(),
  path: z.object({
    courseUuid: z.string().uuid(),
  }),
  query: z.object({
    pageable: zPageable,
  }),
});

/**
 * OK
 */
export const zGetCourseAssessmentsResponse = zApiResponsePagedDtoCourseAssessment;

export const zAddCourseAssessmentData = z.object({
  body: zCourseAssessment,
  path: z.object({
    courseUuid: z.string().uuid(),
  }),
  query: z.never().optional(),
});

/**
 * OK
 */
export const zAddCourseAssessmentResponse = zApiResponseCourseAssessment;

export const zGetAllCourseCreatorsData = z.object({
  body: z.never().optional(),
  path: z.never().optional(),
  query: z.object({
    pageable: zPageable,
  }),
});

/**
 * OK
 */
export const zGetAllCourseCreatorsResponse = zApiResponsePagedDtoCourseCreator;

export const zCreateCourseCreatorData = z.object({
  body: zCourseCreator,
  path: z.never().optional(),
  query: z.never().optional(),
});

/**
 * Course creator created successfully
 */
export const zCreateCourseCreatorResponse = zCourseCreator;

export const zVerifyCourseCreatorData = z.object({
  body: z.never().optional(),
  path: z.object({
    uuid: z.string().uuid(),
  }),
  query: z
    .object({
      reason: z.string().optional(),
    })
    .optional(),
});

/**
 * Course creator verified successfully
 */
export const zVerifyCourseCreatorResponse = zCourseCreator;

export const zUnverifyCourseCreatorData = z.object({
  body: z.never().optional(),
  path: z.object({
    uuid: z.string().uuid(),
  }),
  query: z
    .object({
      reason: z.string().optional(),
    })
    .optional(),
});

/**
 * Course creator unverified successfully
 */
export const zUnverifyCourseCreatorResponse = zCourseCreator;

export const zGetAllGradingLevelsData = z.object({
  body: z.never().optional(),
  path: z.never().optional(),
  query: z.object({
    pageable: zPageable,
  }),
});

/**
 * OK
 */
export const zGetAllGradingLevelsResponse = zApiResponsePagedDtoGradingLevel;

export const zCreateGradingLevelData = z.object({
  body: zGradingLevel,
  path: z.never().optional(),
  query: z.never().optional(),
});

/**
 * OK
 */
export const zCreateGradingLevelResponse = zApiResponseGradingLevel;

export const zGetAllDifficultyLevelsData = z.object({
  body: z.never().optional(),
  path: z.never().optional(),
  query: z.never().optional(),
});

/**
 * OK
 */
export const zGetAllDifficultyLevelsResponse = zApiResponseListDifficultyLevel;

export const zCreateDifficultyLevelData = z.object({
  body: zDifficultyLevel,
  path: z.never().optional(),
  query: z.never().optional(),
});

/**
 * OK
 */
export const zCreateDifficultyLevelResponse = zApiResponseDifficultyLevel;

export const zReorderDifficultyLevelsData = z.object({
  body: z.array(z.string().uuid()),
  path: z.never().optional(),
  query: z.never().optional(),
});

/**
 * OK
 */
export const zReorderDifficultyLevelsResponse = zApiResponseString;

export const zGetAllContentTypesData = z.object({
  body: z.never().optional(),
  path: z.never().optional(),
  query: z.object({
    pageable: zPageable,
  }),
});

/**
 * OK
 */
export const zGetAllContentTypesResponse = zApiResponsePagedDtoContentType;

export const zCreateContentTypeData = z.object({
  body: zContentType,
  path: z.never().optional(),
  query: z.never().optional(),
});

/**
 * OK
 */
export const zCreateContentTypeResponse = zApiResponseContentType;

export const zGetAllCategoriesData = z.object({
  body: z.never().optional(),
  path: z.never().optional(),
  query: z.object({
    pageable: zPageable,
  }),
});

/**
 * OK
 */
export const zGetAllCategoriesResponse = zApiResponsePagedDtoCategory;

export const zCreateCategoryData = z.object({
  body: zCategory,
  path: z.never().optional(),
  query: z.never().optional(),
});

/**
 * OK
 */
export const zCreateCategoryResponse = zApiResponseCategory;

export const zCompleteCheckoutData = z.object({
  body: zCheckoutRequest,
  path: z.never().optional(),
  query: z.never().optional(),
});

/**
 * Order created
 */
export const zCompleteCheckoutResponse = zOrderResponse;

export const zCreateCartData = z.object({
  body: zCreateCartRequest,
  path: z.never().optional(),
  query: z.never().optional(),
});

/**
 * Cart created successfully
 */
export const zCreateCartResponse = zCartResponse;

export const zSelectPaymentSessionData = z.object({
  body: zSelectPaymentSessionRequest,
  path: z.object({
    cartId: z.string().describe('Identifier of the cart to update'),
  }),
  query: z.never().optional(),
});

/**
 * Payment session selected
 */
export const zSelectPaymentSessionResponse = zCartResponse;

export const zAddItemData = z.object({
  body: zCartLineItemRequest,
  path: z.object({
    cartId: z.string().describe('Identifier of the cart to update'),
  }),
  query: z.never().optional(),
});

/**
 * Item added
 */
export const zAddItemResponse = zCartResponse;

export const zCompleteCartData = z.object({
  body: z.never().optional(),
  path: z.object({
    cartId: z.string().describe('Identifier of the cart to finalise'),
  }),
  query: z.never().optional(),
});

/**
 * Cart completed
 */
export const zCompleteCartResponse = zOrderResponse;

export const zCreateClassDefinitionData = z.object({
  body: zClassDefinition,
  path: z.never().optional(),
  query: z.never().optional(),
});

/**
 * Class definition created successfully
 */
export const zCreateClassDefinitionResponse = zApiResponseClassDefinition;

export const zCreateClassRecurrencePatternData = z.object({
  body: zRecurrencePattern,
  path: z.never().optional(),
  query: z.never().optional(),
});

/**
 * Recurrence pattern created successfully
 */
export const zCreateClassRecurrencePatternResponse = zApiResponseRecurrencePattern;

export const zGetAllCertificatesData = z.object({
  body: z.never().optional(),
  path: z.never().optional(),
  query: z.object({
    pageable: zPageable,
  }),
});

/**
 * OK
 */
export const zGetAllCertificatesResponse = zApiResponsePagedDtoCertificate;

export const zCreateCertificateData = z.object({
  body: zCertificate,
  path: z.never().optional(),
  query: z.never().optional(),
});

/**
 * Certificate created successfully
 */
export const zCreateCertificateResponse = zCertificate;

export const zRevokeCertificateData = z.object({
  body: z.never().optional(),
  path: z.object({
    uuid: z.string().uuid(),
  }),
  query: z.object({
    reason: z.string(),
  }),
});

/**
 * Certificate revoked successfully
 */
export const zRevokeCertificateResponse = zApiResponseString;

export const zGenerateCertificateUrlData = z.object({
  body: z.never().optional(),
  path: z.object({
    uuid: z.string().uuid(),
  }),
  query: z.object({
    certificateUrl: z.string(),
  }),
});

/**
 * OK
 */
export const zGenerateCertificateUrlResponse = zApiResponseCertificate;

export const zGetCertificateTemplatesData = z.object({
  body: z.never().optional(),
  path: z.never().optional(),
  query: z.object({
    pageable: zPageable,
  }),
});

/**
 * OK
 */
export const zGetCertificateTemplatesResponse = zApiResponsePagedDtoCertificateTemplate;

export const zCreateCertificateTemplateData = z.object({
  body: zCertificateTemplate,
  path: z.never().optional(),
  query: z.never().optional(),
});

/**
 * OK
 */
export const zCreateCertificateTemplateResponse = zApiResponseCertificateTemplate;

export const zGenerateProgramCertificateData = z.object({
  body: z.never().optional(),
  path: z.never().optional(),
  query: z.object({
    studentUuid: z.string().uuid(),
    programUuid: z.string().uuid(),
    finalGrade: z.number(),
  }),
});

/**
 * Certificate generated successfully
 */
export const zGenerateProgramCertificateResponse = zApiResponseCertificate;

export const zGenerateCourseCertificateData = z.object({
  body: z.never().optional(),
  path: z.never().optional(),
  query: z.object({
    studentUuid: z.string().uuid(),
    courseUuid: z.string().uuid(),
    finalGrade: z.number(),
  }),
});

/**
 * Certificate generated successfully
 */
export const zGenerateCourseCertificateResponse = zApiResponseCertificate;

export const zGetAllAssignmentsData = z.object({
  body: z.never().optional(),
  path: z.never().optional(),
  query: z.object({
    pageable: zPageable,
  }),
});

/**
 * OK
 */
export const zGetAllAssignmentsResponse = zApiResponsePagedDtoAssignment;

export const zCreateAssignmentData = z.object({
  body: zAssignment,
  path: z.never().optional(),
  query: z.never().optional(),
});

/**
 * Assignment created successfully
 */
export const zCreateAssignmentResponse = zAssignment;

export const zSubmitAssignmentData = z.object({
  body: z.never().optional(),
  path: z.object({
    assignmentUuid: z.string().uuid(),
  }),
  query: z.object({
    enrollmentUuid: z.string().uuid(),
    content: z.string(),
    fileUrls: z.array(z.string()).optional(),
  }),
});

/**
 * OK
 */
export const zSubmitAssignmentResponse = zApiResponseAssignmentSubmission;

export const zReturnSubmissionData = z.object({
  body: z.never().optional(),
  path: z.object({
    assignmentUuid: z.string().uuid(),
    submissionUuid: z.string().uuid(),
  }),
  query: z.object({
    feedback: z.string(),
  }),
});

/**
 * OK
 */
export const zReturnSubmissionResponse = zApiResponseAssignmentSubmission;

export const zGradeSubmissionData = z.object({
  body: z.never().optional(),
  path: z.object({
    assignmentUuid: z.string().uuid(),
    submissionUuid: z.string().uuid(),
  }),
  query: z.object({
    score: z.number(),
    maxScore: z.number(),
    comments: z.string().optional(),
  }),
});

/**
 * OK
 */
export const zGradeSubmissionResponse = zApiResponseAssignmentSubmission;

export const zAssignAdminDomainData = z.object({
  body: zAdminDomainAssignmentRequest,
  path: z.object({
    uuid: z
      .string()
      .uuid()
      .describe('UUID of the user to assign admin domain to. User must exist in the system.'),
  }),
  query: z.never().optional(),
});

/**
 * Admin domain assigned successfully
 */
export const zAssignAdminDomainResponse = zApiResponseUser;

export const zVerifyOrganisationData = z.object({
  body: z.never().optional(),
  path: z.object({
    uuid: z
      .string()
      .uuid()
      .describe('UUID of the organization to verify. Must be an existing organization identifier.'),
  }),
  query: z
    .object({
      reason: z.string().describe('Optional reason for verification').optional(),
    })
    .optional(),
});

/**
 * Organization verified successfully
 */
export const zVerifyOrganisationResponse = zApiResponseOrganisation;

export const zUnverifyOrganisationData = z.object({
  body: z.never().optional(),
  path: z.object({
    uuid: z
      .string()
      .uuid()
      .describe(
        'UUID of the organization to remove verification from. Must be an existing organization identifier.'
      ),
  }),
  query: z
    .object({
      reason: z.string().describe('Optional reason for removing verification').optional(),
    })
    .optional(),
});

/**
 * Organization verification removed successfully
 */
export const zUnverifyOrganisationResponse = zApiResponseOrganisation;

export const zVerifyInstructorData = z.object({
  body: z.never().optional(),
  path: z.object({
    uuid: z
      .string()
      .uuid()
      .describe('UUID of the instructor to verify. Must be an existing instructor identifier.'),
  }),
  query: z
    .object({
      reason: z.string().describe('Optional reason for verification').optional(),
    })
    .optional(),
});

/**
 * Instructor verified successfully
 */
export const zVerifyInstructorResponse = zApiResponseInstructor;

export const zUnverifyInstructorData = z.object({
  body: z.never().optional(),
  path: z.object({
    uuid: z
      .string()
      .uuid()
      .describe(
        'UUID of the instructor to remove verification from. Must be an existing instructor identifier.'
      ),
  }),
  query: z
    .object({
      reason: z.string().describe('Optional reason for removing verification').optional(),
    })
    .optional(),
});

/**
 * Instructor verification removed successfully
 */
export const zUnverifyInstructorResponse = zApiResponseInstructor;

export const zUpdateScheduledInstanceStatusData = z.object({
  body: z.never().optional(),
  path: z.object({
    instanceUuid: z.string().uuid().describe('UUID of the scheduled instance'),
  }),
  query: z.object({
    status: z.string().describe('New status (SCHEDULED, ONGOING, COMPLETED, CANCELLED)'),
  }),
});

/**
 * Status updated successfully
 */
export const zUpdateScheduledInstanceStatusResponse = zApiResponseVoid;

export const zReorderScoringLevelsData = z.object({
  body: z.record(z.number().int()),
  path: z.object({
    rubricUuid: z.string().uuid().describe('UUID of the rubric'),
  }),
  query: z.never().optional(),
});

/**
 * OK
 */
export const zReorderScoringLevelsResponse = zApiResponseVoid;

export const zMarkAttendanceData = z.object({
  body: z.never().optional(),
  path: z.object({
    enrollmentUuid: z.string().uuid().describe('UUID of the enrollment'),
  }),
  query: z.object({
    attended: z.boolean().describe('Whether the student attended (true) or was absent (false)'),
  }),
});

/**
 * Attendance marked successfully
 */
export const zMarkAttendanceResponse = zApiResponseVoid;

export const zGetCartData = z.object({
  body: z.never().optional(),
  path: z.object({
    cartId: z.string().describe('Identifier of the cart to load'),
  }),
  query: z.never().optional(),
});

/**
 * Cart retrieved
 */
export const zGetCartResponse = zCartResponse;

export const zUpdateCartData = z.object({
  body: zUpdateCartRequest,
  path: z.object({
    cartId: z.string().describe('Identifier of the cart to update'),
  }),
  query: z.never().optional(),
});

/**
 * Cart updated
 */
export const zUpdateCartResponse = zCartResponse;

export const zGetAllUsersData = z.object({
  body: z.never().optional(),
  path: z.never().optional(),
  query: z.object({
    pageable: zPageable,
  }),
});

/**
 * Paginated list of all users retrieved successfully
 */
export const zGetAllUsersResponse = zApiResponsePagedDtoUser;

export const zGetInvitationsSentByUserData = z.object({
  body: z.never().optional(),
  path: z.object({
    uuid: z
      .string()
      .uuid()
      .describe('UUID of the user to retrieve sent invitations for. Must be an existing user.'),
  }),
  query: z.never().optional(),
});

/**
 * User's sent invitations retrieved successfully (may be empty list)
 */
export const zGetInvitationsSentByUserResponse = zApiResponseListInvitation;

export const zGetPendingInvitationsForUserData = z.object({
  body: z.never().optional(),
  path: z.object({
    uuid: z
      .string()
      .uuid()
      .describe(
        "UUID of the user to get pending invitations for. The system will use the user's email to find invitations."
      ),
  }),
  query: z.never().optional(),
});

/**
 * Pending invitations retrieved successfully (may be empty list)
 */
export const zGetPendingInvitationsForUserResponse = zApiResponseListInvitation;

export const zSearchData = z.object({
  body: z.never().optional(),
  path: z.never().optional(),
  query: z.object({
    searchParams: z.record(z.unknown()).describe('Optional search parameters for filtering'),
    pageable: zPageable,
  }),
});

/**
 * Paginated list of users matching the search criteria
 */
export const zSearchResponse = zApiResponsePagedDtoUser;

export const zGetProfileImageData = z.object({
  body: z.never().optional(),
  path: z.object({
    fileName: z
      .string()
      .describe(
        'Name of the profile image file to retrieve. Format: profile_images_uuid.extension'
      ),
  }),
  query: z.never().optional(),
});

/**
 * Profile image retrieved successfully
 */
export const zGetProfileImageResponse = z.string().describe('Profile image retrieved successfully');

export const zSearch1Data = z.object({
  body: z.never().optional(),
  path: z.never().optional(),
  query: z.object({
    searchParams: z.record(z.unknown()).describe('Optional search parameters for filtering'),
    pageable: zPageable,
  }),
});

/**
 * Paginated list of training branches matching the search criteria
 */
export const zSearch1Response = zApiResponsePagedDtoTrainingBranch;

export const zGetTrainingBranchesByOrganisation1Data = z.object({
  body: z.never().optional(),
  path: z.object({
    organisationUuid: z.string().uuid(),
  }),
  query: z.object({
    pageable: zPageable,
  }),
});

/**
 * Training branches retrieved successfully
 */
export const zGetTrainingBranchesByOrganisation1Response = zApiResponsePagedDtoTrainingBranch;

export const zCancelScheduledClassData = z.object({
  body: z.never().optional(),
  path: z.object({
    instanceUuid: z.string().uuid().describe('UUID of the scheduled instance to cancel'),
  }),
  query: z.object({
    reason: z.string().describe('Reason for cancellation'),
  }),
});

/**
 * Scheduled instance cancelled successfully
 */
export const zCancelScheduledClassResponse = zApiResponseVoid;

export const zGetScheduledInstanceData = z.object({
  body: z.never().optional(),
  path: z.object({
    instanceUuid: z.string().uuid().describe('UUID of the scheduled instance to retrieve'),
  }),
  query: z.never().optional(),
});

/**
 * Scheduled instance retrieved successfully
 */
export const zGetScheduledInstanceResponse = zApiResponseScheduledInstance;

export const zGetInstructorScheduleData = z.object({
  body: z.never().optional(),
  path: z.object({
    instructorUuid: z.string().uuid().describe('UUID of the instructor'),
  }),
  query: z.object({
    start: z.string().date().describe('Start date of the range (YYYY-MM-DD)'),
    end: z.string().date().describe('End date of the range (YYYY-MM-DD)'),
  }),
});

/**
 * Instructor schedule retrieved successfully
 */
export const zGetInstructorScheduleResponse = zApiResponseListScheduledInstance;

export const zSearchStudentsData = z.object({
  body: z.never().optional(),
  path: z.never().optional(),
  query: z.object({
    searchParams: z.record(z.unknown()).describe('Optional search parameters for filtering'),
    pageable: zPageable,
  }),
});

/**
 * Search results returned successfully
 */
export const zSearchStudentsResponse = zPage;

export const zValidateMatrixData = z.object({
  body: z.never().optional(),
  path: z.object({
    rubricUuid: z.string().uuid(),
  }),
  query: z.never().optional(),
});

/**
 * OK
 */
export const zValidateMatrixResponse = zApiResponseMatrixValidationResult;

export const zGetPassingScoringLevelsData = z.object({
  body: z.never().optional(),
  path: z.object({
    rubricUuid: z.string().uuid().describe('UUID of the rubric'),
  }),
  query: z.object({
    pageable: zPageable,
  }),
});

/**
 * OK
 */
export const zGetPassingScoringLevelsResponse = zApiResponsePagedDtoRubricScoringLevel;

export const zGetHighestScoringLevelData = z.object({
  body: z.never().optional(),
  path: z.object({
    rubricUuid: z.string().uuid().describe('UUID of the rubric'),
  }),
  query: z.never().optional(),
});

/**
 * OK
 */
export const zGetHighestScoringLevelResponse = zApiResponseRubricScoringLevel;

export const zGetRubricMatrixData = z.object({
  body: z.never().optional(),
  path: z.object({
    rubricUuid: z.string().uuid().describe('UUID of the rubric'),
  }),
  query: z.never().optional(),
});

/**
 * OK
 */
export const zGetRubricMatrixResponse = zApiResponseRubricMatrix;

export const zValidateMatrix1Data = z.object({
  body: z.never().optional(),
  path: z.object({
    rubricUuid: z.string().uuid().describe('UUID of the rubric'),
  }),
  query: z.never().optional(),
});

/**
 * OK
 */
export const zValidateMatrix1Response = zApiResponseMatrixValidationResult;

export const zGetMatrixStatisticsData = z.object({
  body: z.never().optional(),
  path: z.object({
    rubricUuid: z.string().uuid().describe('UUID of the rubric'),
  }),
  query: z.never().optional(),
});

/**
 * OK
 */
export const zGetMatrixStatisticsResponse = zApiResponseMatrixStatistics;

export const zCheckMatrixReadinessData = z.object({
  body: z.never().optional(),
  path: z.object({
    rubricUuid: z.string().uuid().describe('UUID of the rubric'),
  }),
  query: z.never().optional(),
});

/**
 * OK
 */
export const zCheckMatrixReadinessResponse = zApiResponseMapStringObject;

export const zGetRubricMatrixViewData = z.object({
  body: z.never().optional(),
  path: z.object({
    rubricUuid: z.string().uuid(),
  }),
  query: z.never().optional(),
});

/**
 * OK
 */
export const zGetRubricMatrixViewResponse = zApiResponseRubricMatrix;

export const zSearchAssessmentRubricsData = z.object({
  body: z.never().optional(),
  path: z.never().optional(),
  query: z.object({
    searchParams: z.record(z.string()),
    pageable: zPageable,
  }),
});

/**
 * OK
 */
export const zSearchAssessmentRubricsResponse = zApiResponsePagedDtoAssessmentRubric;

export const zGetRubricsByTypeData = z.object({
  body: z.never().optional(),
  path: z.object({
    type: z.string().describe('Rubric type to filter by'),
  }),
  query: z.object({
    pageable: zPageable,
  }),
});

/**
 * OK
 */
export const zGetRubricsByTypeResponse = zApiResponsePagedDtoAssessmentRubric;

export const zGetRubricsByStatusData = z.object({
  body: z.never().optional(),
  path: z.object({
    status: zSchemaEnum,
  }),
  query: z.object({
    pageable: zPageable,
  }),
});

/**
 * OK
 */
export const zGetRubricsByStatusResponse = zApiResponsePagedDtoAssessmentRubric;

export const zGetRubricStatisticsData = z.object({
  body: z.never().optional(),
  path: z.never().optional(),
  query: z.never().optional(),
});

/**
 * OK
 */
export const zGetRubricStatisticsResponse = zApiResponseMapStringLong;

export const zGetCourseCreatorRubricStatisticsData = z.object({
  body: z.never().optional(),
  path: z.object({
    courseCreatorUuid: z.string().uuid().describe('UUID of the course creator'),
  }),
  query: z.never().optional(),
});

/**
 * OK
 */
export const zGetCourseCreatorRubricStatisticsResponse = zApiResponseMapStringLong;

export const zSearchPublicRubricsData = z.object({
  body: z.never().optional(),
  path: z.never().optional(),
  query: z.object({
    q: z.string().describe('Search term to match in title or description').optional(),
    type: z.string().describe('Filter by rubric type').optional(),
    pageable: zPageable,
  }),
});

/**
 * OK
 */
export const zSearchPublicRubricsResponse = zApiResponsePagedDtoAssessmentRubric;

export const zGetPublicRubricsData = z.object({
  body: z.never().optional(),
  path: z.never().optional(),
  query: z.object({
    pageable: zPageable,
  }),
});

/**
 * OK
 */
export const zGetPublicRubricsResponse = zApiResponsePagedDtoAssessmentRubric;

export const zGetPopularRubricsData = z.object({
  body: z.never().optional(),
  path: z.never().optional(),
  query: z.object({
    pageable: zPageable,
  }),
});

/**
 * OK
 */
export const zGetPopularRubricsResponse = zApiResponsePagedDtoAssessmentRubric;

export const zGetGeneralRubricsData = z.object({
  body: z.never().optional(),
  path: z.never().optional(),
  query: z.object({
    pageable: zPageable,
  }),
});

/**
 * OK
 */
export const zGetGeneralRubricsResponse = zApiResponsePagedDtoAssessmentRubric;

export const zGetCourseCreatorRubricsData = z.object({
  body: z.never().optional(),
  path: z.object({
    courseCreatorUuid: z.string().uuid().describe('UUID of the course creator'),
  }),
  query: z.object({
    includePrivate: z
      .boolean()
      .describe('Include private rubrics (default: false)')
      .optional()
      .default(false),
    pageable: zPageable,
  }),
});

/**
 * OK
 */
export const zGetCourseCreatorRubricsResponse = zApiResponsePagedDtoAssessmentRubric;

export const zGetQuizTotalPointsData = z.object({
  body: z.never().optional(),
  path: z.object({
    quizUuid: z.string().uuid(),
  }),
  query: z.never().optional(),
});

/**
 * OK
 */
export const zGetQuizTotalPointsResponse = zApiResponseBigDecimal;

export const zGetQuestionDistributionData = z.object({
  body: z.never().optional(),
  path: z.object({
    quizUuid: z.string().uuid(),
  }),
  query: z.never().optional(),
});

/**
 * OK
 */
export const zGetQuestionDistributionResponse = zApiResponseMapStringLong;

export const zGetQuizAttemptsData = z.object({
  body: z.never().optional(),
  path: z.object({
    quizUuid: z.string().uuid(),
  }),
  query: z.object({
    pageable: zPageable,
  }),
});

/**
 * OK
 */
export const zGetQuizAttemptsResponse = zApiResponsePagedDtoQuizAttempt;

export const zSearchQuizzesData = z.object({
  body: z.never().optional(),
  path: z.never().optional(),
  query: z.object({
    searchParams: z.record(z.unknown()).describe('Optional search parameters for filtering'),
    pageable: zPageable,
  }),
});

/**
 * OK
 */
export const zSearchQuizzesResponse = zApiResponsePagedDtoQuiz;

export const zSearchQuestionsData = z.object({
  body: z.never().optional(),
  path: z.never().optional(),
  query: z.object({
    searchParams: z.record(z.unknown()).describe('Optional search parameters for filtering'),
    pageable: zPageable,
  }),
});

/**
 * OK
 */
export const zSearchQuestionsResponse = zApiResponsePagedDtoQuizQuestion;

export const zSearchAttemptsData = z.object({
  body: z.never().optional(),
  path: z.never().optional(),
  query: z.object({
    searchParams: z.record(z.unknown()).describe('Optional search parameters for filtering'),
    pageable: zPageable,
  }),
});

/**
 * OK
 */
export const zSearchAttemptsResponse = zApiResponsePagedDtoQuizAttempt;

export const zGetProgramEnrollmentsData = z.object({
  body: z.never().optional(),
  path: z.object({
    programUuid: z.string().uuid(),
  }),
  query: z.object({
    pageable: zPageable,
  }),
});

/**
 * OK
 */
export const zGetProgramEnrollmentsResponse = zApiResponsePagedDtoProgramEnrollment;

export const zGetRequiredCoursesData = z.object({
  body: z.never().optional(),
  path: z.object({
    programUuid: z.string().uuid(),
  }),
  query: z.never().optional(),
});

/**
 * OK
 */
export const zGetRequiredCoursesResponse = zApiResponseListCourse;

export const zGetOptionalCoursesData = z.object({
  body: z.never().optional(),
  path: z.object({
    programUuid: z.string().uuid(),
  }),
  query: z.never().optional(),
});

/**
 * OK
 */
export const zGetOptionalCoursesResponse = zApiResponseListCourse;

export const zGetProgramCompletionRateData = z.object({
  body: z.never().optional(),
  path: z.object({
    programUuid: z.string().uuid(),
  }),
  query: z.never().optional(),
});

/**
 * OK
 */
export const zGetProgramCompletionRateResponse = zApiResponseDouble;

export const zGetProgramCertificatesData = z.object({
  body: z.never().optional(),
  path: z.object({
    programUuid: z.string().uuid(),
  }),
  query: z.object({
    pageable: zPageable,
  }),
});

/**
 * OK
 */
export const zGetProgramCertificatesResponse = zApiResponsePagedDtoCertificate;

export const zSearchTrainingProgramsData = z.object({
  body: z.never().optional(),
  path: z.never().optional(),
  query: z.object({
    searchParams: z.record(z.unknown()).describe('Optional search parameters for filtering'),
    pageable: zPageable,
  }),
});

/**
 * OK
 */
export const zSearchTrainingProgramsResponse = zApiResponsePagedDtoTrainingProgram;

export const zSearchProgramRequirementsData = z.object({
  body: z.never().optional(),
  path: z.never().optional(),
  query: z.object({
    searchParams: z.record(z.unknown()).describe('Optional search parameters for filtering'),
    pageable: zPageable,
  }),
});

/**
 * OK
 */
export const zSearchProgramRequirementsResponse = zApiResponsePagedDtoProgramRequirement;

export const zGetPublishedProgramsData = z.object({
  body: z.never().optional(),
  path: z.never().optional(),
  query: z.object({
    pageable: zPageable,
  }),
});

/**
 * OK
 */
export const zGetPublishedProgramsResponse = zApiResponsePagedDtoTrainingProgram;

export const zGetProgramsByInstructorData = z.object({
  body: z.never().optional(),
  path: z.object({
    instructorUuid: z.string().uuid(),
  }),
  query: z.object({
    pageable: zPageable,
  }),
});

/**
 * OK
 */
export const zGetProgramsByInstructorResponse = zApiResponsePagedDtoTrainingProgram;

export const zGetFreeProgramsData = z.object({
  body: z.never().optional(),
  path: z.never().optional(),
  query: z.object({
    pageable: zPageable,
  }),
});

/**
 * OK
 */
export const zGetFreeProgramsResponse = zApiResponsePagedDtoTrainingProgram;

export const zSearchProgramEnrollmentsData = z.object({
  body: z.never().optional(),
  path: z.never().optional(),
  query: z.object({
    searchParams: z.record(z.unknown()).describe('Optional search parameters for filtering'),
    pageable: zPageable,
  }),
});

/**
 * OK
 */
export const zSearchProgramEnrollmentsResponse = zApiResponsePagedDtoProgramEnrollment;

export const zSearchProgramCoursesData = z.object({
  body: z.never().optional(),
  path: z.never().optional(),
  query: z.object({
    searchParams: z.record(z.unknown()).describe('Optional search parameters for filtering'),
    pageable: zPageable,
  }),
});

/**
 * OK
 */
export const zSearchProgramCoursesResponse = zApiResponsePagedDtoProgramCourse;

export const zGetProgramsByCategoryData = z.object({
  body: z.never().optional(),
  path: z.object({
    categoryUuid: z.string().uuid(),
  }),
  query: z.object({
    pageable: zPageable,
  }),
});

/**
 * OK
 */
export const zGetProgramsByCategoryResponse = zApiResponsePagedDtoTrainingProgram;

export const zGetActiveProgramsData = z.object({
  body: z.never().optional(),
  path: z.never().optional(),
  query: z.object({
    pageable: zPageable,
  }),
});

/**
 * OK
 */
export const zGetActiveProgramsResponse = zApiResponsePagedDtoTrainingProgram;

export const zGetUsersByOrganisationData = z.object({
  body: z.never().optional(),
  path: z.object({
    uuid: z
      .string()
      .uuid()
      .describe(
        'UUID of the organisation to get users for. Must be an existing organisation identifier.'
      ),
  }),
  query: z.object({
    pageable: zPageable,
  }),
});

/**
 * Users retrieved successfully
 */
export const zGetUsersByOrganisationResponse = zApiResponsePagedDtoUser;

export const zGetUsersByOrganisationAndDomainData = z.object({
  body: z.never().optional(),
  path: z.object({
    uuid: z
      .string()
      .uuid()
      .describe(
        'UUID of the organisation to get users for. Must be an existing organisation identifier.'
      ),
    domainName: z
      .string()
      .describe(
        "Domain name to filter users by. Valid values: 'student', 'instructor', 'admin', 'organisation_user'"
      ),
  }),
  query: z.never().optional(),
});

/**
 * Filtered users retrieved successfully
 */
export const zGetUsersByOrganisationAndDomainResponse = zApiResponseListUser;

export const zGetBranchUsersData = z.object({
  body: z.never().optional(),
  path: z.object({
    uuid: z
      .string()
      .uuid()
      .describe(
        'UUID of the organization that owns the training branch. Must be an existing organization.'
      ),
    branchUuid: z
      .string()
      .uuid()
      .describe(
        'UUID of the training branch to get users for. Must be a branch within the specified organization.'
      ),
  }),
  query: z.never().optional(),
});

/**
 * Branch users retrieved successfully
 */
export const zGetBranchUsersResponse = zApiResponseListUser;

export const zGetBranchUsersByDomainData = z.object({
  body: z.never().optional(),
  path: z.object({
    uuid: z
      .string()
      .uuid()
      .describe(
        'UUID of the organization that owns the training branch. Must be an existing organization.'
      ),
    branchUuid: z
      .string()
      .uuid()
      .describe(
        'UUID of the training branch to get users for. Must be a branch within the specified organization.'
      ),
    domainName: z
      .string()
      .describe(
        "Domain name to filter users by. Valid values: 'student', 'instructor', 'admin', 'organisation_user'"
      ),
  }),
  query: z.never().optional(),
});

/**
 * Filtered branch users retrieved successfully
 */
export const zGetBranchUsersByDomainResponse = zApiResponseListUser;

export const zSearch2Data = z.object({
  body: z.never().optional(),
  path: z.never().optional(),
  query: z.object({
    searchParams: z.record(z.unknown()).describe('Optional search parameters for filtering'),
    pageable: zPageable,
  }),
});

/**
 * Paginated list of organisations matching the search criteria
 */
export const zSearch2Response = zApiResponsePagedDtoOrganisation;

export const zValidateInvitationData = z.object({
  body: z.never().optional(),
  path: z.object({
    token: z
      .string()
      .describe(
        'Unique invitation token to validate. This is the 64-character token from invitation emails.'
      ),
  }),
  query: z.never().optional(),
});

/**
 * Validation completed - check response body for result
 */
export const zValidateInvitationResponse = zApiResponseBoolean;

export const zGetInvitationByTokenData = z.object({
  body: z.never().optional(),
  path: z.object({
    token: z
      .string()
      .describe(
        'Unique invitation token from the invitation email URL. This is the 64-character identifier for the specific invitation.'
      ),
  }),
  query: z.never().optional(),
});

/**
 * Invitation details retrieved successfully
 */
export const zGetInvitationByTokenResponse = zApiResponseInvitation;

export const zPreviewInvitationData = z.object({
  body: z.never().optional(),
  path: z.never().optional(),
  query: z.object({
    token: z
      .string()
      .describe('Invitation token from email link. Must be a valid, non-expired invitation token.'),
  }),
});

/**
 * Invitation preview retrieved successfully
 */
export const zPreviewInvitationResponse = zApiResponseInvitationPreview;

export const zGetPendingInvitationsForEmailData = z.object({
  body: z.never().optional(),
  path: z.never().optional(),
  query: z.object({
    email: z
      .string()
      .describe(
        'Email address to search for pending invitations. Must be a valid email format. Search is case-insensitive.'
      ),
  }),
});

/**
 * Pending invitations retrieved successfully (may be empty list)
 */
export const zGetPendingInvitationsForEmailResponse = zApiResponseListInvitation;

export const zClearInstructorAvailabilityData = z.object({
  body: z.never().optional(),
  path: z.object({
    instructorUuid: z.string().uuid().describe('UUID of the instructor'),
  }),
  query: z.never().optional(),
});

/**
 * Availability cleared successfully
 */
export const zClearInstructorAvailabilityResponse = zApiResponseVoid;

export const zGetInstructorAvailabilityData = z.object({
  body: z.never().optional(),
  path: z.object({
    instructorUuid: z.string().uuid().describe('UUID of the instructor'),
  }),
  query: z.never().optional(),
});

/**
 * Availability retrieved successfully
 */
export const zGetInstructorAvailabilityResponse = zApiResponseListAvailabilitySlot;

export const zSearchAvailabilityData = z.object({
  body: z.never().optional(),
  path: z.object({
    instructorUuid: z.string().uuid().describe('UUID of the instructor'),
  }),
  query: z.object({
    searchParams: z.record(z.unknown()).describe('Optional search parameters for filtering'),
    pageable: zPageable,
  }),
});

/**
 * Search results returned successfully
 */
export const zSearchAvailabilityResponse = zPage;

export const zGetAvailabilityForDateData = z.object({
  body: z.never().optional(),
  path: z.object({
    instructorUuid: z.string().uuid().describe('UUID of the instructor'),
    date: z.string().date().describe('Date to check (YYYY-MM-DD)'),
  }),
  query: z.never().optional(),
});

/**
 * Availability for date retrieved successfully
 */
export const zGetAvailabilityForDateResponse = zApiResponseListAvailabilitySlot;

export const zCheckAvailabilityData = z.object({
  body: z.never().optional(),
  path: z.object({
    instructorUuid: z.string().uuid().describe('UUID of the instructor'),
  }),
  query: z.object({
    start: z.string().datetime().describe('Start date and time (ISO format: YYYY-MM-DDTHH:mm:ss)'),
    end: z.string().datetime().describe('End date and time (ISO format: YYYY-MM-DDTHH:mm:ss)'),
  }),
});

/**
 * Availability check completed
 */
export const zCheckAvailabilityResponse = zApiResponseBoolean;

export const zFindAvailableSlotsData = z.object({
  body: z.never().optional(),
  path: z.object({
    instructorUuid: z.string().uuid().describe('UUID of the instructor'),
  }),
  query: z.object({
    start_date: z.string().date().describe('Start date of search range (YYYY-MM-DD)'),
    end_date: z.string().date().describe('End date of search range (YYYY-MM-DD)'),
  }),
});

/**
 * Available slots found successfully
 */
export const zFindAvailableSlotsResponse = zApiResponseListAvailabilitySlot;

export const zSearchSkillsData = z.object({
  body: z.never().optional(),
  path: z.never().optional(),
  query: z.object({
    searchParams: z.record(z.unknown()).describe('Optional search parameters for filtering'),
    pageable: zPageable,
  }),
});

/**
 * OK
 */
export const zSearchSkillsResponse = zApiResponsePagedDtoInstructorSkill;

export const zSearchInstructorsData = z.object({
  body: z.never().optional(),
  path: z.never().optional(),
  query: z.object({
    searchParams: z.record(z.unknown()).describe('Optional search parameters for filtering'),
    pageable: zPageable,
  }),
});

/**
 * Search results returned successfully
 */
export const zSearchInstructorsResponse = zPage;

export const zSearchMembershipsData = z.object({
  body: z.never().optional(),
  path: z.never().optional(),
  query: z.object({
    searchParams: z.record(z.unknown()).describe('Optional search parameters for filtering'),
    pageable: zPageable,
  }),
});

/**
 * OK
 */
export const zSearchMembershipsResponse = zApiResponsePagedDtoInstructorProfessionalMembership;

export const zSearchExperienceData = z.object({
  body: z.never().optional(),
  path: z.never().optional(),
  query: z.object({
    searchParams: z.record(z.unknown()).describe('Optional search parameters for filtering'),
    pageable: zPageable,
  }),
});

/**
 * OK
 */
export const zSearchExperienceResponse = zApiResponsePagedDtoInstructorExperience;

export const zSearchEducationData = z.object({
  body: z.never().optional(),
  path: z.never().optional(),
  query: z.object({
    searchParams: z.record(z.unknown()).describe('Optional search parameters for filtering'),
    pageable: zPageable,
  }),
});

/**
 * OK
 */
export const zSearchEducationResponse = zApiResponsePagedDtoInstructorEducation;

export const zSearchDocumentsData = z.object({
  body: z.never().optional(),
  path: z.never().optional(),
  query: z.object({
    searchParams: z.record(z.unknown()).describe('Optional search parameters for filtering'),
    pageable: zPageable,
  }),
});

/**
 * OK
 */
export const zSearchDocumentsResponse = zApiResponsePagedDtoInstructorDocument;

export const zCancelEnrollmentData = z.object({
  body: z.never().optional(),
  path: z.object({
    enrollmentUuid: z.string().uuid().describe('UUID of the enrollment to cancel'),
  }),
  query: z.object({
    reason: z.string().describe('Reason for cancellation'),
  }),
});

/**
 * Enrollment cancelled successfully
 */
export const zCancelEnrollmentResponse = zApiResponseVoid;

export const zGetEnrollmentData = z.object({
  body: z.never().optional(),
  path: z.object({
    enrollmentUuid: z.string().uuid().describe('UUID of the enrollment to retrieve'),
  }),
  query: z.never().optional(),
});

/**
 * Enrollment retrieved successfully
 */
export const zGetEnrollmentResponse = zApiResponseEnrollment;

export const zGetStudentScheduleData = z.object({
  body: z.never().optional(),
  path: z.object({
    studentUuid: z.string().uuid().describe('UUID of the student'),
  }),
  query: z.object({
    start: z.string().date().describe('Start date of the range (YYYY-MM-DD)'),
    end: z.string().date().describe('End date of the range (YYYY-MM-DD)'),
  }),
});

/**
 * Student schedule retrieved successfully
 */
export const zGetStudentScheduleResponse = zApiResponseListStudentSchedule;

export const zGetEnrollmentsForInstanceData = z.object({
  body: z.never().optional(),
  path: z.object({
    instanceUuid: z.string().uuid().describe('UUID of the scheduled instance'),
  }),
  query: z.never().optional(),
});

/**
 * Enrollments retrieved successfully
 */
export const zGetEnrollmentsForInstanceResponse = zApiResponseListEnrollment;

export const zGetEnrollmentCountData = z.object({
  body: z.never().optional(),
  path: z.object({
    instanceUuid: z.string().uuid().describe('UUID of the scheduled instance'),
  }),
  query: z.never().optional(),
});

/**
 * Enrollment count retrieved successfully
 */
export const zGetEnrollmentCountResponse = zApiResponseLong;

export const zHasCapacityForEnrollmentData = z.object({
  body: z.never().optional(),
  path: z.object({
    instanceUuid: z.string().uuid().describe('UUID of the scheduled instance'),
  }),
  query: z.never().optional(),
});

/**
 * Capacity check completed
 */
export const zHasCapacityForEnrollmentResponse = zApiResponseBoolean;

export const zGetStatusTransitionsData = z.object({
  body: z.never().optional(),
  path: z.object({
    uuid: z.string().uuid(),
  }),
  query: z.never().optional(),
});

/**
 * Available transitions retrieved successfully
 */
export const zGetStatusTransitionsResponse = zApiResponseListContentStatus;

export const zCheckRubricAssociationData = z.object({
  body: z.never().optional(),
  path: z.object({
    courseUuid: z.string().uuid().describe('UUID of the course'),
    rubricUuid: z.string().uuid().describe('UUID of the rubric to check'),
  }),
  query: z.never().optional(),
});

/**
 * OK
 */
export const zCheckRubricAssociationResponse = zApiResponseBoolean;

export const zGetPrimaryRubricData = z.object({
  body: z.never().optional(),
  path: z.object({
    courseUuid: z.string().uuid().describe('UUID of the course'),
  }),
  query: z.never().optional(),
});

/**
 * OK
 */
export const zGetPrimaryRubricResponse = zApiResponseCourseRubricAssociation;

export const zGetRubricsByContextData = z.object({
  body: z.never().optional(),
  path: z.object({
    courseUuid: z.string().uuid().describe('UUID of the course'),
    context: z.string().describe('Usage context to filter by'),
  }),
  query: z.object({
    pageable: zPageable,
  }),
});

/**
 * OK
 */
export const zGetRubricsByContextResponse = zApiResponsePagedDtoCourseRubricAssociation;

export const zGetCourseEnrollmentsData = z.object({
  body: z.never().optional(),
  path: z.object({
    courseUuid: z.string().uuid(),
  }),
  query: z.object({
    pageable: zPageable,
  }),
});

/**
 * OK
 */
export const zGetCourseEnrollmentsResponse = zApiResponsePagedDtoCourseEnrollment;

export const zGetCourseCompletionRateData = z.object({
  body: z.never().optional(),
  path: z.object({
    courseUuid: z.string().uuid(),
  }),
  query: z.never().optional(),
});

/**
 * OK
 */
export const zGetCourseCompletionRateResponse = zApiResponseDouble;

export const zRemoveAllCategoriesFromCourseData = z.object({
  body: z.never().optional(),
  path: z.object({
    courseUuid: z.string().uuid(),
  }),
  query: z.never().optional(),
});

/**
 * OK
 */
export const zRemoveAllCategoriesFromCourseResponse = zApiResponseString;

export const zGetCourseCategoriesData = z.object({
  body: z.never().optional(),
  path: z.object({
    courseUuid: z.string().uuid(),
  }),
  query: z.never().optional(),
});

/**
 * OK
 */
export const zGetCourseCategoriesResponse = zApiResponseListCourseCategoryMapping;

export const zSearchCoursesData = z.object({
  body: z.never().optional(),
  path: z.never().optional(),
  query: z.object({
    searchParams: z.record(z.unknown()).describe('Optional search parameters for filtering'),
    pageable: zPageable,
  }),
});

/**
 * OK
 */
export const zSearchCoursesResponse = zApiResponsePagedDtoCourse;

export const zSearchRequirementsData = z.object({
  body: z.never().optional(),
  path: z.never().optional(),
  query: z.object({
    searchParams: z.record(z.unknown()).describe('Optional search parameters for filtering'),
    pageable: zPageable,
  }),
});

/**
 * OK
 */
export const zSearchRequirementsResponse = zApiResponsePagedDtoCourseRequirement;

export const zGetPublishedCoursesData = z.object({
  body: z.never().optional(),
  path: z.never().optional(),
  query: z.object({
    pageable: zPageable,
  }),
});

/**
 * OK
 */
export const zGetPublishedCoursesResponse = zApiResponsePagedDtoCourse;

export const zGetCourseMediaData = z.object({
  body: z.never().optional(),
  path: z.object({
    fileName: z
      .string()
      .describe(
        'Name of the media file to retrieve. This is typically returned from the upload endpoints.'
      ),
  }),
  query: z.never().optional(),
});

/**
 * Media file retrieved successfully
 */
export const zGetCourseMediaResponse = z.string().describe('Media file retrieved successfully');

export const zSearchLessonsData = z.object({
  body: z.never().optional(),
  path: z.never().optional(),
  query: z.object({
    searchParams: z.record(z.unknown()).describe('Optional search parameters for filtering'),
    pageable: zPageable,
  }),
});

/**
 * OK
 */
export const zSearchLessonsResponse = zApiResponsePagedDtoLesson;

export const zGetCoursesByInstructorData = z.object({
  body: z.never().optional(),
  path: z.object({
    instructorUuid: z.string().uuid(),
  }),
  query: z.object({
    pageable: zPageable,
  }),
});

/**
 * OK
 */
export const zGetCoursesByInstructorResponse = zApiResponsePagedDtoCourse;

export const zSearchEnrollmentsData = z.object({
  body: z.never().optional(),
  path: z.never().optional(),
  query: z.object({
    searchParams: z.record(z.unknown()).describe('Optional search parameters for filtering'),
    pageable: zPageable,
  }),
});

/**
 * OK
 */
export const zSearchEnrollmentsResponse = zApiResponsePagedDtoCourseEnrollment;

export const zSearchLessonContentData = z.object({
  body: z.never().optional(),
  path: z.never().optional(),
  query: z.object({
    searchParams: z.record(z.unknown()).describe('Optional search parameters for filtering'),
    pageable: zPageable,
  }),
});

/**
 * OK
 */
export const zSearchLessonContentResponse = zApiResponsePagedDtoLessonContent;

export const zGetCoursesByCategoryData = z.object({
  body: z.never().optional(),
  path: z.object({
    categoryUuid: z.string().uuid(),
  }),
  query: z.object({
    pageable: zPageable,
  }),
});

/**
 * OK
 */
export const zGetCoursesByCategoryResponse = zApiResponsePagedDtoCourse;

export const zSearchCategoryMappingsData = z.object({
  body: z.never().optional(),
  path: z.never().optional(),
  query: z.object({
    searchParams: z.record(z.unknown()).describe('Optional search parameters for filtering'),
    pageable: zPageable,
  }),
});

/**
 * OK
 */
export const zSearchCategoryMappingsResponse = zApiResponsePagedDtoCourseCategoryMapping;

export const zSearchAssessmentsData = z.object({
  body: z.never().optional(),
  path: z.never().optional(),
  query: z.object({
    searchParams: z.record(z.unknown()).describe('Optional search parameters for filtering'),
    pageable: zPageable,
  }),
});

/**
 * OK
 */
export const zSearchAssessmentsResponse = zApiResponsePagedDtoCourseAssessment;

export const zGetActiveCoursesData = z.object({
  body: z.never().optional(),
  path: z.never().optional(),
  query: z.object({
    pageable: zPageable,
  }),
});

/**
 * OK
 */
export const zGetActiveCoursesResponse = zApiResponsePagedDtoCourse;

export const zIsCourseCreatorVerifiedData = z.object({
  body: z.never().optional(),
  path: z.object({
    uuid: z.string().uuid(),
  }),
  query: z.never().optional(),
});

/**
 * Verification status retrieved
 */
export const zIsCourseCreatorVerifiedResponse = zApiResponseBoolean;

export const zGetVerifiedCourseCreatorsData = z.object({
  body: z.never().optional(),
  path: z.never().optional(),
  query: z.object({
    pageable: zPageable,
  }),
});

/**
 * Verified course creators retrieved successfully
 */
export const zGetVerifiedCourseCreatorsResponse = zApiResponsePagedDtoCourseCreator;

export const zGetUnverifiedCourseCreatorsData = z.object({
  body: z.never().optional(),
  path: z.never().optional(),
  query: z.object({
    pageable: zPageable,
  }),
});

/**
 * Unverified course creators retrieved successfully
 */
export const zGetUnverifiedCourseCreatorsResponse = zApiResponsePagedDtoCourseCreator;

export const zSearchCourseCreatorsData = z.object({
  body: z.never().optional(),
  path: z.never().optional(),
  query: z.object({
    searchParams: z.record(z.string()),
    pageable: zPageable,
  }),
});

/**
 * Search results returned successfully
 */
export const zSearchCourseCreatorsResponse = zPage;

export const zCountCourseCreatorsByVerificationStatusData = z.object({
  body: z.never().optional(),
  path: z.never().optional(),
  query: z.object({
    verified: z.boolean(),
  }),
});

/**
 * Count retrieved successfully
 */
export const zCountCourseCreatorsByVerificationStatusResponse = zApiResponseLong;

export const zSearchContentTypesData = z.object({
  body: z.never().optional(),
  path: z.never().optional(),
  query: z.object({
    searchParams: z.record(z.unknown()).describe('Optional search parameters for filtering'),
    pageable: zPageable,
  }),
});

/**
 * OK
 */
export const zSearchContentTypesResponse = zApiResponsePagedDtoContentType;

export const zCheckMimeTypeSupportData = z.object({
  body: z.never().optional(),
  path: z.object({
    mimeType: z.string(),
  }),
  query: z.never().optional(),
});

/**
 * OK
 */
export const zCheckMimeTypeSupportResponse = zApiResponseBoolean;

export const zGetMediaContentTypesData = z.object({
  body: z.never().optional(),
  path: z.never().optional(),
  query: z.never().optional(),
});

/**
 * OK
 */
export const zGetMediaContentTypesResponse = zApiResponseListContentType;

export const zGetSubCategoriesData = z.object({
  body: z.never().optional(),
  path: z.object({
    parentUuid: z.string().uuid(),
  }),
  query: z.never().optional(),
});

/**
 * OK
 */
export const zGetSubCategoriesResponse = zApiResponseListCategory;

export const zSearchCategoriesData = z.object({
  body: z.never().optional(),
  path: z.never().optional(),
  query: z.object({
    searchParams: z.record(z.unknown()).describe('Optional search parameters for filtering'),
    pageable: zPageable,
  }),
});

/**
 * OK
 */
export const zSearchCategoriesResponse = zApiResponsePagedDtoCategory;

export const zGetRootCategoriesData = z.object({
  body: z.never().optional(),
  path: z.never().optional(),
  query: z.never().optional(),
});

/**
 * OK
 */
export const zGetRootCategoriesResponse = zApiResponseListCategory;

export const zGetOrderData = z.object({
  body: z.never().optional(),
  path: z.object({
    orderId: z.string().describe('Medusa order identifier'),
  }),
  query: z.never().optional(),
});

/**
 * Order retrieved
 */
export const zGetOrderResponse = zOrderResponse;

export const zListCatalogItemsData = z.object({
  body: z.never().optional(),
  path: z.never().optional(),
  query: z
    .object({
      active_only: z.boolean().optional(),
    })
    .optional(),
});

/**
 * OK
 */
export const zListCatalogItemsResponse = zApiResponseListCommerceCatalogItem;

export const zGetByCourseData = z.object({
  body: z.never().optional(),
  path: z.object({
    courseUuid: z.string().uuid(),
  }),
  query: z.never().optional(),
});

/**
 * OK
 */
export const zGetByCourseResponse = zApiResponseCommerceCatalogItem;

export const zGetByClassData = z.object({
  body: z.never().optional(),
  path: z.object({
    classUuid: z.string().uuid(),
  }),
  query: z.never().optional(),
});

/**
 * OK
 */
export const zGetByClassResponse = zApiResponseCommerceCatalogItem;

export const zPreviewRecurringClassScheduleData = z.object({
  body: z.never().optional(),
  path: z.object({
    uuid: z.string().uuid().describe('UUID of the class definition to preview'),
  }),
  query: z.object({
    startDate: z.string().date().describe('Date to start preview from (YYYY-MM-DD)'),
    endDate: z
      .string()
      .date()
      .describe('Date to stop preview (optional, uses pattern end date if not provided)')
      .optional(),
  }),
});

/**
 * Schedule preview generated successfully
 */
export const zPreviewRecurringClassScheduleResponse = zApiResponseListScheduledInstance;

export const zCheckClassSchedulingConflictsData = z.object({
  body: z.never().optional(),
  path: z.object({
    uuid: z.string().uuid().describe('UUID of the class definition to check'),
  }),
  query: z.object({
    startDate: z.string().date().describe('Date to start checking from (YYYY-MM-DD)'),
    endDate: z.string().date().describe('Date to stop checking (optional)').optional(),
  }),
});

/**
 * Conflict check completed
 */
export const zCheckClassSchedulingConflictsResponse = zApiResponseListScheduledInstance;

export const zGetClassDefinitionsForOrganisationData = z.object({
  body: z.never().optional(),
  path: z.object({
    organisationUuid: z.string().uuid().describe('UUID of the organisation'),
  }),
  query: z.never().optional(),
});

/**
 * Class definitions retrieved successfully
 */
export const zGetClassDefinitionsForOrganisationResponse = zApiResponseListClassDefinition;

export const zGetClassDefinitionsForInstructorData = z.object({
  body: z.never().optional(),
  path: z.object({
    instructorUuid: z.string().uuid().describe('UUID of the instructor'),
  }),
  query: z
    .object({
      activeOnly: z
        .boolean()
        .describe('Whether to include only active class definitions')
        .optional()
        .default(false),
    })
    .optional(),
});

/**
 * Class definitions retrieved successfully
 */
export const zGetClassDefinitionsForInstructorResponse = zApiResponseListClassDefinition;

export const zGetClassDefinitionsForCourseData = z.object({
  body: z.never().optional(),
  path: z.object({
    courseUuid: z.string().uuid().describe('UUID of the course'),
  }),
  query: z
    .object({
      activeOnly: z
        .boolean()
        .describe('Whether to include only active class definitions')
        .optional()
        .default(false),
    })
    .optional(),
});

/**
 * Class definitions retrieved successfully
 */
export const zGetClassDefinitionsForCourseResponse = zApiResponseListClassDefinition;

export const zGetAllActiveClassDefinitionsData = z.object({
  body: z.never().optional(),
  path: z.never().optional(),
  query: z.never().optional(),
});

/**
 * Active class definitions retrieved successfully
 */
export const zGetAllActiveClassDefinitionsResponse = zApiResponseListClassDefinition;

export const zVerifyCertificateData = z.object({
  body: z.never().optional(),
  path: z.object({
    certificateNumber: z.string(),
  }),
  query: z.never().optional(),
});

/**
 * Certificate verification result
 */
export const zVerifyCertificateResponse = zApiResponseBoolean;

export const zSearchCertificateTemplatesData = z.object({
  body: z.never().optional(),
  path: z.never().optional(),
  query: z.object({
    searchParams: z.record(z.unknown()).describe('Optional search parameters for filtering'),
    pageable: zPageable,
  }),
});

/**
 * OK
 */
export const zSearchCertificateTemplatesResponse = zApiResponsePagedDtoCertificateTemplate;

export const zGetStudentCertificatesData = z.object({
  body: z.never().optional(),
  path: z.object({
    studentUuid: z.string().uuid(),
  }),
  query: z.never().optional(),
});

/**
 * OK
 */
export const zGetStudentCertificatesResponse = zApiResponseListCertificate;

export const zGetDownloadableCertificatesData = z.object({
  body: z.never().optional(),
  path: z.object({
    studentUuid: z.string().uuid(),
  }),
  query: z.never().optional(),
});

/**
 * OK
 */
export const zGetDownloadableCertificatesResponse = zApiResponseListCertificate;

export const zSearchCertificatesData = z.object({
  body: z.never().optional(),
  path: z.never().optional(),
  query: z.object({
    searchParams: z.record(z.unknown()).describe('Optional search parameters for filtering'),
    pageable: zPageable,
  }),
});

/**
 * OK
 */
export const zSearchCertificatesResponse = zApiResponsePagedDtoCertificate;

export const zGetRevokedCertificatesData = z.object({
  body: z.never().optional(),
  path: z.never().optional(),
  query: z.never().optional(),
});

/**
 * OK
 */
export const zGetRevokedCertificatesResponse = zApiResponseListCertificate;

export const zGetProgramCertificates1Data = z.object({
  body: z.never().optional(),
  path: z.never().optional(),
  query: z.never().optional(),
});

/**
 * OK
 */
export const zGetProgramCertificates1Response = zApiResponseListCertificate;

export const zGetCertificateByNumberData = z.object({
  body: z.never().optional(),
  path: z.object({
    certificateNumber: z.string(),
  }),
  query: z.never().optional(),
});

/**
 * OK
 */
export const zGetCertificateByNumberResponse = zApiResponseCertificate;

export const zGetCourseCertificatesData = z.object({
  body: z.never().optional(),
  path: z.never().optional(),
  query: z.never().optional(),
});

/**
 * OK
 */
export const zGetCourseCertificatesResponse = zApiResponseListCertificate;

export const zGetAssignmentSubmissionsData = z.object({
  body: z.never().optional(),
  path: z.object({
    assignmentUuid: z.string().uuid(),
  }),
  query: z.never().optional(),
});

/**
 * OK
 */
export const zGetAssignmentSubmissionsResponse = zApiResponseListAssignmentSubmission;

export const zGetHighPerformanceSubmissionsData = z.object({
  body: z.never().optional(),
  path: z.object({
    assignmentUuid: z.string().uuid(),
  }),
  query: z.never().optional(),
});

/**
 * OK
 */
export const zGetHighPerformanceSubmissionsResponse = zApiResponseListAssignmentSubmission;

export const zGetAverageScoreData = z.object({
  body: z.never().optional(),
  path: z.object({
    assignmentUuid: z.string().uuid(),
  }),
  query: z.never().optional(),
});

/**
 * OK
 */
export const zGetAverageScoreResponse = zApiResponseDouble;

export const zGetSubmissionAnalyticsData = z.object({
  body: z.never().optional(),
  path: z.object({
    assignmentUuid: z.string().uuid(),
  }),
  query: z.never().optional(),
});

/**
 * OK
 */
export const zGetSubmissionAnalyticsResponse = zApiResponseMapStringLong;

export const zSearchSubmissionsData = z.object({
  body: z.never().optional(),
  path: z.never().optional(),
  query: z.object({
    searchParams: z.record(z.unknown()).describe('Optional search parameters for filtering'),
    pageable: zPageable,
  }),
});

/**
 * OK
 */
export const zSearchSubmissionsResponse = zApiResponsePagedDtoAssignmentSubmission;

export const zSearchAssignmentsData = z.object({
  body: z.never().optional(),
  path: z.never().optional(),
  query: z.object({
    searchParams: z.record(z.unknown()).describe('Optional search parameters for filtering'),
    pageable: zPageable,
  }),
});

/**
 * OK
 */
export const zSearchAssignmentsResponse = zApiResponsePagedDtoAssignment;

export const zGetPendingGradingData = z.object({
  body: z.never().optional(),
  path: z.object({
    instructorUuid: z.string().uuid(),
  }),
  query: z.never().optional(),
});

/**
 * OK
 */
export const zGetPendingGradingResponse = zApiResponseListAssignmentSubmission;

export const zIsUserSystemAdminData = z.object({
  body: z.never().optional(),
  path: z.object({
    uuid: z.string().uuid().describe('UUID of the user to check for system admin privileges'),
  }),
  query: z.never().optional(),
});

/**
 * System admin status check completed
 */
export const zIsUserSystemAdminResponse = zApiResponseBoolean;

export const zIsUserAdminData = z.object({
  body: z.never().optional(),
  path: z.object({
    uuid: z.string().uuid().describe('UUID of the user to check for admin privileges'),
  }),
  query: z.never().optional(),
});

/**
 * Admin status check completed
 */
export const zIsUserAdminResponse = zApiResponseBoolean;

export const zGetSystemAdminUsersData = z.object({
  body: z.never().optional(),
  path: z.never().optional(),
  query: z.object({
    pageable: zPageable,
  }),
});

/**
 * System admin users retrieved successfully
 */
export const zGetSystemAdminUsersResponse = zApiResponsePagedDtoUser;

export const zGetOrganizationAdminUsersData = z.object({
  body: z.never().optional(),
  path: z.never().optional(),
  query: z.object({
    pageable: zPageable,
  }),
});

/**
 * Organization admin users retrieved successfully
 */
export const zGetOrganizationAdminUsersResponse = zApiResponsePagedDtoUser;

export const zGetAdminEligibleUsersData = z.object({
  body: z.never().optional(),
  path: z.never().optional(),
  query: z.object({
    search: z.string().describe('Optional search term to filter users by name or email').optional(),
    pageable: zPageable,
  }),
});

/**
 * Eligible users retrieved successfully
 */
export const zGetAdminEligibleUsersResponse = zApiResponsePagedDtoUser;

export const zGetAdminUsersData = z.object({
  body: z.never().optional(),
  path: z.never().optional(),
  query: z.object({
    filters: z.record(z.unknown()).describe('Optional filters for admin user search'),
    pageable: zPageable,
  }),
});

/**
 * Admin users retrieved successfully
 */
export const zGetAdminUsersResponse = zApiResponsePagedDtoUser;

export const zIsOrganisationVerifiedData = z.object({
  body: z.never().optional(),
  path: z.object({
    uuid: z.string().uuid().describe('UUID of the organization to check verification status for.'),
  }),
  query: z.never().optional(),
});

/**
 * Verification status check completed
 */
export const zIsOrganisationVerifiedResponse = zApiResponseBoolean;

export const zIsInstructorVerifiedData = z.object({
  body: z.never().optional(),
  path: z.object({
    uuid: z.string().uuid().describe('UUID of the instructor to check verification status for.'),
  }),
  query: z.never().optional(),
});

/**
 * Verification status check completed
 */
export const zIsInstructorVerifiedResponse = zApiResponseBoolean;

export const zGetDashboardStatisticsData = z.object({
  body: z.never().optional(),
  path: z.never().optional(),
  query: z.never().optional(),
});

/**
 * Dashboard statistics retrieved successfully
 */
export const zGetDashboardStatisticsResponse = zApiResponseAdminDashboardStats;

export const zCancelInvitationData = z.object({
  body: z.never().optional(),
  path: z.object({
    uuid: z
      .string()
      .uuid()
      .describe(
        'UUID of the organization that owns the invitation. Must be an existing organization.'
      ),
    invitationUuid: z
      .string()
      .uuid()
      .describe(
        "UUID of the invitation to cancel. Must be a pending invitation that hasn't been accepted, declined, or expired."
      ),
  }),
  query: z.object({
    canceller_uuid: z
      .string()
      .uuid()
      .describe(
        'UUID of the user requesting to cancel the invitation. Must be either the original inviter or an administrator of the organization.'
      ),
  }),
});

/**
 * Invitation cancelled successfully
 */
export const zCancelInvitationResponse = zApiResponseVoid;

export const zCleanupOldInvitationsData = z.object({
  body: z.never().optional(),
  path: z.never().optional(),
  query: z
    .object({
      daysOld: z
        .number()
        .int()
        .describe('Delete invitations older than this many days. Default is 90 days.')
        .optional()
        .default(90),
    })
    .optional(),
});

/**
 * Old invitations cleaned up successfully
 */
export const zCleanupOldInvitationsResponse = zApiResponseInteger;

export const zDissociateRubricData = z.object({
  body: z.never().optional(),
  path: z.object({
    courseUuid: z.string().uuid().describe('UUID of the course'),
    rubricUuid: z.string().uuid().describe('UUID of the rubric to dissociate'),
  }),
  query: z.never().optional(),
});

/**
 * OK
 */
export const zDissociateRubricResponse = zApiResponseVoid;

export const zDissociateRubricByContextData = z.object({
  body: z.never().optional(),
  path: z.object({
    courseUuid: z.string().uuid().describe('UUID of the course'),
    rubricUuid: z.string().uuid().describe('UUID of the rubric to dissociate'),
    context: z.string().describe('Usage context of the association to remove'),
  }),
  query: z.never().optional(),
});

/**
 * OK
 */
export const zDissociateRubricByContextResponse = zApiResponseVoid;

export const zRemoveCategoryFromCourseData = z.object({
  body: z.never().optional(),
  path: z.object({
    courseUuid: z.string().uuid(),
    categoryUuid: z.string().uuid(),
  }),
  query: z.never().optional(),
});

/**
 * OK
 */
export const zRemoveCategoryFromCourseResponse = zApiResponseString;

export const zRemoveAdminDomainData = z.object({
  body: z.never().optional(),
  path: z.object({
    uuid: z.string().uuid().describe('UUID of the user to remove admin domain from'),
    domain: zSchemaEnum2,
  }),
  query: z
    .object({
      reason: z.string().describe('Reason for removing admin privileges').optional(),
    })
    .optional(),
});

/**
 * Admin domain removed successfully
 */
export const zRemoveAdminDomainResponse = zApiResponseUser;
