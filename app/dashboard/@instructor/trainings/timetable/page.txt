'use client';

import { useMutation, useQuery, useQueryClient } from '@tanstack/react-query';
import moment from 'moment';
import { useRouter } from 'next/navigation';
import { useEffect, useState } from 'react';
import { Calendar as BigCalendar, momentLocalizer, Views } from 'react-big-calendar';
import 'react-big-calendar/lib/css/react-big-calendar.css';

import {
    deactivateClassDefinitionMutation,
    getClassDefinitionsForInstructorOptions,
    getClassDefinitionsForInstructorQueryKey
} from '@/services/client/@tanstack/react-query.gen';

import DeleteModal from '@/components/custom-modals/delete-modal';
import HTMLTextPreview from '@/components/editors/html-text-preview';
import PageLoader from '@/components/page-loader';
import { Badge } from '@/components/ui/badge';
import { Button } from '@/components/ui/button';
import {
    DropdownMenu,
    DropdownMenuContent,
    DropdownMenuItem,
    DropdownMenuSeparator,
    DropdownMenuTrigger,
} from '@/components/ui/dropdown-menu';
import { useInstructor } from '@/context/instructor-context';

import {
    Calendar as CalendarIcon,
    EyeIcon,
    LucideFileWarning,
    MoreVertical,
    PenIcon,
    PlusIcon
} from 'lucide-react';
import Link from 'next/link';
import { toast } from 'sonner';
import { getClassRecurrencePattern } from '../../../../../services/client';
import { ClassDialog, ScheduleDialog } from '../../_components/class-management-form';
import { RecurrenceDaysCell, RecurrencePatternCell } from '../component/recurring-patterns';

const localizer = momentLocalizer(moment);

const dayToIndex = {
    SUNDAY: 0, MONDAY: 1, TUESDAY: 2, WEDNESDAY: 3, THURSDAY: 4, FRIDAY: 5, SATURDAY: 6
};

// Helper: generate weekly recurring events
function generateRecurringEvents(classDef: any, recurrence: any): any[] {
    const {
        recurrence_type,
        interval_value,
        days_of_week,
        end_date,
        occurrence_count,
        is_indefinite,
    } = recurrence;

    const events: any[] = [];

    const startTime = classDef.default_start_time; // e.g. "09:00:00"
    const endTime = classDef.default_end_time;     // e.g. "10:30:00"

    const startDate = moment(); // or use class start date if available
    const finalDate = moment(end_date);
    let currentDate = startDate.clone();

    let count = 0;

    const allowedDays = days_of_week?.split(',') || [];

    while (currentDate.isSameOrBefore(finalDate)) {
        // DAILY: just increment by interval regardless of day
        if (recurrence_type === 'DAILY') {
            const start = moment(`${currentDate.format('YYYY-MM-DD')}T${startTime}`);
            const end = moment(`${currentDate.format('YYYY-MM-DD')}T${endTime}`);

            events.push({
                title: classDef.title,
                start: start.toDate(),
                end: end.toDate(),
                resource: {
                    location: classDef.location_type,
                    instructor: classDef.instructor_name,
                },
            });

            count++;
            if (!is_indefinite && occurrence_count && count >= occurrence_count) break;

            currentDate.add(interval_value, 'days');
        }

        // WEEKLY: only on allowed weekdays
        if (recurrence_type === 'WEEKLY') {
            const dayName = currentDate.format('dddd').toUpperCase(); // e.g., "MONDAY"

            if (allowedDays.includes(dayName)) {
                const start = moment(`${currentDate.format('YYYY-MM-DD')}T${startTime}`);
                const end = moment(`${currentDate.format('YYYY-MM-DD')}T${endTime}`);

                events.push({
                    title: classDef.title,
                    start: start.toDate(),
                    end: end.toDate(),
                    resource: {
                        location: classDef.location_type,
                        instructor: classDef.instructor_name,
                    },
                });

                count++;
                if (!is_indefinite && occurrence_count && count >= occurrence_count) break;
            }

            currentDate.add(1, 'day'); // check next day until endDate
        }

        // Add monthly / others if needed
    }

    return events;
}


export default function TrainingsPage() {
    const router = useRouter();
    const qc = useQueryClient();
    const instructor = useInstructor();

    const [openAddClass, setOpenAddClass] = useState(false);
    const [editingClassId, setEditingClassId] = useState<string | null>(null);
    const [scheduleModal, setScheduleModal] = useState(false);
    const [deleteModal, setDeleteModal] = useState(false);
    const [deleteId, setDeleteId] = useState<string | null>(null);
    const [mode, setMode] = useState<'cards' | 'calendar'>('cards');

    const [calendarDate, setCalendarDate] = useState(new Date());
    const [calendarView, setCalendarView] = useState(Views.MONTH);
    const [calendarEvents, setCalendarEvents] = useState<any[]>([]);

    const { data, isLoading } = useQuery(
        getClassDefinitionsForInstructorOptions({
            path: { instructorUuid: instructor?.uuid as string },
            query: { activeOnly: false },
        })
    );
    const classes = data?.data || [];

    const openRecurrentSchedule = (id: any) => {
        setEditingClassId(id);
        setScheduleModal(true);
    };

    const openDeleteModal = (id: any) => {
        setDeleteId(id);
        setDeleteModal(true);
    };

    const deactivateClass = useMutation(deactivateClassDefinitionMutation());
    const confirmDelete = () => {
        deactivateClass.mutate({ path: { uuid: deleteId as string } }, {
            onSuccess: (data) => {
                qc.invalidateQueries({
                    queryKey: getClassDefinitionsForInstructorQueryKey({ path: { instructorUuid: instructor?.uuid as string } }),
                });
                setDeleteModal(false);
                toast.message(data?.message || `Class definition deactivated successfully`);
            }
        });
    };

    // Fetch recurrence data dynamically
    useEffect(() => {
        const loadEvents = async () => {
            const allEvents: any[] = [];

            for (const cl of classes) {
                try {
                    const { data: recurrence } = await getClassRecurrencePattern({
                        path: { uuid: cl.recurrence_pattern_uuid as string },
                    });

                    if (recurrence) {
                        console.log(recurrence, "recurrence")
                        const events = generateRecurringEvents(cl, recurrence);
                        allEvents.push(...events);
                    }
                } catch (err) {
                    console.error('Error fetching recurrence for class:', cl.title, err);
                }
            }

            console.log(allEvents, "all events")

            setCalendarEvents(allEvents);
        };

        if (mode === 'calendar' && classes.length > 0) {
            loadEvents();
        }
    }, [mode, classes]);

    console.log(calendarEvents, "cal event")

    return (
        <div className='space-y-6'>
            <div className='mb-6 flex items-end justify-between'>
                <div>
                    <h1 className='text-2xl font-semibold'>Your Classes</h1>
                    <p className='text-muted-foreground mt-1 text-base'>You have {classes?.length} classes</p>
                </div>
                <div className='flex gap-2'>
                    <Button variant={mode === 'cards' ? 'default' : 'outline'} onClick={() => setMode('cards')}>
                        Card View
                    </Button>
                    <Button variant={mode === 'calendar' ? 'default' : 'outline'} onClick={() => setMode('calendar')}>
                        Calendar View
                    </Button>
                    <Button onClick={() => router.push(`/dashboard/trainings/create-new`)}>
                        <PlusIcon className='mr-1 h-4 w-4' />
                        New Class
                    </Button>
                </div>
            </div>

            {isLoading ? (
                <PageLoader />
            ) : mode === 'cards' ? (
                <div className='grid grid-cols-1 gap-4 lg:grid-cols-2'>
                    {classes?.map((cl: any) => (
                        <div
                            key={cl.uuid}
                            className='relative min-h-[250px] rounded-lg border bg-white p-5 shadow-sm transition hover:shadow-md'
                        >
                            {/* Actions dropdown */}
                            <div className='absolute top-2 right-2'>
                                <DropdownMenu>
                                    <DropdownMenuTrigger asChild>
                                        <Button variant='ghost' size='icon' aria-label='Open menu'>
                                            <MoreVertical className='h-4 w-4' />
                                        </Button>
                                    </DropdownMenuTrigger>
                                    <DropdownMenuContent align='end'>
                                        <DropdownMenuItem asChild>
                                            <Link href={`/dashboard/trainings/preview/${cl.uuid}`} className='flex w-full items-center'>
                                                <EyeIcon className='mr-2 h-4 w-4' />
                                                Preview
                                            </Link>
                                        </DropdownMenuItem>
                                        <DropdownMenuItem asChild>
                                            <div onClick={() => router.push(`/dashboard/trainings/create-new?id=${cl.uuid}`)} className='flex w-full items-center'>
                                                <PenIcon className='mr-2 h-4 w-4' />
                                                Edit Class
                                            </div>
                                        </DropdownMenuItem>
                                        <DropdownMenuItem variant='default' onClick={() => openRecurrentSchedule(cl.uuid)}>
                                            <CalendarIcon className='mr-2 h-4 w-4' />
                                            Schedule Recurring
                                        </DropdownMenuItem>
                                        <DropdownMenuSeparator />
                                        <DropdownMenuItem variant='destructive' onClick={() => openDeleteModal(cl.uuid)}>
                                            <LucideFileWarning className='mr-2 h-4 w-4' />
                                            Deactivate
                                        </DropdownMenuItem>
                                    </DropdownMenuContent>
                                </DropdownMenu>
                            </div>

                            <h3 className='pr-6 text-lg font-semibold'>{cl.title}</h3>
                            <div className='text-muted-foreground mb-1 line-clamp-2 text-sm'>
                                <HTMLTextPreview htmlContent={cl?.description as string} />
                            </div>

                            <div className='mb-2 flex justify-end'>
                                <Badge>{cl.is_active ? 'Active' : 'Inactive'}</Badge>
                            </div>

                            <ul className='space-y-2.5 text-sm'>
                                <li>
                                    <strong>üìÖ Days:</strong>{' '}
                                    <RecurrenceDaysCell recurrenceUuid={cl.recurrence_pattern_uuid} />
                                </li>
                                <li>
                                    <strong>üïí Time:</strong> {cl.default_start_time} - {cl.default_end_time}
                                </li>
                                <li>
                                    <strong>üìç Location:</strong> {cl.location_type}
                                </li>
                                <li>
                                    <strong>üîÅ Recurrence:</strong>{' '}
                                    <RecurrencePatternCell recurrenceUuid={cl.recurrence_pattern_uuid} />
                                </li>
                                <li>
                                    <strong>üë• Participants:</strong> {cl.max_participants}
                                </li>
                            </ul>
                        </div>
                    ))}
                </div>
            ) : (
                <div>
                    <div className="mb-4 flex gap-2">
                        <Button variant="outline" onClick={() => setCalendarDate(new Date())}>
                            Today
                        </Button>
                        <Button
                            variant="outline"
                            onClick={() => setCalendarDate(moment(calendarDate).subtract(1, calendarView).toDate())}
                        >
                            Previous
                        </Button>
                        <Button
                            variant="outline"
                            onClick={() => setCalendarDate(moment(calendarDate).add(1, calendarView).toDate())}
                        >
                            Next
                        </Button>
                    </div>

                    <BigCalendar
                        localizer={localizer}
                        events={calendarEvents}
                        startAccessor="start"
                        endAccessor="end"
                        date={calendarDate}
                        view={calendarView}
                        onNavigate={(date) => setCalendarDate(date)}
                        onView={(view) => setCalendarView(view as any)}
                        views={[Views.MONTH, Views.WEEK, Views.DAY]}
                        style={{ height: 600 }}
                    />
                </div>
            )}

            <ClassDialog isOpen={openAddClass} setOpen={setOpenAddClass} onCancel={() => setOpenAddClass(false)} />
            <ScheduleDialog
                isOpen={scheduleModal}
                setOpen={setScheduleModal}
                editingClassId={editingClassId as string}
                onCancel={() => setScheduleModal(false)}
            />
            <DeleteModal
                open={deleteModal}
                setOpen={setDeleteModal}
                title="Deactivate Class"
                description="Are you sure you want to deactivate this class? Don't worry, you can reactivate the class later."
                onConfirm={confirmDelete}
                isLoading={deactivateClass.isPending}
                confirmText="Deactivate Class"
            />
        </div>
    );
}
