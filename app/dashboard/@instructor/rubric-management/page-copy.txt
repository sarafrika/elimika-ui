'use client';

import DeleteModal from '@/components/custom-modals/delete-modal';
import {
  Accordion,
  AccordionContent,
  AccordionItem,
  AccordionTrigger,
} from '@/components/ui/accordion';
import { Button } from '@/components/ui/button';
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuSeparator,
  DropdownMenuTrigger,
} from '@/components/ui/dropdown-menu';
import { useBreadcrumb } from '@/context/breadcrumb-provider';
import { useInstructor } from '@/context/instructor-context';
import {
  deleteAssessmentRubricMutation,
  deleteRubricCriterionMutation,
  deleteRubricScoringMutation,
  deleteScoringLevelMutation,
  getRubricCriteriaQueryKey,
  getRubricMatrixQueryKey,
  getRubricScoringQueryKey,
  getScoringLevelsByRubricQueryKey,
  searchAssessmentRubricsQueryKey
} from '@/services/client/@tanstack/react-query.gen';
import { useMutation, useQueryClient } from '@tanstack/react-query';
import isEqual from 'lodash.isequal';
import { CirclePlus, DiamondPlus, EllipsisVertical, Grip, LayoutGridIcon, ListIcon, PenIcon, PlusIcon, TrashIcon } from 'lucide-react';
import { useEffect, useMemo, useState } from 'react';
import { toast } from 'sonner';
import {
  CriteriaDialog,
  RubricCriteriaFormValues,
  RubricDetailsFormValues,
  RubricDialog,
  RubricScoringFormValues,
  ScoringDialog,
  ScoringLevelDialog,
  ScoringLevelFormValues,
} from '../_components/new-rubric-form';
import { Visibility } from '../_components/rubric-management-form';
import { useRubricsWithCriteriaAndScoring } from './rubric-chaining';
import RubricTable from './rubric-table-render';

export default function RubricsCreationPage() {
  const qc = useQueryClient();
  const instructor = useInstructor();
  const { replaceBreadcrumbs } = useBreadcrumb();

  const [viewMode, setViewMode] = useState<'list' | 'grid'>('grid');


  useEffect(() => {
    replaceBreadcrumbs([
      { id: 'dashboard', title: 'Dashboard', url: '/dashboard/overview' },
      {
        id: 'course-management',
        title: 'Course Management',
        url: '/dashboard/course-management/drafts',
      },
      {
        id: 'rubrics',
        title: 'Rubrics',
        url: `/dashboard/course-management/add-rubrics?`,
        isLast: true,
      },
    ]);
  }, [replaceBreadcrumbs]);

  const [isCreateModalOpen, setIsCreateModalOpen] = useState(false);
  const openCreateRubricModal = () => setIsCreateModalOpen(true);

  const [isCriterionModalOpen, setIsCriterionModalOpen] = useState(false);
  const [isScoringModalOpen, setIsScoringModalOpen] = useState(false);
  const [isScoringLevelModalOpen, setIsScoringLevelModalOpen] = useState(false);

  const {
    rubricsWithDetails,
    isLoading: rubricDataIsLoading,
    isFetched: rubricsDataIsFetched,
  } = useRubricsWithCriteriaAndScoring(instructor?.uuid);

  const memoizedRubricsWithDetails = useMemo(() => {
    return rubricsWithDetails || [];
  }, [rubricsWithDetails]);

  const [rubrics, setRubrics] = useState(memoizedRubricsWithDetails);

  useEffect(() => {
    if (!rubricDataIsLoading && !isEqual(memoizedRubricsWithDetails, rubrics)) {
      setRubrics(memoizedRubricsWithDetails);
    }
  }, [memoizedRubricsWithDetails, rubricDataIsLoading]);

  const [editingRubric, setEditingRubric] = useState<RubricDetailsFormValues | null>(null);
  const [editingCriterion, setEditingCriterion] = useState<RubricCriteriaFormValues | null>(null);
  const [editingScoringLevel, setEditingScoringLevel] = useState<ScoringLevelFormValues | null>(null);
  const [editingScoring, setEditingScoring] = useState<RubricScoringFormValues | null>(null);

  const [editingRubricId, setEditingRubricId] = useState<string | null>(null);
  const [editingCriterionId, setEditingCriterionId] = useState<string | null>(null);
  const [editingScoringId, setEditingScoringId] = useState<string | null>(null);
  const [editingScoringLevelId, setEditingScoringLevelId] = useState<string | null>(null);


  const openEditModal = (rubricId: string) => {
    const rubricItem = rubrics.find(r => r.rubric.uuid === rubricId);
    if (!rubricItem) return;

    const rubric = rubricItem.rubric;

    setEditingRubric({
      title: rubric.title,
      description: rubric.description,
      type: rubric.rubric_type,
      visibility: rubric.is_public ? Visibility.Public : Visibility.Private,
      total_weight: rubric.total_weight,
      max_score: rubric.max_score,
      min_passing_score: rubric.min_passing_score,
    });
    setEditingRubricId(rubricId);
    setIsCreateModalOpen(true);
  };

  const handleAddCriteria = (rubricId: string) => {
    const rubricItem = rubrics.find(r => r.rubric.uuid === rubricId);
    if (!rubricItem) return;

    setEditingCriterion(null);
    setEditingCriterionId(null);

    setEditingRubricId(rubricId);
    setIsCriterionModalOpen(true);
  };

  const handleAddScoringLevel = (rubricId: string) => {
    const rubricItem = rubrics.find(r => r.rubric.uuid === rubricId);
    if (!rubricItem) return;

    setEditingScoringLevel(null);
    setEditingScoringLevelId(null);

    setEditingRubricId(rubricId);
    setIsScoringLevelModalOpen(true);
  }


  const handleEditCriterion = (rubricId: string, criterionId: string) => {
    const rubricItem = rubrics.find(r => r.rubric.uuid === rubricId);
    if (!rubricItem) return;

    const criteria = rubricItem.criteria ?? [];
    const selectedCriterion = criteria.find(c => c.uuid === criterionId);
    if (!selectedCriterion) return;

    setEditingCriterion({
      uuid: selectedCriterion.uuid,
      component_name: selectedCriterion.component_name,
      description: selectedCriterion.description,
      weight: selectedCriterion.weight,
      display_order: selectedCriterion.display_order,
      is_primary_criteria: selectedCriterion.is_primary_criteria,
      criteria_number: selectedCriterion.criteria_number,
    });

    setEditingRubricId(rubricId);
    setEditingCriterionId(criterionId);
    setIsCriterionModalOpen(true);
  };

  const handleAddScore = (rubricId: string, criterionId: string) => {
    const rubricItem = rubrics.find(r => r.rubric.uuid === rubricId);
    if (!rubricItem) return;

    // ðŸ§¹ Clear any previous editing state
    setEditingScoring(null);
    setEditingScoringId(null);

    setEditingRubricId(rubricId);
    setEditingCriterionId(criterionId);
    setIsScoringModalOpen(true);
  };


  const handleEditCriteriaScoring = (rubricId: string, cell: any) => {
    // console.log(rubricId, "rub id")
    // console.log(cell, "ccell deets")

    const rubricItem = rubrics.find(r => r.rubric.uuid === rubricId);
    if (!rubricItem) return;

    // setEditingScoring({
    //   scoring_uuid: selectedScoring.uuid,
    //   name: selectedScoring.performance_expectation || '',
    //   description: selectedScoring.description || '',
    //   points: parseInt(selectedScoring.score_range || '0'),
    //   grading_level_uuid: selectedScoring.grading_level_uuid || '',
    //   is_passing_level: selectedScoring.is_passing_level,
    //   performance_expectation: selectedScoring.performance_expectation,
    //   feedback_category: selectedScoring.feedback_category,
    // });

    setEditingRubricId(rubricId);
    // setEditingCriterionId(criterionId);
    // setEditingScoringId(scoringId);
    setIsScoringModalOpen(true);
  };


  const handleEditScoringLevel = (rubricId: any, level: any) => {

    setEditingScoringLevel({
      rubric_uuid: level.rubric_uuid,
      name: level.name,
      description: level.description || '',
      points: level.points,
      level_order: level.level_order,
      color_code: level.color_code,
      is_passing: level.is_passing,
      display_name: `${level.name} (${level.points} pts)`,
      performance_indicator: level.performance_indicator,
    });

    setEditingRubricId(rubricId);
    setEditingScoringLevelId(level.uuid);
    setIsScoringLevelModalOpen(true);
  };

  const [rubricToDelete, setRubricToDelete] = useState<string | null>(null);
  const [criterionToDelete, setCriterionToDelete] = useState<string | null>(null);
  const [scoringLevelToDelete, setScoringLevelToDelete] = useState<string | null>(null);
  const [scoringToDelete, setScoringToDelete] = useState<string | null>(null);

  const [deleteModalOpen, setDeleteModalOpen] = useState(false);
  const [deleteCriteriaModalOpen, setDeleteCriteriaModalOpen] = useState(false);
  const [deleteScoringLevelModalOpen, setDeleteScoringLevelModalOpen] = useState(false);
  const [deleteScoringModalOpen, setDeleteScoringModalOpen] = useState(false);


  const handleAskDeleteRubric = (rubricId: string) => {
    setRubricToDelete(rubricId);
    setDeleteModalOpen(true);
  };

  const handleAskDeleteCriterion = (rubricId: string, criterionId: string) => {
    setRubricToDelete(rubricId);
    setCriterionToDelete(criterionId);
    setDeleteCriteriaModalOpen(true);
  };

  const handleAskDeleteCriteriaScoring = (rubricId: string, cell: any) => {
    setRubricToDelete(rubricId);
    // setCriterionToDelete(criterionId);
    // setScoringToDelete(scoringId);
    setDeleteScoringModalOpen(true);
  };

  const handleAskDeleteScoringLevel = (rubricId: string, levelId: string) => {
    setRubricToDelete(rubricId);
    setScoringLevelToDelete(levelId);
    setDeleteScoringLevelModalOpen(true);
  };

  const deleteRubric = useMutation(deleteAssessmentRubricMutation());
  const confirmDeleteRubric = () => {
    if (!rubricToDelete) return;
    // Optimistic UI update
    setRubrics(prev => prev.filter(r => r.rubric.uuid !== rubricToDelete));

    deleteRubric.mutate(
      { path: { uuid: rubricToDelete } },
      {
        onSuccess: () => {
          qc.invalidateQueries({
            queryKey: searchAssessmentRubricsQueryKey({
              query: {
                searchParams: { instructor_uuid_eq: instructor?.uuid as string },
                pageable: {},
              },
            }),
          });
          qc.invalidateQueries({
            queryKey: getRubricMatrixQueryKey({ path: { rubricUuid: rubricToDelete } }),
          });
          toast.success('Rubric deleted successfully.');
        },
        onError: () => {
          toast.error('Failed to delete rubric.');
        },
        onSettled: () => {
          setDeleteModalOpen(false);
          setRubricToDelete(null);
        },
      }
    );
  };

  const deleteRubricCriterion = useMutation(deleteRubricCriterionMutation());
  const confirmDeleteCriterion = () => {
    if (!rubricToDelete || !criterionToDelete) return;

    // Optimistic UI update
    setRubrics(prev =>
      prev.map(rubricGroup => {
        if (rubricGroup.rubric.uuid === rubricToDelete) {
          return {
            ...rubricGroup,
            criteria: rubricGroup.criteria.filter(
              criterion => criterion.uuid !== criterionToDelete
            ),
          };
        }
        return rubricGroup;
      })
    );

    deleteRubricCriterion.mutate(
      {
        path: { rubricUuid: rubricToDelete, criteriaUuid: criterionToDelete },
      },
      {
        onSuccess: () => {
          qc.invalidateQueries({
            queryKey: getRubricCriteriaQueryKey({
              path: { rubricUuid: rubricToDelete },
              query: { pageable: {} },
            }),
          });
          qc.invalidateQueries({
            queryKey: getRubricMatrixQueryKey({ path: { rubricUuid: rubricToDelete } }),
          });
          toast.success('Rubric criterion deleted successfully.');
        },
        onError: () => {
          toast.error('Failed to delete rubric criterion.');
        },
        onSettled: () => {
          setDeleteCriteriaModalOpen(false);
          setRubricToDelete(null);
          setCriterionToDelete(null);
        },
      }
    );
  };

  const deleteRubricScoringLevel = useMutation(deleteScoringLevelMutation());
  const confirmDeleteScoringLevel = () => {
    if (!rubricToDelete || !scoringLevelToDelete) return;

    // Optimistic UI update
    setRubrics(prev =>
      prev.map(rubricGroup => {
        if (rubricGroup.rubric.uuid !== rubricToDelete) return rubricGroup;

        return {
          ...rubricGroup,
          criteria: rubricGroup.criteria.map(criterion => {
            if (criterion.uuid !== criterionToDelete) return criterion;

            return {
              ...criterion,
              scoring: criterion.scoring.filter((s: any) => s.uuid !== scoringToDelete),
            };
          }),
        };
      })
    );

    deleteRubricScoringLevel.mutate(
      {
        path: {
          rubricUuid: rubricToDelete,
          levelUuid: scoringLevelToDelete as string,
        },
      },
      {
        onSuccess: () => {
          qc.invalidateQueries({
            queryKey: getScoringLevelsByRubricQueryKey({
              path: { rubricUuid: rubricToDelete, },
              query: { pageable: {} },
            }),
          });
          qc.invalidateQueries({
            queryKey: getRubricMatrixQueryKey({ path: { rubricUuid: rubricToDelete } }),
          });
          toast.success('Rubric scoring level deleted successfully.');
        },
        onError: () => {
          toast.error('Failed to delete rubric scoring.');
        },
        onSettled: () => {
          setDeleteScoringModalOpen(false);
          setRubricToDelete(null);
          setScoringLevelToDelete(null);
        },
      }
    );
  };

  const deleteRubricScoring = useMutation(deleteRubricScoringMutation());
  const confirmDeleteScoring = () => {
    if (!rubricToDelete || !criterionToDelete || !scoringToDelete) return;

    // Optimistic UI update
    setRubrics(prev =>
      prev.map(rubricGroup => {
        if (rubricGroup.rubric.uuid !== rubricToDelete) return rubricGroup;

        return {
          ...rubricGroup,
          criteria: rubricGroup.criteria.map(criterion => {
            if (criterion.uuid !== criterionToDelete) return criterion;

            return {
              ...criterion,
              scoring: criterion.scoring.filter((s: any) => s.uuid !== scoringToDelete),
            };
          }),
        };
      })
    );

    deleteRubricScoring.mutate(
      {
        path: {
          rubricUuid: rubricToDelete,
          criteriaUuid: criterionToDelete,
          scoringUuid: scoringToDelete,
        },
      },
      {
        onSuccess: () => {
          qc.invalidateQueries({
            queryKey: getRubricScoringQueryKey({
              path: {
                rubricUuid: rubricToDelete,
                criteriaUuid: criterionToDelete,
              },
              query: { pageable: {} },
            }),
          });
          qc.invalidateQueries({
            queryKey: getRubricMatrixQueryKey({ path: { rubricUuid: rubricToDelete } }),
          });
          toast.success('Rubric scoring deleted successfully.');
        },
        onError: () => {
          toast.error('Failed to delete rubric scoring.');
        },
        onSettled: () => {
          setDeleteScoringModalOpen(false);
          setRubricToDelete(null);
          setCriterionToDelete(null);
          setScoringToDelete(null);
        },
      }
    );
  };

  // const initMatrix = useMutation(initializeMatrixMutation())
  // const handleInitializeMatrix = (rubricId: any) => {
  //   initMatrix.mutate({ path: { rubricUuid: rubricId }, query: { template: 'standard' } }, {
  //     onSuccess: (data) => {
  //       toast.success(data?.message)
  //     }
  //   })
  // }

  return (
    <div className='space-y-6'>
      <div className='mb-6 flex items-end justify-between'>
        <div>
          <h1 className='text-2xl font-semibold'>Your Rubrics</h1>
          <p className='text-muted-foreground mt-1 text-base'>
            You have {rubrics.length} rubric{rubrics.length !== 1 ? 's' : ''} created.
          </p>
        </div>
        <Button
          type='button'
          onClick={openCreateRubricModal}
          className='cursor-pointer px-4 py-2 text-sm'
        >
          <PlusIcon className='mr-1 h-4 w-4' />
          New Rubric
        </Button>
      </div>

      <div className="mb-4 flex items-center justify-start space-x-2">
        <Button
          variant={viewMode === 'list' ? 'default' : 'ghost'}
          onClick={() => setViewMode('list')}
          size="icon"
          className="flex items-center gap-2 px-3 min-w-fit"
        >
          <ListIcon className="h-4 w-4" />
          <span>List View</span>
        </Button>

        <Button
          variant={viewMode === 'grid' ? 'default' : 'ghost'}
          onClick={() => setViewMode('grid')}
          size="icon"
          className="flex items-center gap-2 px-3 min-w-fit"
        >
          <LayoutGridIcon className="h-4 w-4" />
          <span>Grid View</span>
        </Button>
      </div>


      {rubricDataIsLoading && (
        <div className='flex flex-col gap-4 text-[12px] sm:text-[14px]'>
          <div className='h-20 w-full animate-pulse rounded bg-gray-200'></div>
          <div className='h-16 w-full animate-pulse rounded bg-gray-200'></div>
          <div className='h-12 w-full animate-pulse rounded bg-gray-200'></div>
        </div>
      )}

      {!rubricDataIsLoading &&
        !rubricsDataIsFetched &&
        rubrics.length !== undefined &&
        rubrics.length === 0 && (
          <div className='bg-muted/20 rounded-md border py-12 text-center'>
            <p className='text-muted-foreground mt-2'>No rubrics created yet.</p>
            <Button className='mt-4' onClick={openCreateRubricModal}>
              Create Your First Rubric
            </Button>
          </div>
        )}

      {viewMode === 'list' && (
        <>
          {rubricsDataIsFetched && !rubricDataIsLoading && rubrics.length >= 1 && (
            <div className='space-y-4'>
              {rubrics.map((rubricItem: any) => {
                const rubric = rubricItem.rubric;
                const criteria = rubricItem.criteria ?? [];

                return (
                  <div
                    key={rubricItem?.uuid || rubric.uuid}
                    className='group relative flex items-start gap-4 rounded-lg border px-4 py-2 transition-all'
                  >
                    <Grip className='text-muted-foreground mt-4 h-5 w-5 cursor-move opacity-0 transition-opacity group-hover:opacity-100' />

                    <Accordion type='multiple' key={rubric.uuid} className='w-full self-start'>
                      <AccordionItem value={rubric.uuid} className='px-1'>
                        <AccordionTrigger className='accordion-trigger-no-underline flex w-full items-center justify-between text-left'>
                          <div className='flex flex-grow flex-col'>
                            <h3 className='font-semibold'>{rubric.title}</h3>
                            <p className='text-muted-foreground text-sm'>{rubric.description}</p>
                          </div>

                          {/* Hover Actions */}
                          <div className='ml-2 flex-shrink-0'>
                            <DropdownMenu>
                              <DropdownMenuTrigger asChild>
                                <Button
                                  variant='ghost'
                                  size='icon'
                                  className='opacity-0 transition-opacity group-hover:opacity-100'
                                >
                                  <EllipsisVertical className='h-4 w-4' />
                                </Button>
                              </DropdownMenuTrigger>
                              <DropdownMenuContent align='end'>
                                <DropdownMenuItem onClick={() => openEditModal(rubric.uuid)}>
                                  <PenIcon className='mr-2 h-4 w-4' />
                                  Edit Rubric
                                </DropdownMenuItem>
                                <DropdownMenuItem onClick={() => handleAddCriteria(rubric.uuid)}>
                                  <CirclePlus className='mr-2 h-4 w-4' />
                                  Add Criterion
                                </DropdownMenuItem>
                                <DropdownMenuItem onClick={() => handleAddScoringLevel(rubric.uuid)}>
                                  <DiamondPlus className="mr-2 h-4 w-4" />
                                  Add Scoring Level
                                </DropdownMenuItem>
                                <DropdownMenuSeparator />
                                <DropdownMenuItem
                                  variant='destructive'
                                  onClick={() => handleAskDeleteRubric(rubric.uuid)}
                                >
                                  <TrashIcon className='mr-2 h-4 w-4' />
                                  Delete Rubric
                                </DropdownMenuItem>
                              </DropdownMenuContent>
                            </DropdownMenu>
                          </div>
                        </AccordionTrigger>

                        <AccordionContent className='px-4 pb-4'>
                          <Accordion type='multiple' className='space-y-2'>
                            {criteria.length === 0 ? (
                              <p className='text-muted-foreground py-4 text-sm italic'>
                                No criteria added.
                              </p>
                            ) : (
                              criteria.map((criterion: any, index: number) => (
                                <AccordionItem
                                  key={criterion.uuid || index}
                                  value={criterion.uuid || `${rubric.uuid}-${index}`}
                                >
                                  <AccordionTrigger className='bg-muted/50 hover:bg-muted accordion-trigger-no-underline flex items-center justify-between rounded-lg px-3 py-2'>
                                    <div className='flex flex-grow flex-col'>
                                      <p className='text-sm font-medium'>{criterion.component_name}</p>
                                    </div>

                                    {/* Criterion Actions */}
                                    <DropdownMenu>
                                      <DropdownMenuTrigger asChild>
                                        <Button variant='ghost' size='icon'>
                                          <EllipsisVertical className='h-4 w-4' />
                                        </Button>
                                      </DropdownMenuTrigger>
                                      <DropdownMenuContent align='end'>
                                        <DropdownMenuItem
                                          onClick={() =>
                                            handleEditCriterion(rubric.uuid, criterion.uuid)
                                          }
                                        >
                                          <PenIcon className='mr-2 h-4 w-4' />
                                          Edit Criterion
                                        </DropdownMenuItem>
                                        <DropdownMenuItem
                                          onClick={() => handleAddScore(rubric.uuid, criterion.uuid)}
                                        >
                                          <CirclePlus className='mr-2 h-4 w-4' />
                                          Add Scoring
                                        </DropdownMenuItem>
                                        <DropdownMenuItem
                                          variant='destructive'
                                          onClick={() =>
                                            handleAskDeleteCriterion(rubric.uuid, criterion.uuid)
                                          }
                                        >
                                          <TrashIcon className='mr-2 h-4 w-4' />
                                          Delete Criterion
                                        </DropdownMenuItem>
                                      </DropdownMenuContent>
                                    </DropdownMenu>
                                  </AccordionTrigger>

                                  <AccordionContent className='space-y-2 px-4 pt-2'>
                                    {!criterion.scoring || criterion.scoring.length === 0 ? (
                                      <p className='text-muted-foreground py-4 text-sm italic'>
                                        No scoring defined.
                                      </p>
                                    ) : (
                                      criterion.scoring?.map((score: any, i: number) => (
                                        <div
                                          key={score.uuid || i}
                                          className='bg-background relative rounded-lg border p-3 shadow-sm'
                                        >
                                          <div className='text-sm font-medium'>
                                            {score.performance_expectation} â€“{' '}
                                            <span className='text-muted-foreground'>
                                              {score.score_range}
                                            </span>
                                          </div>
                                          {score.description && (
                                            <p className='text-muted-foreground mt-1 text-sm'>
                                              {score.description}
                                            </p>
                                          )}
                                          {/* Scoring Actions */}
                                          <div className='absolute top-2 right-2 flex space-x-1'>
                                            {/* <Button
                                              variant='ghost'
                                              size='icon'
                                              onClick={() =>
                                                handleEditCriteriaScoring(rubric.uuid, cell)
                                              }
                                            >
                                              <PenIcon className='h-4 w-4' />
                                            </Button> */}
                                            {/* <Button
                                              variant='ghost'
                                              size='icon'
                                              onClick={() =>
                                                handleAskDeleteCriteriaScoring(
                                                  rubric.uuid,
                                                  criterion.uuid,
                                                  cell
                                                )
                                              }
                                            >
                                              <TrashIcon className='text-destructive h-4 w-4' />
                                            </Button> */}
                                          </div>
                                        </div>
                                      ))
                                    )}
                                  </AccordionContent>
                                </AccordionItem>
                              ))
                            )}
                          </Accordion>
                        </AccordionContent>
                      </AccordionItem>
                    </Accordion>
                  </div>
                );
              })}
            </div>
          )}
        </>
      )}

      {viewMode === 'grid' && (
        <>
          {rubricsDataIsFetched && !rubricDataIsLoading && rubrics.length >= 1 && (
            <div className="space-y-6">
              {rubrics.map((item) => {
                const rubric = item.rubric;
                const matrixData = item.matrix?.data?.data;

                return (
                  <RubricTable
                    key={rubric.uuid}
                    rubric={rubric}
                    scoringLevels={matrixData?.scoring_levels || []}
                    criteria={matrixData?.criteria || []}
                    matrixCells={matrixData?.matrix_cells || {}}

                    // Pass action handlers here
                    onEditRubric={openEditModal}
                    onDeleteRubric={handleAskDeleteRubric}
                    onAddCriterion={handleAddCriteria}
                    onAddScoringLevel={handleAddScoringLevel}
                    onEditScoringLevel={handleEditScoringLevel}
                    onDeleteScoringLevel={handleAskDeleteScoringLevel}

                    onEditCriterion={handleEditCriterion}
                    onDeleteCriterion={handleAskDeleteCriterion}
                    onAddScoring={handleAddScore}
                    onEditCriterionScoring={handleEditCriteriaScoring}
                    onDeleteCriterionScoring={handleAskDeleteCriteriaScoring}

                  />
                );
              })}
            </div>
          )}
        </>

      )}

      {/* Create and edit components modals */}
      {isCreateModalOpen && (
        <RubricDialog
          open={isCreateModalOpen}
          setOpen={setIsCreateModalOpen}
          onSubmitSuccess={() => {
            setEditingRubricId(null);
            setEditingRubric(null);
          }}
          editingRubric={editingRubric}
          editingRubricId={editingRubricId as string}
        />
      )}

      {isCriterionModalOpen && (
        <CriteriaDialog
          open={isCriterionModalOpen}
          setOpen={setIsCriterionModalOpen}
          defaultValues={editingCriterion ?? undefined}
          rubricId={editingRubricId as string}
          criterionId={editingCriterionId as string}
          onSuccess={() => {
            setEditingRubricId(null);
            setEditingCriterionId(null);
            setEditingCriterion(null);
          }}
        />
      )}

      {isScoringLevelModalOpen && (
        <ScoringLevelDialog
          open={isScoringLevelModalOpen}
          setOpen={setIsScoringLevelModalOpen}
          defaultValues={editingScoringLevel ?? undefined}
          rubricId={editingRubricId as string}
          scoringLevelId={editingScoringLevelId as string}
          onSuccess={() => {
            setEditingRubricId(null);
            setEditingCriterionId(null);
            setEditingScoringLevelId(null);
            setEditingScoringId(null);
            setEditingScoring(null);
          }} />
      )}

      {isScoringModalOpen && (
        <ScoringDialog
          open={isScoringModalOpen}
          setOpen={setIsScoringModalOpen}
          defaultValues={editingScoring ?? undefined}
          rubricId={editingRubricId as string}
          criterionId={editingCriterionId as string}
          scoringId={editingScoringId as string}
          onSuccess={() => {
            setEditingRubricId(null);
            setEditingCriterionId(null);
            setEditingScoringId(null);
            setEditingScoring(null);
          }}
        />

      )}

      {/* Delete components modals */}
      <DeleteModal
        open={deleteModalOpen}
        setOpen={setDeleteModalOpen}
        title='Delete Rubric'
        description='Are you sure you want to delete this rubric? This action cannot be undone.'
        onConfirm={confirmDeleteRubric}
        isLoading={deleteRubric.isPending}
        confirmText='Delete Rubric'
      />

      <DeleteModal
        open={deleteCriteriaModalOpen}
        setOpen={setDeleteCriteriaModalOpen}
        title='Delete Criterion'
        description='Are you sure you want to delete this rubric criterion? This action cannot be undone.'
        onConfirm={confirmDeleteCriterion}
        isLoading={deleteRubricCriterion.isPending}
        confirmText='Delete Criterion'
      />

      <DeleteModal
        open={deleteScoringLevelModalOpen}
        setOpen={setDeleteScoringLevelModalOpen}
        title='Delete Scoring Level'
        description='Are you sure you want to delete this scoring level? This action cannot be undone.'
        onConfirm={confirmDeleteScoringLevel}
        isLoading={deleteRubricScoringLevel.isPending}
        confirmText='Delete Scoring Level'
      />

      <DeleteModal
        open={deleteScoringModalOpen}
        setOpen={setDeleteScoringModalOpen}
        title='Delete Scoring'
        description='Are you sure you want to delete this scoring? This action cannot be undone.'
        onConfirm={confirmDeleteScoring}
        isLoading={deleteRubricScoring.isPending}
        confirmText='Delete Scoring'
      />
    </div>
  );
}
