// This file is auto-generated by @hey-api/openapi-ts

import {
  type Options,
  deleteUser,
  getUserByUuid,
  updateUser,
  deleteUserGroup,
  getUserGroupByUuid,
  updateUserGroup,
  deleteTrainingSession,
  getTrainingSessionById,
  updateTrainingSession,
  deleteStudent,
  getStudentById,
  updateStudent,
  deleteRole,
  getRoleByUuid,
  updateRole,
  deletePrerequisite,
  updatePrerequisite,
  deletePrerequisiteGroup,
  updatePrerequisiteGroup,
  deleteOrganisation,
  getOrganisationByUuid,
  updateOrganisation,
  deleteInstructor,
  getInstructorByUuid,
  updateInstructor,
  deleteCourse,
  getCourse,
  updateCourse,
  deleteLesson,
  getLesson,
  updateLesson,
  deleteCategory,
  getCategory,
  updateCategory,
  deleteAssessment,
  getAssessment,
  updateAssessment,
  deleteQuestion,
  getQuestion,
  updateQuestion,
  createUserGroup,
  removeUsersFromGroup,
  getUsersForUserGroup,
  addUsersToGroup,
  removeRolesFromGroup,
  getRolesForUserGroup,
  assignRolesToGroup,
  getAllTrainingSessions,
  createTrainingSession,
  getAllStudents,
  createStudent,
  createRole,
  findPrerequisites,
  createPrerequisite,
  createPrerequisiteGroup,
  getPrerequisiteTypes,
  createPrerequisiteType,
  getAllOrganisations,
  createOrganisation,
  getAllInstructors,
  createInstructor,
  getCourses,
  createCourse,
  getLessons,
  createLesson,
  getAllCategories,
  createCategory,
  createAssessment,
  getQuestions,
  createQuestion,
  search,
  getProfileImage,
  getUsersByOrganisation,
  search1,
  getUserGroupsByOrganisation,
  searchTrainingSessions,
  searchStudents,
  getEffectiveRolesForUser,
  searchRoles,
  getAllPermissions,
  getRolesByOrganisation,
  search2,
  searchInstructors,
  getCourseThumbnail,
  getAssessmentsByLesson,
  getAssessmentsByCourse,
} from "../sdk.gen"
import {
  type UseMutationOptions,
  queryOptions,
  infiniteQueryOptions,
  type InfiniteData,
} from "@tanstack/react-query"
import type {
  DeleteUserData,
  DeleteUserError,
  DeleteUserResponse,
  GetUserByUuidData,
  UpdateUserData,
  UpdateUserError,
  UpdateUserResponse,
  DeleteUserGroupData,
  DeleteUserGroupError,
  DeleteUserGroupResponse,
  GetUserGroupByUuidData,
  UpdateUserGroupData,
  UpdateUserGroupError,
  UpdateUserGroupResponse,
  DeleteTrainingSessionData,
  DeleteTrainingSessionError,
  DeleteTrainingSessionResponse,
  GetTrainingSessionByIdData,
  UpdateTrainingSessionData,
  UpdateTrainingSessionError,
  UpdateTrainingSessionResponse,
  DeleteStudentData,
  DeleteStudentError,
  DeleteStudentResponse,
  GetStudentByIdData,
  UpdateStudentData,
  UpdateStudentError,
  UpdateStudentResponse,
  DeleteRoleData,
  DeleteRoleError,
  DeleteRoleResponse,
  GetRoleByUuidData,
  UpdateRoleData,
  UpdateRoleError,
  UpdateRoleResponse,
  DeletePrerequisiteData,
  DeletePrerequisiteError,
  DeletePrerequisiteResponse,
  UpdatePrerequisiteData,
  UpdatePrerequisiteError,
  UpdatePrerequisiteResponse,
  DeletePrerequisiteGroupData,
  DeletePrerequisiteGroupError,
  DeletePrerequisiteGroupResponse,
  UpdatePrerequisiteGroupData,
  UpdatePrerequisiteGroupError,
  UpdatePrerequisiteGroupResponse,
  DeleteOrganisationData,
  DeleteOrganisationError,
  DeleteOrganisationResponse,
  GetOrganisationByUuidData,
  UpdateOrganisationData,
  UpdateOrganisationError,
  UpdateOrganisationResponse,
  DeleteInstructorData,
  DeleteInstructorError,
  DeleteInstructorResponse,
  GetInstructorByUuidData,
  UpdateInstructorData,
  UpdateInstructorError,
  UpdateInstructorResponse,
  DeleteCourseData,
  DeleteCourseError,
  DeleteCourseResponse,
  GetCourseData,
  UpdateCourseData,
  UpdateCourseError,
  UpdateCourseResponse,
  DeleteLessonData,
  DeleteLessonError,
  DeleteLessonResponse,
  GetLessonData,
  UpdateLessonData,
  UpdateLessonError,
  UpdateLessonResponse,
  DeleteCategoryData,
  DeleteCategoryError,
  DeleteCategoryResponse,
  GetCategoryData,
  UpdateCategoryData,
  UpdateCategoryError,
  UpdateCategoryResponse,
  DeleteAssessmentData,
  DeleteAssessmentError,
  DeleteAssessmentResponse,
  GetAssessmentData,
  UpdateAssessmentData,
  UpdateAssessmentError,
  UpdateAssessmentResponse,
  DeleteQuestionData,
  DeleteQuestionError,
  DeleteQuestionResponse,
  GetQuestionData,
  UpdateQuestionData,
  UpdateQuestionError,
  UpdateQuestionResponse,
  CreateUserGroupData,
  CreateUserGroupError,
  CreateUserGroupResponse,
  RemoveUsersFromGroupData,
  RemoveUsersFromGroupError,
  RemoveUsersFromGroupResponse,
  GetUsersForUserGroupData,
  GetUsersForUserGroupError,
  GetUsersForUserGroupResponse,
  AddUsersToGroupData,
  AddUsersToGroupError,
  AddUsersToGroupResponse,
  RemoveRolesFromGroupData,
  RemoveRolesFromGroupError,
  RemoveRolesFromGroupResponse,
  GetRolesForUserGroupData,
  GetRolesForUserGroupError,
  GetRolesForUserGroupResponse,
  AssignRolesToGroupData,
  AssignRolesToGroupError,
  AssignRolesToGroupResponse,
  GetAllTrainingSessionsData,
  GetAllTrainingSessionsError,
  GetAllTrainingSessionsResponse,
  CreateTrainingSessionData,
  CreateTrainingSessionError,
  CreateTrainingSessionResponse,
  GetAllStudentsData,
  GetAllStudentsError,
  GetAllStudentsResponse,
  CreateStudentData,
  CreateStudentError,
  CreateStudentResponse,
  CreateRoleData,
  CreateRoleError,
  CreateRoleResponse,
  FindPrerequisitesData,
  FindPrerequisitesError,
  FindPrerequisitesResponse,
  CreatePrerequisiteData,
  CreatePrerequisiteError,
  CreatePrerequisiteResponse,
  CreatePrerequisiteGroupData,
  CreatePrerequisiteGroupError,
  CreatePrerequisiteGroupResponse,
  GetPrerequisiteTypesData,
  GetPrerequisiteTypesError,
  GetPrerequisiteTypesResponse,
  CreatePrerequisiteTypeData,
  CreatePrerequisiteTypeError,
  CreatePrerequisiteTypeResponse,
  GetAllOrganisationsData,
  GetAllOrganisationsError,
  GetAllOrganisationsResponse,
  CreateOrganisationData,
  CreateOrganisationError,
  CreateOrganisationResponse,
  GetAllInstructorsData,
  GetAllInstructorsError,
  GetAllInstructorsResponse,
  CreateInstructorData,
  CreateInstructorError,
  CreateInstructorResponse,
  GetCoursesData,
  GetCoursesError,
  GetCoursesResponse,
  CreateCourseData,
  CreateCourseError,
  CreateCourseResponse,
  GetLessonsData,
  GetLessonsError,
  GetLessonsResponse,
  CreateLessonData,
  CreateLessonError,
  CreateLessonResponse,
  GetAllCategoriesData,
  GetAllCategoriesError,
  GetAllCategoriesResponse,
  CreateCategoryData,
  CreateCategoryError,
  CreateCategoryResponse,
  CreateAssessmentData,
  CreateAssessmentError,
  CreateAssessmentResponse,
  GetQuestionsData,
  GetQuestionsError,
  GetQuestionsResponse,
  CreateQuestionData,
  CreateQuestionError,
  CreateQuestionResponse,
  SearchData,
  SearchError,
  SearchResponse,
  GetProfileImageData,
  GetUsersByOrganisationData,
  GetUsersByOrganisationError,
  GetUsersByOrganisationResponse,
  Search1Data,
  Search1Error,
  Search1Response,
  GetUserGroupsByOrganisationData,
  GetUserGroupsByOrganisationError,
  GetUserGroupsByOrganisationResponse,
  SearchTrainingSessionsData,
  SearchTrainingSessionsError,
  SearchTrainingSessionsResponse,
  SearchStudentsData,
  SearchStudentsError,
  SearchStudentsResponse,
  GetEffectiveRolesForUserData,
  SearchRolesData,
  SearchRolesError,
  SearchRolesResponse,
  GetAllPermissionsData,
  GetRolesByOrganisationData,
  GetRolesByOrganisationError,
  GetRolesByOrganisationResponse,
  Search2Data,
  Search2Error,
  Search2Response,
  SearchInstructorsData,
  SearchInstructorsError,
  SearchInstructorsResponse,
  GetCourseThumbnailData,
  GetAssessmentsByLessonData,
  GetAssessmentsByLessonError,
  GetAssessmentsByLessonResponse,
  GetAssessmentsByCourseData,
  GetAssessmentsByCourseError,
  GetAssessmentsByCourseResponse,
} from "../types.gen"
import { client as _heyApiClient } from "../client.gen"

/**
 * Delete a user by UUID
 */
export const deleteUserMutation = (
  options?: Partial<Options<DeleteUserData>>,
): UseMutationOptions<
  DeleteUserResponse,
  DeleteUserError,
  Options<DeleteUserData>
> => {
  const mutationOptions: UseMutationOptions<
    DeleteUserResponse,
    DeleteUserError,
    Options<DeleteUserData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await deleteUser({
        ...options,
        ...localOptions,
        throwOnError: true,
      })
      return data
    },
  }
  return mutationOptions
}

export type QueryKey<TOptions extends Options> = [
  Pick<TOptions, "baseUrl" | "body" | "headers" | "path" | "query"> & {
    _id: string
    _infinite?: boolean
  },
]

const createQueryKey = <TOptions extends Options>(
  id: string,
  options?: TOptions,
  infinite?: boolean,
): [QueryKey<TOptions>[0]] => {
  const params: QueryKey<TOptions>[0] = {
    _id: id,
    baseUrl: (options?.client ?? _heyApiClient).getConfig().baseUrl,
  } as QueryKey<TOptions>[0]
  if (infinite) {
    params._infinite = infinite
  }
  if (options?.body) {
    params.body = options.body
  }
  if (options?.headers) {
    params.headers = options.headers
  }
  if (options?.path) {
    params.path = options.path
  }
  if (options?.query) {
    params.query = options.query
  }
  return [params]
}

export const getUserByUuidQueryKey = (options: Options<GetUserByUuidData>) =>
  createQueryKey("getUserByUuid", options)

/**
 * Get a user by UUID
 */
export const getUserByUuidOptions = (options: Options<GetUserByUuidData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getUserByUuid({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      })
      return data
    },
    queryKey: getUserByUuidQueryKey(options),
  })
}

/**
 * Update a user by UUID
 */
export const updateUserMutation = (
  options?: Partial<Options<UpdateUserData>>,
): UseMutationOptions<
  UpdateUserResponse,
  UpdateUserError,
  Options<UpdateUserData>
> => {
  const mutationOptions: UseMutationOptions<
    UpdateUserResponse,
    UpdateUserError,
    Options<UpdateUserData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await updateUser({
        ...options,
        ...localOptions,
        throwOnError: true,
      })
      return data
    },
  }
  return mutationOptions
}

/**
 * Delete a user group by UUID
 */
export const deleteUserGroupMutation = (
  options?: Partial<Options<DeleteUserGroupData>>,
): UseMutationOptions<
  DeleteUserGroupResponse,
  DeleteUserGroupError,
  Options<DeleteUserGroupData>
> => {
  const mutationOptions: UseMutationOptions<
    DeleteUserGroupResponse,
    DeleteUserGroupError,
    Options<DeleteUserGroupData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await deleteUserGroup({
        ...options,
        ...localOptions,
        throwOnError: true,
      })
      return data
    },
  }
  return mutationOptions
}

export const getUserGroupByUuidQueryKey = (
  options: Options<GetUserGroupByUuidData>,
) => createQueryKey("getUserGroupByUuid", options)

/**
 * Get a user group by UUID
 */
export const getUserGroupByUuidOptions = (
  options: Options<GetUserGroupByUuidData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getUserGroupByUuid({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      })
      return data
    },
    queryKey: getUserGroupByUuidQueryKey(options),
  })
}

/**
 * Update a user group by UUID
 */
export const updateUserGroupMutation = (
  options?: Partial<Options<UpdateUserGroupData>>,
): UseMutationOptions<
  UpdateUserGroupResponse,
  UpdateUserGroupError,
  Options<UpdateUserGroupData>
> => {
  const mutationOptions: UseMutationOptions<
    UpdateUserGroupResponse,
    UpdateUserGroupError,
    Options<UpdateUserGroupData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await updateUserGroup({
        ...options,
        ...localOptions,
        throwOnError: true,
      })
      return data
    },
  }
  return mutationOptions
}

/**
 * Delete a training session
 * Removes a training session record from the system.
 */
export const deleteTrainingSessionMutation = (
  options?: Partial<Options<DeleteTrainingSessionData>>,
): UseMutationOptions<
  DeleteTrainingSessionResponse,
  DeleteTrainingSessionError,
  Options<DeleteTrainingSessionData>
> => {
  const mutationOptions: UseMutationOptions<
    DeleteTrainingSessionResponse,
    DeleteTrainingSessionError,
    Options<DeleteTrainingSessionData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await deleteTrainingSession({
        ...options,
        ...localOptions,
        throwOnError: true,
      })
      return data
    },
  }
  return mutationOptions
}

export const getTrainingSessionByIdQueryKey = (
  options: Options<GetTrainingSessionByIdData>,
) => createQueryKey("getTrainingSessionById", options)

/**
 * Get training session by ID
 * Fetches a training session by its UUID.
 */
export const getTrainingSessionByIdOptions = (
  options: Options<GetTrainingSessionByIdData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getTrainingSessionById({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      })
      return data
    },
    queryKey: getTrainingSessionByIdQueryKey(options),
  })
}

/**
 * Update a training session
 * Updates an existing training session record.
 */
export const updateTrainingSessionMutation = (
  options?: Partial<Options<UpdateTrainingSessionData>>,
): UseMutationOptions<
  UpdateTrainingSessionResponse,
  UpdateTrainingSessionError,
  Options<UpdateTrainingSessionData>
> => {
  const mutationOptions: UseMutationOptions<
    UpdateTrainingSessionResponse,
    UpdateTrainingSessionError,
    Options<UpdateTrainingSessionData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await updateTrainingSession({
        ...options,
        ...localOptions,
        throwOnError: true,
      })
      return data
    },
  }
  return mutationOptions
}

/**
 * Delete a student
 * Removes a student record from the system.
 */
export const deleteStudentMutation = (
  options?: Partial<Options<DeleteStudentData>>,
): UseMutationOptions<
  DeleteStudentResponse,
  DeleteStudentError,
  Options<DeleteStudentData>
> => {
  const mutationOptions: UseMutationOptions<
    DeleteStudentResponse,
    DeleteStudentError,
    Options<DeleteStudentData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await deleteStudent({
        ...options,
        ...localOptions,
        throwOnError: true,
      })
      return data
    },
  }
  return mutationOptions
}

export const getStudentByIdQueryKey = (options: Options<GetStudentByIdData>) =>
  createQueryKey("getStudentById", options)

/**
 * Get student by ID
 * Fetches a student by their UUID.
 */
export const getStudentByIdOptions = (options: Options<GetStudentByIdData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getStudentById({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      })
      return data
    },
    queryKey: getStudentByIdQueryKey(options),
  })
}

/**
 * Update a student
 * Updates an existing student record.
 */
export const updateStudentMutation = (
  options?: Partial<Options<UpdateStudentData>>,
): UseMutationOptions<
  UpdateStudentResponse,
  UpdateStudentError,
  Options<UpdateStudentData>
> => {
  const mutationOptions: UseMutationOptions<
    UpdateStudentResponse,
    UpdateStudentError,
    Options<UpdateStudentData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await updateStudent({
        ...options,
        ...localOptions,
        throwOnError: true,
      })
      return data
    },
  }
  return mutationOptions
}

/**
 * Delete a role by UUID
 */
export const deleteRoleMutation = (
  options?: Partial<Options<DeleteRoleData>>,
): UseMutationOptions<
  DeleteRoleResponse,
  DeleteRoleError,
  Options<DeleteRoleData>
> => {
  const mutationOptions: UseMutationOptions<
    DeleteRoleResponse,
    DeleteRoleError,
    Options<DeleteRoleData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await deleteRole({
        ...options,
        ...localOptions,
        throwOnError: true,
      })
      return data
    },
  }
  return mutationOptions
}

export const getRoleByUuidQueryKey = (options: Options<GetRoleByUuidData>) =>
  createQueryKey("getRoleByUuid", options)

/**
 * Get a role by UUID
 */
export const getRoleByUuidOptions = (options: Options<GetRoleByUuidData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getRoleByUuid({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      })
      return data
    },
    queryKey: getRoleByUuidQueryKey(options),
  })
}

/**
 * Update a role by UUID
 */
export const updateRoleMutation = (
  options?: Partial<Options<UpdateRoleData>>,
): UseMutationOptions<
  UpdateRoleResponse,
  UpdateRoleError,
  Options<UpdateRoleData>
> => {
  const mutationOptions: UseMutationOptions<
    UpdateRoleResponse,
    UpdateRoleError,
    Options<UpdateRoleData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await updateRole({
        ...options,
        ...localOptions,
        throwOnError: true,
      })
      return data
    },
  }
  return mutationOptions
}

export const deletePrerequisiteMutation = (
  options?: Partial<Options<DeletePrerequisiteData>>,
): UseMutationOptions<
  DeletePrerequisiteResponse,
  DeletePrerequisiteError,
  Options<DeletePrerequisiteData>
> => {
  const mutationOptions: UseMutationOptions<
    DeletePrerequisiteResponse,
    DeletePrerequisiteError,
    Options<DeletePrerequisiteData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await deletePrerequisite({
        ...options,
        ...localOptions,
        throwOnError: true,
      })
      return data
    },
  }
  return mutationOptions
}

export const updatePrerequisiteMutation = (
  options?: Partial<Options<UpdatePrerequisiteData>>,
): UseMutationOptions<
  UpdatePrerequisiteResponse,
  UpdatePrerequisiteError,
  Options<UpdatePrerequisiteData>
> => {
  const mutationOptions: UseMutationOptions<
    UpdatePrerequisiteResponse,
    UpdatePrerequisiteError,
    Options<UpdatePrerequisiteData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await updatePrerequisite({
        ...options,
        ...localOptions,
        throwOnError: true,
      })
      return data
    },
  }
  return mutationOptions
}

export const deletePrerequisiteGroupMutation = (
  options?: Partial<Options<DeletePrerequisiteGroupData>>,
): UseMutationOptions<
  DeletePrerequisiteGroupResponse,
  DeletePrerequisiteGroupError,
  Options<DeletePrerequisiteGroupData>
> => {
  const mutationOptions: UseMutationOptions<
    DeletePrerequisiteGroupResponse,
    DeletePrerequisiteGroupError,
    Options<DeletePrerequisiteGroupData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await deletePrerequisiteGroup({
        ...options,
        ...localOptions,
        throwOnError: true,
      })
      return data
    },
  }
  return mutationOptions
}

export const updatePrerequisiteGroupMutation = (
  options?: Partial<Options<UpdatePrerequisiteGroupData>>,
): UseMutationOptions<
  UpdatePrerequisiteGroupResponse,
  UpdatePrerequisiteGroupError,
  Options<UpdatePrerequisiteGroupData>
> => {
  const mutationOptions: UseMutationOptions<
    UpdatePrerequisiteGroupResponse,
    UpdatePrerequisiteGroupError,
    Options<UpdatePrerequisiteGroupData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await updatePrerequisiteGroup({
        ...options,
        ...localOptions,
        throwOnError: true,
      })
      return data
    },
  }
  return mutationOptions
}

/**
 * Delete an organisation by UUID
 */
export const deleteOrganisationMutation = (
  options?: Partial<Options<DeleteOrganisationData>>,
): UseMutationOptions<
  DeleteOrganisationResponse,
  DeleteOrganisationError,
  Options<DeleteOrganisationData>
> => {
  const mutationOptions: UseMutationOptions<
    DeleteOrganisationResponse,
    DeleteOrganisationError,
    Options<DeleteOrganisationData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await deleteOrganisation({
        ...options,
        ...localOptions,
        throwOnError: true,
      })
      return data
    },
  }
  return mutationOptions
}

export const getOrganisationByUuidQueryKey = (
  options: Options<GetOrganisationByUuidData>,
) => createQueryKey("getOrganisationByUuid", options)

/**
 * Get an organisation by UUID
 */
export const getOrganisationByUuidOptions = (
  options: Options<GetOrganisationByUuidData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getOrganisationByUuid({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      })
      return data
    },
    queryKey: getOrganisationByUuidQueryKey(options),
  })
}

/**
 * Update an organisation by UUID
 */
export const updateOrganisationMutation = (
  options?: Partial<Options<UpdateOrganisationData>>,
): UseMutationOptions<
  UpdateOrganisationResponse,
  UpdateOrganisationError,
  Options<UpdateOrganisationData>
> => {
  const mutationOptions: UseMutationOptions<
    UpdateOrganisationResponse,
    UpdateOrganisationError,
    Options<UpdateOrganisationData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await updateOrganisation({
        ...options,
        ...localOptions,
        throwOnError: true,
      })
      return data
    },
  }
  return mutationOptions
}

/**
 * Delete an instructor
 * Removes an instructor record from the system.
 */
export const deleteInstructorMutation = (
  options?: Partial<Options<DeleteInstructorData>>,
): UseMutationOptions<
  DeleteInstructorResponse,
  DeleteInstructorError,
  Options<DeleteInstructorData>
> => {
  const mutationOptions: UseMutationOptions<
    DeleteInstructorResponse,
    DeleteInstructorError,
    Options<DeleteInstructorData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await deleteInstructor({
        ...options,
        ...localOptions,
        throwOnError: true,
      })
      return data
    },
  }
  return mutationOptions
}

export const getInstructorByUuidQueryKey = (
  options: Options<GetInstructorByUuidData>,
) => createQueryKey("getInstructorByUuid", options)

/**
 * Get instructor by UUID
 * Fetches an instructor by their UUID.
 */
export const getInstructorByUuidOptions = (
  options: Options<GetInstructorByUuidData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getInstructorByUuid({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      })
      return data
    },
    queryKey: getInstructorByUuidQueryKey(options),
  })
}

/**
 * Update an instructor
 * Updates an existing instructor record.
 */
export const updateInstructorMutation = (
  options?: Partial<Options<UpdateInstructorData>>,
): UseMutationOptions<
  UpdateInstructorResponse,
  UpdateInstructorError,
  Options<UpdateInstructorData>
> => {
  const mutationOptions: UseMutationOptions<
    UpdateInstructorResponse,
    UpdateInstructorError,
    Options<UpdateInstructorData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await updateInstructor({
        ...options,
        ...localOptions,
        throwOnError: true,
      })
      return data
    },
  }
  return mutationOptions
}

export const deleteCourseMutation = (
  options?: Partial<Options<DeleteCourseData>>,
): UseMutationOptions<
  DeleteCourseResponse,
  DeleteCourseError,
  Options<DeleteCourseData>
> => {
  const mutationOptions: UseMutationOptions<
    DeleteCourseResponse,
    DeleteCourseError,
    Options<DeleteCourseData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await deleteCourse({
        ...options,
        ...localOptions,
        throwOnError: true,
      })
      return data
    },
  }
  return mutationOptions
}

export const getCourseQueryKey = (options: Options<GetCourseData>) =>
  createQueryKey("getCourse", options)

export const getCourseOptions = (options: Options<GetCourseData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getCourse({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      })
      return data
    },
    queryKey: getCourseQueryKey(options),
  })
}

export const updateCourseMutation = (
  options?: Partial<Options<UpdateCourseData>>,
): UseMutationOptions<
  UpdateCourseResponse,
  UpdateCourseError,
  Options<UpdateCourseData>
> => {
  const mutationOptions: UseMutationOptions<
    UpdateCourseResponse,
    UpdateCourseError,
    Options<UpdateCourseData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await updateCourse({
        ...options,
        ...localOptions,
        throwOnError: true,
      })
      return data
    },
  }
  return mutationOptions
}

export const deleteLessonMutation = (
  options?: Partial<Options<DeleteLessonData>>,
): UseMutationOptions<
  DeleteLessonResponse,
  DeleteLessonError,
  Options<DeleteLessonData>
> => {
  const mutationOptions: UseMutationOptions<
    DeleteLessonResponse,
    DeleteLessonError,
    Options<DeleteLessonData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await deleteLesson({
        ...options,
        ...localOptions,
        throwOnError: true,
      })
      return data
    },
  }
  return mutationOptions
}

export const getLessonQueryKey = (options: Options<GetLessonData>) =>
  createQueryKey("getLesson", options)

export const getLessonOptions = (options: Options<GetLessonData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getLesson({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      })
      return data
    },
    queryKey: getLessonQueryKey(options),
  })
}

export const updateLessonMutation = (
  options?: Partial<Options<UpdateLessonData>>,
): UseMutationOptions<
  UpdateLessonResponse,
  UpdateLessonError,
  Options<UpdateLessonData>
> => {
  const mutationOptions: UseMutationOptions<
    UpdateLessonResponse,
    UpdateLessonError,
    Options<UpdateLessonData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await updateLesson({
        ...options,
        ...localOptions,
        throwOnError: true,
      })
      return data
    },
  }
  return mutationOptions
}

export const deleteCategoryMutation = (
  options?: Partial<Options<DeleteCategoryData>>,
): UseMutationOptions<
  DeleteCategoryResponse,
  DeleteCategoryError,
  Options<DeleteCategoryData>
> => {
  const mutationOptions: UseMutationOptions<
    DeleteCategoryResponse,
    DeleteCategoryError,
    Options<DeleteCategoryData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await deleteCategory({
        ...options,
        ...localOptions,
        throwOnError: true,
      })
      return data
    },
  }
  return mutationOptions
}

export const getCategoryQueryKey = (options: Options<GetCategoryData>) =>
  createQueryKey("getCategory", options)

export const getCategoryOptions = (options: Options<GetCategoryData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getCategory({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      })
      return data
    },
    queryKey: getCategoryQueryKey(options),
  })
}

export const updateCategoryMutation = (
  options?: Partial<Options<UpdateCategoryData>>,
): UseMutationOptions<
  UpdateCategoryResponse,
  UpdateCategoryError,
  Options<UpdateCategoryData>
> => {
  const mutationOptions: UseMutationOptions<
    UpdateCategoryResponse,
    UpdateCategoryError,
    Options<UpdateCategoryData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await updateCategory({
        ...options,
        ...localOptions,
        throwOnError: true,
      })
      return data
    },
  }
  return mutationOptions
}

export const deleteAssessmentMutation = (
  options?: Partial<Options<DeleteAssessmentData>>,
): UseMutationOptions<
  DeleteAssessmentResponse,
  DeleteAssessmentError,
  Options<DeleteAssessmentData>
> => {
  const mutationOptions: UseMutationOptions<
    DeleteAssessmentResponse,
    DeleteAssessmentError,
    Options<DeleteAssessmentData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await deleteAssessment({
        ...options,
        ...localOptions,
        throwOnError: true,
      })
      return data
    },
  }
  return mutationOptions
}

export const getAssessmentQueryKey = (options: Options<GetAssessmentData>) =>
  createQueryKey("getAssessment", options)

export const getAssessmentOptions = (options: Options<GetAssessmentData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getAssessment({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      })
      return data
    },
    queryKey: getAssessmentQueryKey(options),
  })
}

export const updateAssessmentMutation = (
  options?: Partial<Options<UpdateAssessmentData>>,
): UseMutationOptions<
  UpdateAssessmentResponse,
  UpdateAssessmentError,
  Options<UpdateAssessmentData>
> => {
  const mutationOptions: UseMutationOptions<
    UpdateAssessmentResponse,
    UpdateAssessmentError,
    Options<UpdateAssessmentData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await updateAssessment({
        ...options,
        ...localOptions,
        throwOnError: true,
      })
      return data
    },
  }
  return mutationOptions
}

export const deleteQuestionMutation = (
  options?: Partial<Options<DeleteQuestionData>>,
): UseMutationOptions<
  DeleteQuestionResponse,
  DeleteQuestionError,
  Options<DeleteQuestionData>
> => {
  const mutationOptions: UseMutationOptions<
    DeleteQuestionResponse,
    DeleteQuestionError,
    Options<DeleteQuestionData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await deleteQuestion({
        ...options,
        ...localOptions,
        throwOnError: true,
      })
      return data
    },
  }
  return mutationOptions
}

export const getQuestionQueryKey = (options: Options<GetQuestionData>) =>
  createQueryKey("getQuestion", options)

export const getQuestionOptions = (options: Options<GetQuestionData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getQuestion({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      })
      return data
    },
    queryKey: getQuestionQueryKey(options),
  })
}

export const updateQuestionMutation = (
  options?: Partial<Options<UpdateQuestionData>>,
): UseMutationOptions<
  UpdateQuestionResponse,
  UpdateQuestionError,
  Options<UpdateQuestionData>
> => {
  const mutationOptions: UseMutationOptions<
    UpdateQuestionResponse,
    UpdateQuestionError,
    Options<UpdateQuestionData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await updateQuestion({
        ...options,
        ...localOptions,
        throwOnError: true,
      })
      return data
    },
  }
  return mutationOptions
}

export const createUserGroupQueryKey = (
  options: Options<CreateUserGroupData>,
) => createQueryKey("createUserGroup", options)

/**
 * Create a new user group
 */
export const createUserGroupOptions = (
  options: Options<CreateUserGroupData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await createUserGroup({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      })
      return data
    },
    queryKey: createUserGroupQueryKey(options),
  })
}

/**
 * Create a new user group
 */
export const createUserGroupMutation = (
  options?: Partial<Options<CreateUserGroupData>>,
): UseMutationOptions<
  CreateUserGroupResponse,
  CreateUserGroupError,
  Options<CreateUserGroupData>
> => {
  const mutationOptions: UseMutationOptions<
    CreateUserGroupResponse,
    CreateUserGroupError,
    Options<CreateUserGroupData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await createUserGroup({
        ...options,
        ...localOptions,
        throwOnError: true,
      })
      return data
    },
  }
  return mutationOptions
}

/**
 * Remove users from a user group
 */
export const removeUsersFromGroupMutation = (
  options?: Partial<Options<RemoveUsersFromGroupData>>,
): UseMutationOptions<
  RemoveUsersFromGroupResponse,
  RemoveUsersFromGroupError,
  Options<RemoveUsersFromGroupData>
> => {
  const mutationOptions: UseMutationOptions<
    RemoveUsersFromGroupResponse,
    RemoveUsersFromGroupError,
    Options<RemoveUsersFromGroupData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await removeUsersFromGroup({
        ...options,
        ...localOptions,
        throwOnError: true,
      })
      return data
    },
  }
  return mutationOptions
}

export const getUsersForUserGroupQueryKey = (
  options: Options<GetUsersForUserGroupData>,
) => createQueryKey("getUsersForUserGroup", options)

/**
 * Get users for a user group
 */
export const getUsersForUserGroupOptions = (
  options: Options<GetUsersForUserGroupData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getUsersForUserGroup({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      })
      return data
    },
    queryKey: getUsersForUserGroupQueryKey(options),
  })
}

const createInfiniteParams = <
  K extends Pick<QueryKey<Options>[0], "body" | "headers" | "path" | "query">,
>(
  queryKey: QueryKey<Options>,
  page: K,
) => {
  const params = {
    ...queryKey[0],
  }
  if (page.body) {
    params.body = {
      ...(queryKey[0].body as any),
      ...(page.body as any),
    }
  }
  if (page.headers) {
    params.headers = {
      ...queryKey[0].headers,
      ...page.headers,
    }
  }
  if (page.path) {
    params.path = {
      ...(queryKey[0].path as any),
      ...(page.path as any),
    }
  }
  if (page.query) {
    params.query = {
      ...(queryKey[0].query as any),
      ...(page.query as any),
    }
  }
  return params as unknown as typeof page
}

export const getUsersForUserGroupInfiniteQueryKey = (
  options: Options<GetUsersForUserGroupData>,
): QueryKey<Options<GetUsersForUserGroupData>> =>
  createQueryKey("getUsersForUserGroup", options, true)

/**
 * Get users for a user group
 */
export const getUsersForUserGroupInfiniteOptions = (
  options: Options<GetUsersForUserGroupData>,
) => {
  return infiniteQueryOptions<
    GetUsersForUserGroupResponse,
    GetUsersForUserGroupError,
    InfiniteData<GetUsersForUserGroupResponse>,
    QueryKey<Options<GetUsersForUserGroupData>>,
    | number
    | Pick<
        QueryKey<Options<GetUsersForUserGroupData>>[0],
        "body" | "headers" | "path" | "query"
      >
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<GetUsersForUserGroupData>>[0],
          "body" | "headers" | "path" | "query"
        > =
          typeof pageParam === "object"
            ? pageParam
            : {
                query: {
                  pageable: { page: pageParam },
                },
              }
        const params = createInfiniteParams(queryKey, page)
        const { data } = await getUsersForUserGroup({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        })
        return data
      },
      queryKey: getUsersForUserGroupInfiniteQueryKey(options),
    },
  )
}

export const addUsersToGroupQueryKey = (
  options: Options<AddUsersToGroupData>,
) => createQueryKey("addUsersToGroup", options)

/**
 * Add users to a user group
 */
export const addUsersToGroupOptions = (
  options: Options<AddUsersToGroupData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await addUsersToGroup({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      })
      return data
    },
    queryKey: addUsersToGroupQueryKey(options),
  })
}

/**
 * Add users to a user group
 */
export const addUsersToGroupMutation = (
  options?: Partial<Options<AddUsersToGroupData>>,
): UseMutationOptions<
  AddUsersToGroupResponse,
  AddUsersToGroupError,
  Options<AddUsersToGroupData>
> => {
  const mutationOptions: UseMutationOptions<
    AddUsersToGroupResponse,
    AddUsersToGroupError,
    Options<AddUsersToGroupData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await addUsersToGroup({
        ...options,
        ...localOptions,
        throwOnError: true,
      })
      return data
    },
  }
  return mutationOptions
}

/**
 * Remove roles from a user group
 */
export const removeRolesFromGroupMutation = (
  options?: Partial<Options<RemoveRolesFromGroupData>>,
): UseMutationOptions<
  RemoveRolesFromGroupResponse,
  RemoveRolesFromGroupError,
  Options<RemoveRolesFromGroupData>
> => {
  const mutationOptions: UseMutationOptions<
    RemoveRolesFromGroupResponse,
    RemoveRolesFromGroupError,
    Options<RemoveRolesFromGroupData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await removeRolesFromGroup({
        ...options,
        ...localOptions,
        throwOnError: true,
      })
      return data
    },
  }
  return mutationOptions
}

export const getRolesForUserGroupQueryKey = (
  options: Options<GetRolesForUserGroupData>,
) => createQueryKey("getRolesForUserGroup", options)

/**
 * Get roles for a user group
 */
export const getRolesForUserGroupOptions = (
  options: Options<GetRolesForUserGroupData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getRolesForUserGroup({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      })
      return data
    },
    queryKey: getRolesForUserGroupQueryKey(options),
  })
}

export const getRolesForUserGroupInfiniteQueryKey = (
  options: Options<GetRolesForUserGroupData>,
): QueryKey<Options<GetRolesForUserGroupData>> =>
  createQueryKey("getRolesForUserGroup", options, true)

/**
 * Get roles for a user group
 */
export const getRolesForUserGroupInfiniteOptions = (
  options: Options<GetRolesForUserGroupData>,
) => {
  return infiniteQueryOptions<
    GetRolesForUserGroupResponse,
    GetRolesForUserGroupError,
    InfiniteData<GetRolesForUserGroupResponse>,
    QueryKey<Options<GetRolesForUserGroupData>>,
    | number
    | Pick<
        QueryKey<Options<GetRolesForUserGroupData>>[0],
        "body" | "headers" | "path" | "query"
      >
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<GetRolesForUserGroupData>>[0],
          "body" | "headers" | "path" | "query"
        > =
          typeof pageParam === "object"
            ? pageParam
            : {
                query: {
                  pageable: { page: pageParam },
                },
              }
        const params = createInfiniteParams(queryKey, page)
        const { data } = await getRolesForUserGroup({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        })
        return data
      },
      queryKey: getRolesForUserGroupInfiniteQueryKey(options),
    },
  )
}

export const assignRolesToGroupQueryKey = (
  options: Options<AssignRolesToGroupData>,
) => createQueryKey("assignRolesToGroup", options)

/**
 * Assign roles to a user group
 */
export const assignRolesToGroupOptions = (
  options: Options<AssignRolesToGroupData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await assignRolesToGroup({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      })
      return data
    },
    queryKey: assignRolesToGroupQueryKey(options),
  })
}

/**
 * Assign roles to a user group
 */
export const assignRolesToGroupMutation = (
  options?: Partial<Options<AssignRolesToGroupData>>,
): UseMutationOptions<
  AssignRolesToGroupResponse,
  AssignRolesToGroupError,
  Options<AssignRolesToGroupData>
> => {
  const mutationOptions: UseMutationOptions<
    AssignRolesToGroupResponse,
    AssignRolesToGroupError,
    Options<AssignRolesToGroupData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await assignRolesToGroup({
        ...options,
        ...localOptions,
        throwOnError: true,
      })
      return data
    },
  }
  return mutationOptions
}

export const getAllTrainingSessionsQueryKey = (
  options: Options<GetAllTrainingSessionsData>,
) => createQueryKey("getAllTrainingSessions", options)

/**
 * Get all training sessions
 * Fetches a paginated list of training sessions.
 */
export const getAllTrainingSessionsOptions = (
  options: Options<GetAllTrainingSessionsData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getAllTrainingSessions({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      })
      return data
    },
    queryKey: getAllTrainingSessionsQueryKey(options),
  })
}

export const getAllTrainingSessionsInfiniteQueryKey = (
  options: Options<GetAllTrainingSessionsData>,
): QueryKey<Options<GetAllTrainingSessionsData>> =>
  createQueryKey("getAllTrainingSessions", options, true)

/**
 * Get all training sessions
 * Fetches a paginated list of training sessions.
 */
export const getAllTrainingSessionsInfiniteOptions = (
  options: Options<GetAllTrainingSessionsData>,
) => {
  return infiniteQueryOptions<
    GetAllTrainingSessionsResponse,
    GetAllTrainingSessionsError,
    InfiniteData<GetAllTrainingSessionsResponse>,
    QueryKey<Options<GetAllTrainingSessionsData>>,
    | number
    | Pick<
        QueryKey<Options<GetAllTrainingSessionsData>>[0],
        "body" | "headers" | "path" | "query"
      >
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<GetAllTrainingSessionsData>>[0],
          "body" | "headers" | "path" | "query"
        > =
          typeof pageParam === "object"
            ? pageParam
            : {
                query: {
                  pageable: { page: pageParam },
                },
              }
        const params = createInfiniteParams(queryKey, page)
        const { data } = await getAllTrainingSessions({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        })
        return data
      },
      queryKey: getAllTrainingSessionsInfiniteQueryKey(options),
    },
  )
}

export const createTrainingSessionQueryKey = (
  options: Options<CreateTrainingSessionData>,
) => createQueryKey("createTrainingSession", options)

/**
 * Create a new training session
 * Saves a new training session record in the system.
 */
export const createTrainingSessionOptions = (
  options: Options<CreateTrainingSessionData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await createTrainingSession({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      })
      return data
    },
    queryKey: createTrainingSessionQueryKey(options),
  })
}

/**
 * Create a new training session
 * Saves a new training session record in the system.
 */
export const createTrainingSessionMutation = (
  options?: Partial<Options<CreateTrainingSessionData>>,
): UseMutationOptions<
  CreateTrainingSessionResponse,
  CreateTrainingSessionError,
  Options<CreateTrainingSessionData>
> => {
  const mutationOptions: UseMutationOptions<
    CreateTrainingSessionResponse,
    CreateTrainingSessionError,
    Options<CreateTrainingSessionData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await createTrainingSession({
        ...options,
        ...localOptions,
        throwOnError: true,
      })
      return data
    },
  }
  return mutationOptions
}

export const getAllStudentsQueryKey = (options: Options<GetAllStudentsData>) =>
  createQueryKey("getAllStudents", options)

/**
 * Get all students
 * Fetches a paginated list of students.
 */
export const getAllStudentsOptions = (options: Options<GetAllStudentsData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getAllStudents({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      })
      return data
    },
    queryKey: getAllStudentsQueryKey(options),
  })
}

export const getAllStudentsInfiniteQueryKey = (
  options: Options<GetAllStudentsData>,
): QueryKey<Options<GetAllStudentsData>> =>
  createQueryKey("getAllStudents", options, true)

/**
 * Get all students
 * Fetches a paginated list of students.
 */
export const getAllStudentsInfiniteOptions = (
  options: Options<GetAllStudentsData>,
) => {
  return infiniteQueryOptions<
    GetAllStudentsResponse,
    GetAllStudentsError,
    InfiniteData<GetAllStudentsResponse>,
    QueryKey<Options<GetAllStudentsData>>,
    | number
    | Pick<
        QueryKey<Options<GetAllStudentsData>>[0],
        "body" | "headers" | "path" | "query"
      >
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<GetAllStudentsData>>[0],
          "body" | "headers" | "path" | "query"
        > =
          typeof pageParam === "object"
            ? pageParam
            : {
                query: {
                  pageable: { page: pageParam },
                },
              }
        const params = createInfiniteParams(queryKey, page)
        const { data } = await getAllStudents({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        })
        return data
      },
      queryKey: getAllStudentsInfiniteQueryKey(options),
    },
  )
}

export const createStudentQueryKey = (options: Options<CreateStudentData>) =>
  createQueryKey("createStudent", options)

/**
 * Create a new student
 * Saves a new student record in the system.
 */
export const createStudentOptions = (options: Options<CreateStudentData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await createStudent({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      })
      return data
    },
    queryKey: createStudentQueryKey(options),
  })
}

/**
 * Create a new student
 * Saves a new student record in the system.
 */
export const createStudentMutation = (
  options?: Partial<Options<CreateStudentData>>,
): UseMutationOptions<
  CreateStudentResponse,
  CreateStudentError,
  Options<CreateStudentData>
> => {
  const mutationOptions: UseMutationOptions<
    CreateStudentResponse,
    CreateStudentError,
    Options<CreateStudentData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await createStudent({
        ...options,
        ...localOptions,
        throwOnError: true,
      })
      return data
    },
  }
  return mutationOptions
}

export const createRoleQueryKey = (options: Options<CreateRoleData>) =>
  createQueryKey("createRole", options)

/**
 * Create a new role for an organisation
 */
export const createRoleOptions = (options: Options<CreateRoleData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await createRole({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      })
      return data
    },
    queryKey: createRoleQueryKey(options),
  })
}

/**
 * Create a new role for an organisation
 */
export const createRoleMutation = (
  options?: Partial<Options<CreateRoleData>>,
): UseMutationOptions<
  CreateRoleResponse,
  CreateRoleError,
  Options<CreateRoleData>
> => {
  const mutationOptions: UseMutationOptions<
    CreateRoleResponse,
    CreateRoleError,
    Options<CreateRoleData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await createRole({
        ...options,
        ...localOptions,
        throwOnError: true,
      })
      return data
    },
  }
  return mutationOptions
}

export const findPrerequisitesQueryKey = (
  options: Options<FindPrerequisitesData>,
) => createQueryKey("findPrerequisites", options)

export const findPrerequisitesOptions = (
  options: Options<FindPrerequisitesData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await findPrerequisites({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      })
      return data
    },
    queryKey: findPrerequisitesQueryKey(options),
  })
}

export const findPrerequisitesInfiniteQueryKey = (
  options: Options<FindPrerequisitesData>,
): QueryKey<Options<FindPrerequisitesData>> =>
  createQueryKey("findPrerequisites", options, true)

export const findPrerequisitesInfiniteOptions = (
  options: Options<FindPrerequisitesData>,
) => {
  return infiniteQueryOptions<
    FindPrerequisitesResponse,
    FindPrerequisitesError,
    InfiniteData<FindPrerequisitesResponse>,
    QueryKey<Options<FindPrerequisitesData>>,
    | number
    | Pick<
        QueryKey<Options<FindPrerequisitesData>>[0],
        "body" | "headers" | "path" | "query"
      >
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<FindPrerequisitesData>>[0],
          "body" | "headers" | "path" | "query"
        > =
          typeof pageParam === "object"
            ? pageParam
            : {
                query: {
                  pageable: { page: pageParam },
                },
              }
        const params = createInfiniteParams(queryKey, page)
        const { data } = await findPrerequisites({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        })
        return data
      },
      queryKey: findPrerequisitesInfiniteQueryKey(options),
    },
  )
}

export const createPrerequisiteQueryKey = (
  options: Options<CreatePrerequisiteData>,
) => createQueryKey("createPrerequisite", options)

export const createPrerequisiteOptions = (
  options: Options<CreatePrerequisiteData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await createPrerequisite({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      })
      return data
    },
    queryKey: createPrerequisiteQueryKey(options),
  })
}

export const createPrerequisiteMutation = (
  options?: Partial<Options<CreatePrerequisiteData>>,
): UseMutationOptions<
  CreatePrerequisiteResponse,
  CreatePrerequisiteError,
  Options<CreatePrerequisiteData>
> => {
  const mutationOptions: UseMutationOptions<
    CreatePrerequisiteResponse,
    CreatePrerequisiteError,
    Options<CreatePrerequisiteData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await createPrerequisite({
        ...options,
        ...localOptions,
        throwOnError: true,
      })
      return data
    },
  }
  return mutationOptions
}

export const createPrerequisiteGroupQueryKey = (
  options: Options<CreatePrerequisiteGroupData>,
) => createQueryKey("createPrerequisiteGroup", options)

export const createPrerequisiteGroupOptions = (
  options: Options<CreatePrerequisiteGroupData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await createPrerequisiteGroup({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      })
      return data
    },
    queryKey: createPrerequisiteGroupQueryKey(options),
  })
}

export const createPrerequisiteGroupMutation = (
  options?: Partial<Options<CreatePrerequisiteGroupData>>,
): UseMutationOptions<
  CreatePrerequisiteGroupResponse,
  CreatePrerequisiteGroupError,
  Options<CreatePrerequisiteGroupData>
> => {
  const mutationOptions: UseMutationOptions<
    CreatePrerequisiteGroupResponse,
    CreatePrerequisiteGroupError,
    Options<CreatePrerequisiteGroupData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await createPrerequisiteGroup({
        ...options,
        ...localOptions,
        throwOnError: true,
      })
      return data
    },
  }
  return mutationOptions
}

export const getPrerequisiteTypesQueryKey = (
  options: Options<GetPrerequisiteTypesData>,
) => createQueryKey("getPrerequisiteTypes", options)

export const getPrerequisiteTypesOptions = (
  options: Options<GetPrerequisiteTypesData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getPrerequisiteTypes({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      })
      return data
    },
    queryKey: getPrerequisiteTypesQueryKey(options),
  })
}

export const getPrerequisiteTypesInfiniteQueryKey = (
  options: Options<GetPrerequisiteTypesData>,
): QueryKey<Options<GetPrerequisiteTypesData>> =>
  createQueryKey("getPrerequisiteTypes", options, true)

export const getPrerequisiteTypesInfiniteOptions = (
  options: Options<GetPrerequisiteTypesData>,
) => {
  return infiniteQueryOptions<
    GetPrerequisiteTypesResponse,
    GetPrerequisiteTypesError,
    InfiniteData<GetPrerequisiteTypesResponse>,
    QueryKey<Options<GetPrerequisiteTypesData>>,
    | number
    | Pick<
        QueryKey<Options<GetPrerequisiteTypesData>>[0],
        "body" | "headers" | "path" | "query"
      >
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<GetPrerequisiteTypesData>>[0],
          "body" | "headers" | "path" | "query"
        > =
          typeof pageParam === "object"
            ? pageParam
            : {
                query: {
                  pageable: { page: pageParam },
                },
              }
        const params = createInfiniteParams(queryKey, page)
        const { data } = await getPrerequisiteTypes({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        })
        return data
      },
      queryKey: getPrerequisiteTypesInfiniteQueryKey(options),
    },
  )
}

export const createPrerequisiteTypeQueryKey = (
  options: Options<CreatePrerequisiteTypeData>,
) => createQueryKey("createPrerequisiteType", options)

export const createPrerequisiteTypeOptions = (
  options: Options<CreatePrerequisiteTypeData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await createPrerequisiteType({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      })
      return data
    },
    queryKey: createPrerequisiteTypeQueryKey(options),
  })
}

export const createPrerequisiteTypeMutation = (
  options?: Partial<Options<CreatePrerequisiteTypeData>>,
): UseMutationOptions<
  CreatePrerequisiteTypeResponse,
  CreatePrerequisiteTypeError,
  Options<CreatePrerequisiteTypeData>
> => {
  const mutationOptions: UseMutationOptions<
    CreatePrerequisiteTypeResponse,
    CreatePrerequisiteTypeError,
    Options<CreatePrerequisiteTypeData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await createPrerequisiteType({
        ...options,
        ...localOptions,
        throwOnError: true,
      })
      return data
    },
  }
  return mutationOptions
}

export const getAllOrganisationsQueryKey = (
  options: Options<GetAllOrganisationsData>,
) => createQueryKey("getAllOrganisations", options)

/**
 * Get all organisations
 */
export const getAllOrganisationsOptions = (
  options: Options<GetAllOrganisationsData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getAllOrganisations({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      })
      return data
    },
    queryKey: getAllOrganisationsQueryKey(options),
  })
}

export const getAllOrganisationsInfiniteQueryKey = (
  options: Options<GetAllOrganisationsData>,
): QueryKey<Options<GetAllOrganisationsData>> =>
  createQueryKey("getAllOrganisations", options, true)

/**
 * Get all organisations
 */
export const getAllOrganisationsInfiniteOptions = (
  options: Options<GetAllOrganisationsData>,
) => {
  return infiniteQueryOptions<
    GetAllOrganisationsResponse,
    GetAllOrganisationsError,
    InfiniteData<GetAllOrganisationsResponse>,
    QueryKey<Options<GetAllOrganisationsData>>,
    | number
    | Pick<
        QueryKey<Options<GetAllOrganisationsData>>[0],
        "body" | "headers" | "path" | "query"
      >
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<GetAllOrganisationsData>>[0],
          "body" | "headers" | "path" | "query"
        > =
          typeof pageParam === "object"
            ? pageParam
            : {
                query: {
                  pageable: { page: pageParam },
                },
              }
        const params = createInfiniteParams(queryKey, page)
        const { data } = await getAllOrganisations({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        })
        return data
      },
      queryKey: getAllOrganisationsInfiniteQueryKey(options),
    },
  )
}

export const createOrganisationQueryKey = (
  options: Options<CreateOrganisationData>,
) => createQueryKey("createOrganisation", options)

/**
 * Create a new organisation
 */
export const createOrganisationOptions = (
  options: Options<CreateOrganisationData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await createOrganisation({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      })
      return data
    },
    queryKey: createOrganisationQueryKey(options),
  })
}

/**
 * Create a new organisation
 */
export const createOrganisationMutation = (
  options?: Partial<Options<CreateOrganisationData>>,
): UseMutationOptions<
  CreateOrganisationResponse,
  CreateOrganisationError,
  Options<CreateOrganisationData>
> => {
  const mutationOptions: UseMutationOptions<
    CreateOrganisationResponse,
    CreateOrganisationError,
    Options<CreateOrganisationData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await createOrganisation({
        ...options,
        ...localOptions,
        throwOnError: true,
      })
      return data
    },
  }
  return mutationOptions
}

export const getAllInstructorsQueryKey = (
  options: Options<GetAllInstructorsData>,
) => createQueryKey("getAllInstructors", options)

/**
 * Get all instructors
 * Fetches a paginated list of instructors.
 */
export const getAllInstructorsOptions = (
  options: Options<GetAllInstructorsData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getAllInstructors({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      })
      return data
    },
    queryKey: getAllInstructorsQueryKey(options),
  })
}

export const getAllInstructorsInfiniteQueryKey = (
  options: Options<GetAllInstructorsData>,
): QueryKey<Options<GetAllInstructorsData>> =>
  createQueryKey("getAllInstructors", options, true)

/**
 * Get all instructors
 * Fetches a paginated list of instructors.
 */
export const getAllInstructorsInfiniteOptions = (
  options: Options<GetAllInstructorsData>,
) => {
  return infiniteQueryOptions<
    GetAllInstructorsResponse,
    GetAllInstructorsError,
    InfiniteData<GetAllInstructorsResponse>,
    QueryKey<Options<GetAllInstructorsData>>,
    | number
    | Pick<
        QueryKey<Options<GetAllInstructorsData>>[0],
        "body" | "headers" | "path" | "query"
      >
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<GetAllInstructorsData>>[0],
          "body" | "headers" | "path" | "query"
        > =
          typeof pageParam === "object"
            ? pageParam
            : {
                query: {
                  pageable: { page: pageParam },
                },
              }
        const params = createInfiniteParams(queryKey, page)
        const { data } = await getAllInstructors({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        })
        return data
      },
      queryKey: getAllInstructorsInfiniteQueryKey(options),
    },
  )
}

export const createInstructorQueryKey = (
  options: Options<CreateInstructorData>,
) => createQueryKey("createInstructor", options)

/**
 * Create a new instructor
 * Saves a new instructor record in the system.
 */
export const createInstructorOptions = (
  options: Options<CreateInstructorData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await createInstructor({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      })
      return data
    },
    queryKey: createInstructorQueryKey(options),
  })
}

/**
 * Create a new instructor
 * Saves a new instructor record in the system.
 */
export const createInstructorMutation = (
  options?: Partial<Options<CreateInstructorData>>,
): UseMutationOptions<
  CreateInstructorResponse,
  CreateInstructorError,
  Options<CreateInstructorData>
> => {
  const mutationOptions: UseMutationOptions<
    CreateInstructorResponse,
    CreateInstructorError,
    Options<CreateInstructorData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await createInstructor({
        ...options,
        ...localOptions,
        throwOnError: true,
      })
      return data
    },
  }
  return mutationOptions
}

export const getCoursesQueryKey = (options: Options<GetCoursesData>) =>
  createQueryKey("getCourses", options)

export const getCoursesOptions = (options: Options<GetCoursesData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getCourses({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      })
      return data
    },
    queryKey: getCoursesQueryKey(options),
  })
}

export const getCoursesInfiniteQueryKey = (
  options: Options<GetCoursesData>,
): QueryKey<Options<GetCoursesData>> =>
  createQueryKey("getCourses", options, true)

export const getCoursesInfiniteOptions = (options: Options<GetCoursesData>) => {
  return infiniteQueryOptions<
    GetCoursesResponse,
    GetCoursesError,
    InfiniteData<GetCoursesResponse>,
    QueryKey<Options<GetCoursesData>>,
    | number
    | Pick<
        QueryKey<Options<GetCoursesData>>[0],
        "body" | "headers" | "path" | "query"
      >
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<GetCoursesData>>[0],
          "body" | "headers" | "path" | "query"
        > =
          typeof pageParam === "object"
            ? pageParam
            : {
                query: {
                  pageable: { page: pageParam },
                },
              }
        const params = createInfiniteParams(queryKey, page)
        const { data } = await getCourses({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        })
        return data
      },
      queryKey: getCoursesInfiniteQueryKey(options),
    },
  )
}

export const createCourseQueryKey = (options?: Options<CreateCourseData>) =>
  createQueryKey("createCourse", options)

export const createCourseOptions = (options?: Options<CreateCourseData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await createCourse({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      })
      return data
    },
    queryKey: createCourseQueryKey(options),
  })
}

export const createCourseMutation = (
  options?: Partial<Options<CreateCourseData>>,
): UseMutationOptions<
  CreateCourseResponse,
  CreateCourseError,
  Options<CreateCourseData>
> => {
  const mutationOptions: UseMutationOptions<
    CreateCourseResponse,
    CreateCourseError,
    Options<CreateCourseData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await createCourse({
        ...options,
        ...localOptions,
        throwOnError: true,
      })
      return data
    },
  }
  return mutationOptions
}

export const getLessonsQueryKey = (options: Options<GetLessonsData>) =>
  createQueryKey("getLessons", options)

export const getLessonsOptions = (options: Options<GetLessonsData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getLessons({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      })
      return data
    },
    queryKey: getLessonsQueryKey(options),
  })
}

export const getLessonsInfiniteQueryKey = (
  options: Options<GetLessonsData>,
): QueryKey<Options<GetLessonsData>> =>
  createQueryKey("getLessons", options, true)

export const getLessonsInfiniteOptions = (options: Options<GetLessonsData>) => {
  return infiniteQueryOptions<
    GetLessonsResponse,
    GetLessonsError,
    InfiniteData<GetLessonsResponse>,
    QueryKey<Options<GetLessonsData>>,
    | number
    | Pick<
        QueryKey<Options<GetLessonsData>>[0],
        "body" | "headers" | "path" | "query"
      >
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<GetLessonsData>>[0],
          "body" | "headers" | "path" | "query"
        > =
          typeof pageParam === "object"
            ? pageParam
            : {
                query: {
                  pageable: { page: pageParam },
                },
              }
        const params = createInfiniteParams(queryKey, page)
        const { data } = await getLessons({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        })
        return data
      },
      queryKey: getLessonsInfiniteQueryKey(options),
    },
  )
}

export const createLessonQueryKey = (options: Options<CreateLessonData>) =>
  createQueryKey("createLesson", options)

export const createLessonOptions = (options: Options<CreateLessonData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await createLesson({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      })
      return data
    },
    queryKey: createLessonQueryKey(options),
  })
}

export const createLessonMutation = (
  options?: Partial<Options<CreateLessonData>>,
): UseMutationOptions<
  CreateLessonResponse,
  CreateLessonError,
  Options<CreateLessonData>
> => {
  const mutationOptions: UseMutationOptions<
    CreateLessonResponse,
    CreateLessonError,
    Options<CreateLessonData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await createLesson({
        ...options,
        ...localOptions,
        throwOnError: true,
      })
      return data
    },
  }
  return mutationOptions
}

export const getAllCategoriesQueryKey = (
  options: Options<GetAllCategoriesData>,
) => createQueryKey("getAllCategories", options)

export const getAllCategoriesOptions = (
  options: Options<GetAllCategoriesData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getAllCategories({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      })
      return data
    },
    queryKey: getAllCategoriesQueryKey(options),
  })
}

export const getAllCategoriesInfiniteQueryKey = (
  options: Options<GetAllCategoriesData>,
): QueryKey<Options<GetAllCategoriesData>> =>
  createQueryKey("getAllCategories", options, true)

export const getAllCategoriesInfiniteOptions = (
  options: Options<GetAllCategoriesData>,
) => {
  return infiniteQueryOptions<
    GetAllCategoriesResponse,
    GetAllCategoriesError,
    InfiniteData<GetAllCategoriesResponse>,
    QueryKey<Options<GetAllCategoriesData>>,
    | number
    | Pick<
        QueryKey<Options<GetAllCategoriesData>>[0],
        "body" | "headers" | "path" | "query"
      >
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<GetAllCategoriesData>>[0],
          "body" | "headers" | "path" | "query"
        > =
          typeof pageParam === "object"
            ? pageParam
            : {
                query: {
                  pageable: { page: pageParam },
                },
              }
        const params = createInfiniteParams(queryKey, page)
        const { data } = await getAllCategories({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        })
        return data
      },
      queryKey: getAllCategoriesInfiniteQueryKey(options),
    },
  )
}

export const createCategoryQueryKey = (options: Options<CreateCategoryData>) =>
  createQueryKey("createCategory", options)

export const createCategoryOptions = (options: Options<CreateCategoryData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await createCategory({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      })
      return data
    },
    queryKey: createCategoryQueryKey(options),
  })
}

export const createCategoryMutation = (
  options?: Partial<Options<CreateCategoryData>>,
): UseMutationOptions<
  CreateCategoryResponse,
  CreateCategoryError,
  Options<CreateCategoryData>
> => {
  const mutationOptions: UseMutationOptions<
    CreateCategoryResponse,
    CreateCategoryError,
    Options<CreateCategoryData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await createCategory({
        ...options,
        ...localOptions,
        throwOnError: true,
      })
      return data
    },
  }
  return mutationOptions
}

export const createAssessmentQueryKey = (
  options: Options<CreateAssessmentData>,
) => createQueryKey("createAssessment", options)

export const createAssessmentOptions = (
  options: Options<CreateAssessmentData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await createAssessment({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      })
      return data
    },
    queryKey: createAssessmentQueryKey(options),
  })
}

export const createAssessmentMutation = (
  options?: Partial<Options<CreateAssessmentData>>,
): UseMutationOptions<
  CreateAssessmentResponse,
  CreateAssessmentError,
  Options<CreateAssessmentData>
> => {
  const mutationOptions: UseMutationOptions<
    CreateAssessmentResponse,
    CreateAssessmentError,
    Options<CreateAssessmentData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await createAssessment({
        ...options,
        ...localOptions,
        throwOnError: true,
      })
      return data
    },
  }
  return mutationOptions
}

export const getQuestionsQueryKey = (options: Options<GetQuestionsData>) =>
  createQueryKey("getQuestions", options)

export const getQuestionsOptions = (options: Options<GetQuestionsData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getQuestions({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      })
      return data
    },
    queryKey: getQuestionsQueryKey(options),
  })
}

export const getQuestionsInfiniteQueryKey = (
  options: Options<GetQuestionsData>,
): QueryKey<Options<GetQuestionsData>> =>
  createQueryKey("getQuestions", options, true)

export const getQuestionsInfiniteOptions = (
  options: Options<GetQuestionsData>,
) => {
  return infiniteQueryOptions<
    GetQuestionsResponse,
    GetQuestionsError,
    InfiniteData<GetQuestionsResponse>,
    QueryKey<Options<GetQuestionsData>>,
    | number
    | Pick<
        QueryKey<Options<GetQuestionsData>>[0],
        "body" | "headers" | "path" | "query"
      >
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<GetQuestionsData>>[0],
          "body" | "headers" | "path" | "query"
        > =
          typeof pageParam === "object"
            ? pageParam
            : {
                query: {
                  pageable: { page: pageParam },
                },
              }
        const params = createInfiniteParams(queryKey, page)
        const { data } = await getQuestions({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        })
        return data
      },
      queryKey: getQuestionsInfiniteQueryKey(options),
    },
  )
}

export const createQuestionQueryKey = (options: Options<CreateQuestionData>) =>
  createQueryKey("createQuestion", options)

export const createQuestionOptions = (options: Options<CreateQuestionData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await createQuestion({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      })
      return data
    },
    queryKey: createQuestionQueryKey(options),
  })
}

export const createQuestionMutation = (
  options?: Partial<Options<CreateQuestionData>>,
): UseMutationOptions<
  CreateQuestionResponse,
  CreateQuestionError,
  Options<CreateQuestionData>
> => {
  const mutationOptions: UseMutationOptions<
    CreateQuestionResponse,
    CreateQuestionError,
    Options<CreateQuestionData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await createQuestion({
        ...options,
        ...localOptions,
        throwOnError: true,
      })
      return data
    },
  }
  return mutationOptions
}

export const searchQueryKey = (options: Options<SearchData>) =>
  createQueryKey("search", options)

/**
 * Search users
 * Fetches a paginated list of users based on optional filters. Supports pagination and sorting.
 */
export const searchOptions = (options: Options<SearchData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await search({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      })
      return data
    },
    queryKey: searchQueryKey(options),
  })
}

export const searchInfiniteQueryKey = (
  options: Options<SearchData>,
): QueryKey<Options<SearchData>> => createQueryKey("search", options, true)

/**
 * Search users
 * Fetches a paginated list of users based on optional filters. Supports pagination and sorting.
 */
export const searchInfiniteOptions = (options: Options<SearchData>) => {
  return infiniteQueryOptions<
    SearchResponse,
    SearchError,
    InfiniteData<SearchResponse>,
    QueryKey<Options<SearchData>>,
    | number
    | Pick<
        QueryKey<Options<SearchData>>[0],
        "body" | "headers" | "path" | "query"
      >
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<SearchData>>[0],
          "body" | "headers" | "path" | "query"
        > =
          typeof pageParam === "object"
            ? pageParam
            : {
                query: {
                  pageable: { page: pageParam },
                },
              }
        const params = createInfiniteParams(queryKey, page)
        const { data } = await search({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        })
        return data
      },
      queryKey: searchInfiniteQueryKey(options),
    },
  )
}

export const getProfileImageQueryKey = (
  options: Options<GetProfileImageData>,
) => createQueryKey("getProfileImage", options)

/**
 * Get user profile image by file name
 */
export const getProfileImageOptions = (
  options: Options<GetProfileImageData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getProfileImage({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      })
      return data
    },
    queryKey: getProfileImageQueryKey(options),
  })
}

export const getUsersByOrganisationQueryKey = (
  options: Options<GetUsersByOrganisationData>,
) => createQueryKey("getUsersByOrganisation", options)

/**
 * Get users by organisation ID
 */
export const getUsersByOrganisationOptions = (
  options: Options<GetUsersByOrganisationData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getUsersByOrganisation({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      })
      return data
    },
    queryKey: getUsersByOrganisationQueryKey(options),
  })
}

export const getUsersByOrganisationInfiniteQueryKey = (
  options: Options<GetUsersByOrganisationData>,
): QueryKey<Options<GetUsersByOrganisationData>> =>
  createQueryKey("getUsersByOrganisation", options, true)

/**
 * Get users by organisation ID
 */
export const getUsersByOrganisationInfiniteOptions = (
  options: Options<GetUsersByOrganisationData>,
) => {
  return infiniteQueryOptions<
    GetUsersByOrganisationResponse,
    GetUsersByOrganisationError,
    InfiniteData<GetUsersByOrganisationResponse>,
    QueryKey<Options<GetUsersByOrganisationData>>,
    | number
    | Pick<
        QueryKey<Options<GetUsersByOrganisationData>>[0],
        "body" | "headers" | "path" | "query"
      >
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<GetUsersByOrganisationData>>[0],
          "body" | "headers" | "path" | "query"
        > =
          typeof pageParam === "object"
            ? pageParam
            : {
                query: {
                  pageable: { page: pageParam },
                },
              }
        const params = createInfiniteParams(queryKey, page)
        const { data } = await getUsersByOrganisation({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        })
        return data
      },
      queryKey: getUsersByOrganisationInfiniteQueryKey(options),
    },
  )
}

export const search1QueryKey = (options: Options<Search1Data>) =>
  createQueryKey("search1", options)

/**
 * Search user groups
 * Fetches a paginated list of user groups based on optional filters. Supports pagination and sorting.
 */
export const search1Options = (options: Options<Search1Data>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await search1({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      })
      return data
    },
    queryKey: search1QueryKey(options),
  })
}

export const search1InfiniteQueryKey = (
  options: Options<Search1Data>,
): QueryKey<Options<Search1Data>> => createQueryKey("search1", options, true)

/**
 * Search user groups
 * Fetches a paginated list of user groups based on optional filters. Supports pagination and sorting.
 */
export const search1InfiniteOptions = (options: Options<Search1Data>) => {
  return infiniteQueryOptions<
    Search1Response,
    Search1Error,
    InfiniteData<Search1Response>,
    QueryKey<Options<Search1Data>>,
    | number
    | Pick<
        QueryKey<Options<Search1Data>>[0],
        "body" | "headers" | "path" | "query"
      >
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<Search1Data>>[0],
          "body" | "headers" | "path" | "query"
        > =
          typeof pageParam === "object"
            ? pageParam
            : {
                query: {
                  pageable: { page: pageParam },
                },
              }
        const params = createInfiniteParams(queryKey, page)
        const { data } = await search1({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        })
        return data
      },
      queryKey: search1InfiniteQueryKey(options),
    },
  )
}

export const getUserGroupsByOrganisationQueryKey = (
  options: Options<GetUserGroupsByOrganisationData>,
) => createQueryKey("getUserGroupsByOrganisation", options)

/**
 * Get all user groups for an organisation
 */
export const getUserGroupsByOrganisationOptions = (
  options: Options<GetUserGroupsByOrganisationData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getUserGroupsByOrganisation({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      })
      return data
    },
    queryKey: getUserGroupsByOrganisationQueryKey(options),
  })
}

export const getUserGroupsByOrganisationInfiniteQueryKey = (
  options: Options<GetUserGroupsByOrganisationData>,
): QueryKey<Options<GetUserGroupsByOrganisationData>> =>
  createQueryKey("getUserGroupsByOrganisation", options, true)

/**
 * Get all user groups for an organisation
 */
export const getUserGroupsByOrganisationInfiniteOptions = (
  options: Options<GetUserGroupsByOrganisationData>,
) => {
  return infiniteQueryOptions<
    GetUserGroupsByOrganisationResponse,
    GetUserGroupsByOrganisationError,
    InfiniteData<GetUserGroupsByOrganisationResponse>,
    QueryKey<Options<GetUserGroupsByOrganisationData>>,
    | number
    | Pick<
        QueryKey<Options<GetUserGroupsByOrganisationData>>[0],
        "body" | "headers" | "path" | "query"
      >
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<GetUserGroupsByOrganisationData>>[0],
          "body" | "headers" | "path" | "query"
        > =
          typeof pageParam === "object"
            ? pageParam
            : {
                query: {
                  pageable: { page: pageParam },
                },
              }
        const params = createInfiniteParams(queryKey, page)
        const { data } = await getUserGroupsByOrganisation({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        })
        return data
      },
      queryKey: getUserGroupsByOrganisationInfiniteQueryKey(options),
    },
  )
}

export const searchTrainingSessionsQueryKey = (
  options: Options<SearchTrainingSessionsData>,
) => createQueryKey("searchTrainingSessions", options)

/**
 * Search training sessions
 * Search for training sessions based on criteria.
 */
export const searchTrainingSessionsOptions = (
  options: Options<SearchTrainingSessionsData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await searchTrainingSessions({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      })
      return data
    },
    queryKey: searchTrainingSessionsQueryKey(options),
  })
}

export const searchTrainingSessionsInfiniteQueryKey = (
  options: Options<SearchTrainingSessionsData>,
): QueryKey<Options<SearchTrainingSessionsData>> =>
  createQueryKey("searchTrainingSessions", options, true)

/**
 * Search training sessions
 * Search for training sessions based on criteria.
 */
export const searchTrainingSessionsInfiniteOptions = (
  options: Options<SearchTrainingSessionsData>,
) => {
  return infiniteQueryOptions<
    SearchTrainingSessionsResponse,
    SearchTrainingSessionsError,
    InfiniteData<SearchTrainingSessionsResponse>,
    QueryKey<Options<SearchTrainingSessionsData>>,
    | number
    | Pick<
        QueryKey<Options<SearchTrainingSessionsData>>[0],
        "body" | "headers" | "path" | "query"
      >
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<SearchTrainingSessionsData>>[0],
          "body" | "headers" | "path" | "query"
        > =
          typeof pageParam === "object"
            ? pageParam
            : {
                query: {
                  pageable: { page: pageParam },
                },
              }
        const params = createInfiniteParams(queryKey, page)
        const { data } = await searchTrainingSessions({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        })
        return data
      },
      queryKey: searchTrainingSessionsInfiniteQueryKey(options),
    },
  )
}

export const searchStudentsQueryKey = (options: Options<SearchStudentsData>) =>
  createQueryKey("searchStudents", options)

/**
 * Search students
 * Search for students based on criteria.
 */
export const searchStudentsOptions = (options: Options<SearchStudentsData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await searchStudents({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      })
      return data
    },
    queryKey: searchStudentsQueryKey(options),
  })
}

export const searchStudentsInfiniteQueryKey = (
  options: Options<SearchStudentsData>,
): QueryKey<Options<SearchStudentsData>> =>
  createQueryKey("searchStudents", options, true)

/**
 * Search students
 * Search for students based on criteria.
 */
export const searchStudentsInfiniteOptions = (
  options: Options<SearchStudentsData>,
) => {
  return infiniteQueryOptions<
    SearchStudentsResponse,
    SearchStudentsError,
    InfiniteData<SearchStudentsResponse>,
    QueryKey<Options<SearchStudentsData>>,
    | number
    | Pick<
        QueryKey<Options<SearchStudentsData>>[0],
        "body" | "headers" | "path" | "query"
      >
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<SearchStudentsData>>[0],
          "body" | "headers" | "path" | "query"
        > =
          typeof pageParam === "object"
            ? pageParam
            : {
                query: {
                  pageable: { page: pageParam },
                },
              }
        const params = createInfiniteParams(queryKey, page)
        const { data } = await searchStudents({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        })
        return data
      },
      queryKey: searchStudentsInfiniteQueryKey(options),
    },
  )
}

export const getEffectiveRolesForUserQueryKey = (
  options: Options<GetEffectiveRolesForUserData>,
) => createQueryKey("getEffectiveRolesForUser", options)

/**
 * Get effective roles for a user
 * Fetches roles for a user, considering both direct and group assignments, with precedence given to user roles.
 */
export const getEffectiveRolesForUserOptions = (
  options: Options<GetEffectiveRolesForUserData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getEffectiveRolesForUser({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      })
      return data
    },
    queryKey: getEffectiveRolesForUserQueryKey(options),
  })
}

export const searchRolesQueryKey = (options: Options<SearchRolesData>) =>
  createQueryKey("searchRoles", options)

/**
 * Search roles
 * Fetches a paginated list of roles based on optional filters. Supports pagination and sorting.
 */
export const searchRolesOptions = (options: Options<SearchRolesData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await searchRoles({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      })
      return data
    },
    queryKey: searchRolesQueryKey(options),
  })
}

export const searchRolesInfiniteQueryKey = (
  options: Options<SearchRolesData>,
): QueryKey<Options<SearchRolesData>> =>
  createQueryKey("searchRoles", options, true)

/**
 * Search roles
 * Fetches a paginated list of roles based on optional filters. Supports pagination and sorting.
 */
export const searchRolesInfiniteOptions = (
  options: Options<SearchRolesData>,
) => {
  return infiniteQueryOptions<
    SearchRolesResponse,
    SearchRolesError,
    InfiniteData<SearchRolesResponse>,
    QueryKey<Options<SearchRolesData>>,
    | number
    | Pick<
        QueryKey<Options<SearchRolesData>>[0],
        "body" | "headers" | "path" | "query"
      >
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<SearchRolesData>>[0],
          "body" | "headers" | "path" | "query"
        > =
          typeof pageParam === "object"
            ? pageParam
            : {
                query: {
                  pageable: { page: pageParam },
                },
              }
        const params = createInfiniteParams(queryKey, page)
        const { data } = await searchRoles({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        })
        return data
      },
      queryKey: searchRolesInfiniteQueryKey(options),
    },
  )
}

export const getAllPermissionsQueryKey = (
  options?: Options<GetAllPermissionsData>,
) => createQueryKey("getAllPermissions", options)

/**
 * Fetch all available permissions
 * Retrieve a list of all available permissions that can be assigned to roles.
 */
export const getAllPermissionsOptions = (
  options?: Options<GetAllPermissionsData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getAllPermissions({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      })
      return data
    },
    queryKey: getAllPermissionsQueryKey(options),
  })
}

export const getRolesByOrganisationQueryKey = (
  options: Options<GetRolesByOrganisationData>,
) => createQueryKey("getRolesByOrganisation", options)

/**
 * Get all roles for a specific organisation
 */
export const getRolesByOrganisationOptions = (
  options: Options<GetRolesByOrganisationData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getRolesByOrganisation({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      })
      return data
    },
    queryKey: getRolesByOrganisationQueryKey(options),
  })
}

export const getRolesByOrganisationInfiniteQueryKey = (
  options: Options<GetRolesByOrganisationData>,
): QueryKey<Options<GetRolesByOrganisationData>> =>
  createQueryKey("getRolesByOrganisation", options, true)

/**
 * Get all roles for a specific organisation
 */
export const getRolesByOrganisationInfiniteOptions = (
  options: Options<GetRolesByOrganisationData>,
) => {
  return infiniteQueryOptions<
    GetRolesByOrganisationResponse,
    GetRolesByOrganisationError,
    InfiniteData<GetRolesByOrganisationResponse>,
    QueryKey<Options<GetRolesByOrganisationData>>,
    | number
    | Pick<
        QueryKey<Options<GetRolesByOrganisationData>>[0],
        "body" | "headers" | "path" | "query"
      >
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<GetRolesByOrganisationData>>[0],
          "body" | "headers" | "path" | "query"
        > =
          typeof pageParam === "object"
            ? pageParam
            : {
                query: {
                  pageable: { page: pageParam },
                },
              }
        const params = createInfiniteParams(queryKey, page)
        const { data } = await getRolesByOrganisation({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        })
        return data
      },
      queryKey: getRolesByOrganisationInfiniteQueryKey(options),
    },
  )
}

export const search2QueryKey = (options: Options<Search2Data>) =>
  createQueryKey("search2", options)

/**
 * Search organisations
 * Fetches a paginated list of organisations based on optional filters. Supports pagination and sorting.
 */
export const search2Options = (options: Options<Search2Data>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await search2({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      })
      return data
    },
    queryKey: search2QueryKey(options),
  })
}

export const search2InfiniteQueryKey = (
  options: Options<Search2Data>,
): QueryKey<Options<Search2Data>> => createQueryKey("search2", options, true)

/**
 * Search organisations
 * Fetches a paginated list of organisations based on optional filters. Supports pagination and sorting.
 */
export const search2InfiniteOptions = (options: Options<Search2Data>) => {
  return infiniteQueryOptions<
    Search2Response,
    Search2Error,
    InfiniteData<Search2Response>,
    QueryKey<Options<Search2Data>>,
    | number
    | Pick<
        QueryKey<Options<Search2Data>>[0],
        "body" | "headers" | "path" | "query"
      >
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<Search2Data>>[0],
          "body" | "headers" | "path" | "query"
        > =
          typeof pageParam === "object"
            ? pageParam
            : {
                query: {
                  pageable: { page: pageParam },
                },
              }
        const params = createInfiniteParams(queryKey, page)
        const { data } = await search2({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        })
        return data
      },
      queryKey: search2InfiniteQueryKey(options),
    },
  )
}

export const searchInstructorsQueryKey = (
  options: Options<SearchInstructorsData>,
) => createQueryKey("searchInstructors", options)

/**
 * Search instructors
 * Search for instructors based on criteria.
 */
export const searchInstructorsOptions = (
  options: Options<SearchInstructorsData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await searchInstructors({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      })
      return data
    },
    queryKey: searchInstructorsQueryKey(options),
  })
}

export const searchInstructorsInfiniteQueryKey = (
  options: Options<SearchInstructorsData>,
): QueryKey<Options<SearchInstructorsData>> =>
  createQueryKey("searchInstructors", options, true)

/**
 * Search instructors
 * Search for instructors based on criteria.
 */
export const searchInstructorsInfiniteOptions = (
  options: Options<SearchInstructorsData>,
) => {
  return infiniteQueryOptions<
    SearchInstructorsResponse,
    SearchInstructorsError,
    InfiniteData<SearchInstructorsResponse>,
    QueryKey<Options<SearchInstructorsData>>,
    | number
    | Pick<
        QueryKey<Options<SearchInstructorsData>>[0],
        "body" | "headers" | "path" | "query"
      >
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<SearchInstructorsData>>[0],
          "body" | "headers" | "path" | "query"
        > =
          typeof pageParam === "object"
            ? pageParam
            : {
                query: {
                  pageable: { page: pageParam },
                },
              }
        const params = createInfiniteParams(queryKey, page)
        const { data } = await searchInstructors({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        })
        return data
      },
      queryKey: searchInstructorsInfiniteQueryKey(options),
    },
  )
}

export const getCourseThumbnailQueryKey = (
  options: Options<GetCourseThumbnailData>,
) => createQueryKey("getCourseThumbnail", options)

export const getCourseThumbnailOptions = (
  options: Options<GetCourseThumbnailData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getCourseThumbnail({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      })
      return data
    },
    queryKey: getCourseThumbnailQueryKey(options),
  })
}

export const getAssessmentsByLessonQueryKey = (
  options: Options<GetAssessmentsByLessonData>,
) => createQueryKey("getAssessmentsByLesson", options)

export const getAssessmentsByLessonOptions = (
  options: Options<GetAssessmentsByLessonData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getAssessmentsByLesson({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      })
      return data
    },
    queryKey: getAssessmentsByLessonQueryKey(options),
  })
}

export const getAssessmentsByLessonInfiniteQueryKey = (
  options: Options<GetAssessmentsByLessonData>,
): QueryKey<Options<GetAssessmentsByLessonData>> =>
  createQueryKey("getAssessmentsByLesson", options, true)

export const getAssessmentsByLessonInfiniteOptions = (
  options: Options<GetAssessmentsByLessonData>,
) => {
  return infiniteQueryOptions<
    GetAssessmentsByLessonResponse,
    GetAssessmentsByLessonError,
    InfiniteData<GetAssessmentsByLessonResponse>,
    QueryKey<Options<GetAssessmentsByLessonData>>,
    | number
    | Pick<
        QueryKey<Options<GetAssessmentsByLessonData>>[0],
        "body" | "headers" | "path" | "query"
      >
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<GetAssessmentsByLessonData>>[0],
          "body" | "headers" | "path" | "query"
        > =
          typeof pageParam === "object"
            ? pageParam
            : {
                query: {
                  pageable: { page: pageParam },
                },
              }
        const params = createInfiniteParams(queryKey, page)
        const { data } = await getAssessmentsByLesson({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        })
        return data
      },
      queryKey: getAssessmentsByLessonInfiniteQueryKey(options),
    },
  )
}

export const getAssessmentsByCourseQueryKey = (
  options: Options<GetAssessmentsByCourseData>,
) => createQueryKey("getAssessmentsByCourse", options)

export const getAssessmentsByCourseOptions = (
  options: Options<GetAssessmentsByCourseData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getAssessmentsByCourse({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      })
      return data
    },
    queryKey: getAssessmentsByCourseQueryKey(options),
  })
}

export const getAssessmentsByCourseInfiniteQueryKey = (
  options: Options<GetAssessmentsByCourseData>,
): QueryKey<Options<GetAssessmentsByCourseData>> =>
  createQueryKey("getAssessmentsByCourse", options, true)

export const getAssessmentsByCourseInfiniteOptions = (
  options: Options<GetAssessmentsByCourseData>,
) => {
  return infiniteQueryOptions<
    GetAssessmentsByCourseResponse,
    GetAssessmentsByCourseError,
    InfiniteData<GetAssessmentsByCourseResponse>,
    QueryKey<Options<GetAssessmentsByCourseData>>,
    | number
    | Pick<
        QueryKey<Options<GetAssessmentsByCourseData>>[0],
        "body" | "headers" | "path" | "query"
      >
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<GetAssessmentsByCourseData>>[0],
          "body" | "headers" | "path" | "query"
        > =
          typeof pageParam === "object"
            ? pageParam
            : {
                query: {
                  pageable: { page: pageParam },
                },
              }
        const params = createInfiniteParams(queryKey, page)
        const { data } = await getAssessmentsByCourse({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        })
        return data
      },
      queryKey: getAssessmentsByCourseInfiniteQueryKey(options),
    },
  )
}
